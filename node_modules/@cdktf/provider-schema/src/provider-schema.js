"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.readModuleSchema = exports.sanitizeProviderSchema = exports.readProviderSchema = exports.parseFQPN = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const hcl2json_1 = require("@cdktf/hcl2json");
const commons_1 = require("@cdktf/commons");
const terraformBinaryName = process.env.TERRAFORM_BINARY_NAME || "terraform";
const parseFQPN = (f) => {
    const [hostname, namespace, name] = f.split("/");
    if (!name) {
        throw new Error(`can't handle ${f}`);
    }
    return { hostname, namespace, name };
};
exports.parseFQPN = parseFQPN;
const unwrapIfArray = (item) => Array.isArray(item) ? item[0] : item;
const transformVariables = (variables) => {
    var _a;
    const result = [];
    if (!variables)
        return result;
    for (const name of Object.keys(variables)) {
        const variable = unwrapIfArray(variables[name]);
        let variableType;
        if (
        // eslint-disable-next-line no-prototype-builtins
        variable.hasOwnProperty("type") == false &&
            // eslint-disable-next-line no-prototype-builtins
            variable.hasOwnProperty("default") == true) {
            switch (typeof variable["default"]) {
                case "boolean":
                    variableType = "bool";
                    break;
                case "number":
                    variableType = "number";
                    break;
                default:
                    variableType = "any";
            }
        }
        else {
            const matched = (_a = variable["type"]) === null || _a === void 0 ? void 0 : _a.match(/\$\{(.*)\}/);
            variableType = matched ? matched[1] : "any";
        }
        const item = {
            name,
            type: variableType,
            description: variable["description"],
            // eslint-disable-next-line no-prototype-builtins
            required: variable.hasOwnProperty("default") == false,
        };
        if (!item.required) {
            item["default"] = variable["default"];
        }
        result.push(item);
    }
    return result;
};
const transformOutputs = (outputs) => {
    const result = [];
    if (outputs) {
        for (const name of Object.keys(outputs)) {
            const output = unwrapIfArray(outputs[name]);
            const item = {
                name,
                description: output["description"],
            };
            result.push(item);
        }
    }
    return result;
};
const harvestModuleSchema = async (workingDirectory, modules) => {
    const fileName = path.join(workingDirectory, ".terraform", "modules", "modules.json");
    const result = {};
    if (!fs.existsSync(fileName)) {
        throw new Error(`Modules were not generated properly - couldn't find ${fileName}`);
    }
    const moduleIndex = JSON.parse(fs.readFileSync(fileName, "utf-8"));
    for (const mod of modules) {
        const m = moduleIndex.Modules.find((other) => mod === other.Key);
        if (!m) {
            throw new Error(`Couldn't find ${m}`);
        }
        const parsed = await (0, hcl2json_1.convertFiles)(path.join(workingDirectory, m.Dir));
        if (!parsed) {
            throw new Error(`Modules were not generated properly - couldn't parse ${m.Dir}`);
        }
        const schema = {
            inputs: transformVariables(parsed.variable),
            outputs: transformOutputs(parsed.output),
            name: mod,
        };
        result[mod] = schema;
    }
    return result;
};
async function readProviderSchema(target) {
    const config = {
        provider: {},
        terraform: {
            required_providers: {},
        },
    };
    config.provider[target.name] = {};
    config.terraform.required_providers[target.name] = {
        version: target.version,
        source: target.source,
    };
    let providerSchema = { format_version: "0.1" };
    await (0, commons_1.withTempDir)("fetchProviderSchema", async () => {
        const outdir = process.cwd();
        const filePath = path.join(outdir, "main.tf.json");
        await fs.writeFile(filePath, JSON.stringify(config));
        await (0, commons_1.exec)(terraformBinaryName, ["init"], { cwd: outdir });
        providerSchema = JSON.parse(await (0, commons_1.exec)(terraformBinaryName, ["providers", "schema", "-json"], {
            cwd: outdir,
        }));
        const versionSchema = JSON.parse(await (0, commons_1.exec)(terraformBinaryName, ["version", "-json"], {
            cwd: outdir,
        }));
        providerSchema.provider_versions = versionSchema.provider_selections;
    });
    return sanitizeProviderSchema(providerSchema);
}
exports.readProviderSchema = readProviderSchema;
// The providers have some potential bugs that we want to pro-actively
// fix here so that the rest of the code can assume a consistent schema.
function sanitizeProviderSchema(schema) {
    // Mainly some attributes are "doubled", e.g. ["list", "string", "list", "string"]
    // instead of ["list", "string"]
    function attributeDoublingFix(attribute) {
        if ((0, commons_1.isNestedTypeAttribute)(attribute) || !Array.isArray(attribute.type)) {
            return attribute;
        }
        const type = attribute.type.length === 2
            ? attribute.type
            : attribute.type.slice(0, 2); // The types tell us this can't happen, reality begs to differ
        attribute.type = type;
        return attribute;
    }
    // Mutates block with the fix
    function sanitizeBlock(block) {
        Object.values(block.attributes || {}).forEach(attributeDoublingFix);
        Object.values(block.block_types || {}).forEach((blockType) => {
            sanitizeBlock(blockType.block);
        });
    }
    Object.values(schema.provider_schemas || {}).forEach((provider) => {
        const entities = [
            provider.provider,
            ...Object.values(provider.resource_schemas || {}),
            ...Object.values(provider.data_source_schemas || {}),
        ];
        entities.forEach((entity) => {
            sanitizeBlock(entity.block);
        });
    });
    return schema;
}
exports.sanitizeProviderSchema = sanitizeProviderSchema;
async function readModuleSchema(target) {
    let moduleSchema = {};
    await (0, commons_1.withTempDir)("fetchSchema", async () => {
        const config = {
            terraform: {},
        };
        if (!config.module)
            config.module = {};
        let source = target.source;
        const localSource = target.constraint
            .localSourceAbsolutePath;
        if (localSource) {
            // create relative path to module in the user project
            source = path.relative(process.cwd(), localSource);
        }
        config.module[target.moduleKey] = { source: source };
        if (target.version) {
            config.module[target.moduleKey]["version"] = target.version;
        }
        const outdir = process.cwd();
        const filePath = path.join(outdir, "main.tf.json");
        await fs.writeFile(filePath, JSON.stringify(config));
        await (0, commons_1.exec)(terraformBinaryName, ["get"], { cwd: outdir });
        if (config.module) {
            moduleSchema = await harvestModuleSchema(outdir, Object.keys(config.module));
        }
    });
    return moduleSchema;
}
exports.readModuleSchema = readModuleSchema;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvdmlkZXItc2NoZW1hLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicHJvdmlkZXItc2NoZW1hLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyw2Q0FBK0I7QUFDL0IsMkNBQTZCO0FBRTdCLDhDQUErQztBQUMvQyw0Q0Fld0I7QUFFeEIsTUFBTSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQixJQUFJLFdBQVcsQ0FBQztBQVd0RSxNQUFNLFNBQVMsR0FBRyxDQUFDLENBQU8sRUFBRSxFQUFFO0lBQ25DLE1BQU0sQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakQsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNULE1BQU0sSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUM7S0FDdEM7SUFDRCxPQUFPLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBSWpDLENBQUM7QUFDSixDQUFDLENBQUM7QUFWVyxRQUFBLFNBQVMsYUFVcEI7QUFFRixNQUFNLGFBQWEsR0FBRyxDQUFJLElBQWEsRUFBSyxFQUFFLENBQzVDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBRXZDLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxTQUFjLEVBQUUsRUFBRTs7SUFDNUMsTUFBTSxNQUFNLEdBQVksRUFBRSxDQUFDO0lBRTNCLElBQUksQ0FBQyxTQUFTO1FBQUUsT0FBTyxNQUFNLENBQUM7SUFFOUIsS0FBSyxNQUFNLElBQUksSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1FBQ3pDLE1B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QUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsQ0FBQztRQUNuRCxNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUVyRCxNQUFNLElBQUEsY0FBSSxFQUFDLG1CQUFtQixFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUMxRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDakIsWUFBWSxHQUFHLE1BQU0sbUJBQW1CLENBQ3RDLE1BQU0sRUFDTixNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FDM0IsQ0FBQztTQUNIO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLFlBQVksQ0FBQztBQUN0QixDQUFDO0FBckNELDRDQXFDQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgSGFzaGlDb3JwLCBJbmNcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNUEwtMi4wXG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMtZXh0cmFcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcblxuaW1wb3J0IHsgY29udmVydEZpbGVzIH0gZnJvbSBcIkBjZGt0Zi9oY2wyanNvblwiO1xuaW1wb3J0IHtcbiAgQXR0cmlidXRlLFxuICBBdHRyaWJ1dGVUeXBlLFxuICBCbG9jayxcbiAgQ29uc3RydWN0c01ha2VyTW9kdWxlVGFyZ2V0LFxuICBDb25zdHJ1Y3RzTWFrZXJQcm92aWRlclRhcmdldCxcbiAgSW5wdXQsXG4gIE1vZHVsZUluZGV4LFxuICBNb2R1bGVTY2hlbWEsXG4gIFByb3ZpZGVyU2NoZW1hLFxuICBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50LFxuICBWZXJzaW9uU2NoZW1hLFxuICBleGVjLFxuICBpc05lc3RlZFR5cGVBdHRyaWJ1dGUsXG4gIHdpdGhUZW1wRGlyLFxufSBmcm9tIFwiQGNka3RmL2NvbW1vbnNcIjtcblxuY29uc3QgdGVycmFmb3JtQmluYXJ5TmFtZSA9IHByb2Nlc3MuZW52LlRFUlJBRk9STV9CSU5BUllfTkFNRSB8fCBcInRlcnJhZm9ybVwiO1xuXG4vKipcbiAqIEZ1bGx5IFF1YWxpZmllZCBwcm92aWRlciBuYW1lIGluIHRoZSBmb3JtYXQ6XG4gKiBsaWtlIGUuZy4gcmVnaXN0cnkudGVycmFmb3JtLmlvL2hhc2hpY29ycC9hd3NcbiAqL1xuZXhwb3J0IHR5cGUgRlFQTiA9IHN0cmluZyAmIHsgX190eXBlOiBcIkZ1bGx5UXVhbGlmaWVkUHJvdmlkZXJOYW1lXCIgfTtcbmV4cG9ydCB0eXBlIFByb3ZpZGVySG9zdG5hbWUgPSBzdHJpbmcgJiB7IF9fdHlwZTogXCJQcm92aWRlckhvc3RuYW1lXCIgfTtcbmV4cG9ydCB0eXBlIFByb3ZpZGVyTmFtZXNwYWNlID0gc3RyaW5nICYgeyBfX3R5cGU6IFwiUHJvdmlkZXJOYW1lc3BhY2VcIiB9O1xuZXhwb3J0IHR5cGUgUHJvdmlkZXJOYW1lID0gc3RyaW5nICYgeyBfX3R5cGU6IFwiUHJvdmlkZXJOYW1lXCIgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlRlFQTiA9IChmOiBGUVBOKSA9PiB7XG4gIGNvbnN0IFtob3N0bmFtZSwgbmFtZXNwYWNlLCBuYW1lXSA9IGYuc3BsaXQoXCIvXCIpO1xuICBpZiAoIW5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbid0IGhhbmRsZSAke2Z9YCk7XG4gIH1cbiAgcmV0dXJuIHsgaG9zdG5hbWUsIG5hbWVzcGFjZSwgbmFtZSB9IGFzIHtcbiAgICBob3N0bmFtZTogUHJvdmlkZXJIb3N0bmFtZTtcbiAgICBuYW1lc3BhY2U6IFByb3ZpZGVyTmFtZXNwYWNlO1xuICAgIG5hbWU6IFByb3ZpZGVyTmFtZTtcbiAgfTtcbn07XG5cbmNvbnN0IHVud3JhcElmQXJyYXkgPSA8VD4oaXRlbTogVCB8IFRbXSk6IFQgPT5cbiAgQXJyYXkuaXNBcnJheShpdGVtKSA/IGl0ZW1bMF0gOiBpdGVtO1xuXG5jb25zdCB0cmFuc2Zvcm1WYXJpYWJsZXMgPSAodmFyaWFibGVzOiBhbnkpID0+IHtcbiAgY29uc3QgcmVzdWx0OiBJbnB1dFtdID0gW107XG5cbiAgaWYgKCF2YXJpYWJsZXMpIHJldHVybiByZXN1bHQ7XG5cbiAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHZhcmlhYmxlcykpIHtcbiAgICBjb25zdCB2YXJpYWJsZSA9IHVud3JhcElmQXJyYXkodmFyaWFibGVzW25hbWVdKTtcbiAgICBsZXQgdmFyaWFibGVUeXBlOiBzdHJpbmc7XG5cbiAgICBpZiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICB2YXJpYWJsZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikgPT0gZmFsc2UgJiZcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIHZhcmlhYmxlLmhhc093blByb3BlcnR5KFwiZGVmYXVsdFwiKSA9PSB0cnVlXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YXJpYWJsZVtcImRlZmF1bHRcIl0pIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICB2YXJpYWJsZVR5cGUgPSBcImJvb2xcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgIHZhcmlhYmxlVHlwZSA9IFwibnVtYmVyXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFyaWFibGVUeXBlID0gXCJhbnlcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF0Y2hlZCA9ICh2YXJpYWJsZVtcInR5cGVcIl0gYXMgc3RyaW5nKT8ubWF0Y2goL1xcJFxceyguKilcXH0vKTtcbiAgICAgIHZhcmlhYmxlVHlwZSA9IG1hdGNoZWQgPyBtYXRjaGVkWzFdIDogXCJhbnlcIjtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtOiBJbnB1dCA9IHtcbiAgICAgIG5hbWUsXG4gICAgICB0eXBlOiB2YXJpYWJsZVR5cGUsXG4gICAgICBkZXNjcmlwdGlvbjogdmFyaWFibGVbXCJkZXNjcmlwdGlvblwiXSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIHJlcXVpcmVkOiB2YXJpYWJsZS5oYXNPd25Qcm9wZXJ0eShcImRlZmF1bHRcIikgPT0gZmFsc2UsXG4gICAgfTtcblxuICAgIGlmICghaXRlbS5yZXF1aXJlZCkge1xuICAgICAgaXRlbVtcImRlZmF1bHRcIl0gPSB2YXJpYWJsZVtcImRlZmF1bHRcIl07XG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgdHJhbnNmb3JtT3V0cHV0cyA9IChvdXRwdXRzOiBhbnkpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgaWYgKG91dHB1dHMpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMob3V0cHV0cykpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IHVud3JhcElmQXJyYXkob3V0cHV0c1tuYW1lXSk7XG5cbiAgICAgIGNvbnN0IGl0ZW06IGFueSA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IG91dHB1dFtcImRlc2NyaXB0aW9uXCJdLFxuICAgICAgfTtcblxuICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGhhcnZlc3RNb2R1bGVTY2hlbWEgPSBhc3luYyAoXG4gIHdvcmtpbmdEaXJlY3Rvcnk6IHN0cmluZyxcbiAgbW9kdWxlczogc3RyaW5nW11cbik6IFByb21pc2U8UmVjb3JkPHN0cmluZywgYW55Pj4gPT4ge1xuICBjb25zdCBmaWxlTmFtZSA9IHBhdGguam9pbihcbiAgICB3b3JraW5nRGlyZWN0b3J5LFxuICAgIFwiLnRlcnJhZm9ybVwiLFxuICAgIFwibW9kdWxlc1wiLFxuICAgIFwibW9kdWxlcy5qc29uXCJcbiAgKTtcbiAgY29uc3QgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG5cbiAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGVOYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBNb2R1bGVzIHdlcmUgbm90IGdlbmVyYXRlZCBwcm9wZXJseSAtIGNvdWxkbid0IGZpbmQgJHtmaWxlTmFtZX1gXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IG1vZHVsZUluZGV4ID0gSlNPTi5wYXJzZShcbiAgICBmcy5yZWFkRmlsZVN5bmMoZmlsZU5hbWUsIFwidXRmLThcIilcbiAgKSBhcyBNb2R1bGVJbmRleDtcblxuICBmb3IgKGNvbnN0IG1vZCBvZiBtb2R1bGVzKSB7XG4gICAgY29uc3QgbSA9IG1vZHVsZUluZGV4Lk1vZHVsZXMuZmluZCgob3RoZXIpID0+IG1vZCA9PT0gb3RoZXIuS2V5KTtcblxuICAgIGlmICghbSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBmaW5kICR7bX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWQgPSBhd2FpdCBjb252ZXJ0RmlsZXMocGF0aC5qb2luKHdvcmtpbmdEaXJlY3RvcnksIG0uRGlyKSk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTW9kdWxlcyB3ZXJlIG5vdCBnZW5lcmF0ZWQgcHJvcGVybHkgLSBjb3VsZG4ndCBwYXJzZSAke20uRGlyfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NoZW1hOiBNb2R1bGVTY2hlbWEgPSB7XG4gICAgICBpbnB1dHM6IHRyYW5zZm9ybVZhcmlhYmxlcyhwYXJzZWQudmFyaWFibGUpLFxuICAgICAgb3V0cHV0czogdHJhbnNmb3JtT3V0cHV0cyhwYXJzZWQub3V0cHV0KSxcbiAgICAgIG5hbWU6IG1vZCxcbiAgICB9O1xuXG4gICAgcmVzdWx0W21vZF0gPSBzY2hlbWE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBUZXJyYWZvcm1Db25maWcge1xuICBwcm92aWRlcj86IHsgW25hbWU6IHN0cmluZ106IFJlY29yZDxzdHJpbmcsIGFueT4gfTtcbiAgdGVycmFmb3JtOiB7XG4gICAgcmVxdWlyZWRfcHJvdmlkZXJzPzoge1xuICAgICAgW25hbWU6IHN0cmluZ106IHsgc291cmNlPzogc3RyaW5nOyB2ZXJzaW9uPzogc3RyaW5nIH07XG4gICAgfTtcbiAgfTtcbiAgbW9kdWxlPzogeyBbbmFtZTogc3RyaW5nXTogeyBzb3VyY2U6IHN0cmluZzsgdmVyc2lvbj86IHN0cmluZyB9IH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkUHJvdmlkZXJTY2hlbWEoXG4gIHRhcmdldDogQ29uc3RydWN0c01ha2VyUHJvdmlkZXJUYXJnZXRcbikge1xuICBjb25zdCBjb25maWc6IFRlcnJhZm9ybUNvbmZpZyA9IHtcbiAgICBwcm92aWRlcjoge30sXG4gICAgdGVycmFmb3JtOiB7XG4gICAgICByZXF1aXJlZF9wcm92aWRlcnM6IHt9LFxuICAgIH0sXG4gIH07XG5cbiAgY29uZmlnLnByb3ZpZGVyIVt0YXJnZXQubmFtZV0gPSB7fTtcbiAgY29uZmlnLnRlcnJhZm9ybS5yZXF1aXJlZF9wcm92aWRlcnMhW3RhcmdldC5uYW1lXSA9IHtcbiAgICB2ZXJzaW9uOiB0YXJnZXQudmVyc2lvbixcbiAgICBzb3VyY2U6IHRhcmdldC5zb3VyY2UsXG4gIH07XG5cbiAgbGV0IHByb3ZpZGVyU2NoZW1hOiBQcm92aWRlclNjaGVtYSA9IHsgZm9ybWF0X3ZlcnNpb246IFwiMC4xXCIgfTtcblxuICBhd2FpdCB3aXRoVGVtcERpcihcImZldGNoUHJvdmlkZXJTY2hlbWFcIiwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG91dGRpciA9IHByb2Nlc3MuY3dkKCk7XG4gICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4ob3V0ZGlyLCBcIm1haW4udGYuanNvblwiKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KGNvbmZpZykpO1xuXG4gICAgYXdhaXQgZXhlYyh0ZXJyYWZvcm1CaW5hcnlOYW1lLCBbXCJpbml0XCJdLCB7IGN3ZDogb3V0ZGlyIH0pO1xuICAgIHByb3ZpZGVyU2NoZW1hID0gSlNPTi5wYXJzZShcbiAgICAgIGF3YWl0IGV4ZWModGVycmFmb3JtQmluYXJ5TmFtZSwgW1wicHJvdmlkZXJzXCIsIFwic2NoZW1hXCIsIFwiLWpzb25cIl0sIHtcbiAgICAgICAgY3dkOiBvdXRkaXIsXG4gICAgICB9KVxuICAgICkgYXMgUHJvdmlkZXJTY2hlbWE7XG5cbiAgICBjb25zdCB2ZXJzaW9uU2NoZW1hID0gSlNPTi5wYXJzZShcbiAgICAgIGF3YWl0IGV4ZWModGVycmFmb3JtQmluYXJ5TmFtZSwgW1widmVyc2lvblwiLCBcIi1qc29uXCJdLCB7XG4gICAgICAgIGN3ZDogb3V0ZGlyLFxuICAgICAgfSlcbiAgICApIGFzIFZlcnNpb25TY2hlbWE7XG5cbiAgICBwcm92aWRlclNjaGVtYS5wcm92aWRlcl92ZXJzaW9ucyA9IHZlcnNpb25TY2hlbWEucHJvdmlkZXJfc2VsZWN0aW9ucztcbiAgfSk7XG5cbiAgcmV0dXJuIHNhbml0aXplUHJvdmlkZXJTY2hlbWEocHJvdmlkZXJTY2hlbWEpO1xufVxuXG4vLyBUaGUgcHJvdmlkZXJzIGhhdmUgc29tZSBwb3RlbnRpYWwgYnVncyB0aGF0IHdlIHdhbnQgdG8gcHJvLWFjdGl2ZWx5XG4vLyBmaXggaGVyZSBzbyB0aGF0IHRoZSByZXN0IG9mIHRoZSBjb2RlIGNhbiBhc3N1bWUgYSBjb25zaXN0ZW50IHNjaGVtYS5cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZVByb3ZpZGVyU2NoZW1hKHNjaGVtYTogUHJvdmlkZXJTY2hlbWEpOiBQcm92aWRlclNjaGVtYSB7XG4gIC8vIE1haW5seSBzb21lIGF0dHJpYnV0ZXMgYXJlIFwiZG91YmxlZFwiLCBlLmcuIFtcImxpc3RcIiwgXCJzdHJpbmdcIiwgXCJsaXN0XCIsIFwic3RyaW5nXCJdXG4gIC8vIGluc3RlYWQgb2YgW1wibGlzdFwiLCBcInN0cmluZ1wiXVxuICBmdW5jdGlvbiBhdHRyaWJ1dGVEb3VibGluZ0ZpeChhdHRyaWJ1dGU6IEF0dHJpYnV0ZSk6IEF0dHJpYnV0ZSB7XG4gICAgaWYgKGlzTmVzdGVkVHlwZUF0dHJpYnV0ZShhdHRyaWJ1dGUpIHx8ICFBcnJheS5pc0FycmF5KGF0dHJpYnV0ZS50eXBlKSkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID1cbiAgICAgIGF0dHJpYnV0ZS50eXBlLmxlbmd0aCA9PT0gMlxuICAgICAgICA/IGF0dHJpYnV0ZS50eXBlXG4gICAgICAgIDogKGF0dHJpYnV0ZS50eXBlIGFzIHN0cmluZ1tdKS5zbGljZSgwLCAyKTsgLy8gVGhlIHR5cGVzIHRlbGwgdXMgdGhpcyBjYW4ndCBoYXBwZW4sIHJlYWxpdHkgYmVncyB0byBkaWZmZXJcblxuICAgIGF0dHJpYnV0ZS50eXBlID0gdHlwZSBhcyBBdHRyaWJ1dGVUeXBlO1xuICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gIH1cblxuICAvLyBNdXRhdGVzIGJsb2NrIHdpdGggdGhlIGZpeFxuICBmdW5jdGlvbiBzYW5pdGl6ZUJsb2NrKGJsb2NrOiBCbG9jaykge1xuICAgIE9iamVjdC52YWx1ZXMoYmxvY2suYXR0cmlidXRlcyB8fCB7fSkuZm9yRWFjaChhdHRyaWJ1dGVEb3VibGluZ0ZpeCk7XG4gICAgT2JqZWN0LnZhbHVlcyhibG9jay5ibG9ja190eXBlcyB8fCB7fSkuZm9yRWFjaCgoYmxvY2tUeXBlKSA9PiB7XG4gICAgICBzYW5pdGl6ZUJsb2NrKGJsb2NrVHlwZS5ibG9jayk7XG4gICAgfSk7XG4gIH1cblxuICBPYmplY3QudmFsdWVzKHNjaGVtYS5wcm92aWRlcl9zY2hlbWFzIHx8IHt9KS5mb3JFYWNoKChwcm92aWRlcikgPT4ge1xuICAgIGNvbnN0IGVudGl0aWVzID0gW1xuICAgICAgcHJvdmlkZXIucHJvdmlkZXIsXG4gICAgICAuLi5PYmplY3QudmFsdWVzKHByb3ZpZGVyLnJlc291cmNlX3NjaGVtYXMgfHwge30pLFxuICAgICAgLi4uT2JqZWN0LnZhbHVlcyhwcm92aWRlci5kYXRhX3NvdXJjZV9zY2hlbWFzIHx8IHt9KSxcbiAgICBdO1xuXG4gICAgZW50aXRpZXMuZm9yRWFjaCgoZW50aXR5KSA9PiB7XG4gICAgICBzYW5pdGl6ZUJsb2NrKGVudGl0eS5ibG9jayk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzY2hlbWE7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkTW9kdWxlU2NoZW1hKHRhcmdldDogQ29uc3RydWN0c01ha2VyTW9kdWxlVGFyZ2V0KSB7XG4gIGxldCBtb2R1bGVTY2hlbWE6IFJlY29yZDxzdHJpbmcsIE1vZHVsZVNjaGVtYT4gPSB7fTtcblxuICBhd2FpdCB3aXRoVGVtcERpcihcImZldGNoU2NoZW1hXCIsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjb25maWc6IFRlcnJhZm9ybUNvbmZpZyA9IHtcbiAgICAgIHRlcnJhZm9ybToge30sXG4gICAgfTtcblxuICAgIGlmICghY29uZmlnLm1vZHVsZSkgY29uZmlnLm1vZHVsZSA9IHt9O1xuICAgIGxldCBzb3VyY2U6IHN0cmluZyA9IHRhcmdldC5zb3VyY2U7XG5cbiAgICBjb25zdCBsb2NhbFNvdXJjZSA9ICh0YXJnZXQuY29uc3RyYWludCBhcyBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50KVxuICAgICAgLmxvY2FsU291cmNlQWJzb2x1dGVQYXRoO1xuICAgIGlmIChsb2NhbFNvdXJjZSkge1xuICAgICAgLy8gY3JlYXRlIHJlbGF0aXZlIHBhdGggdG8gbW9kdWxlIGluIHRoZSB1c2VyIHByb2plY3RcbiAgICAgIHNvdXJjZSA9IHBhdGgucmVsYXRpdmUocHJvY2Vzcy5jd2QoKSwgbG9jYWxTb3VyY2UpO1xuICAgIH1cblxuICAgIGNvbmZpZy5tb2R1bGVbdGFyZ2V0Lm1vZHVsZUtleV0gPSB7IHNvdXJjZTogc291cmNlIH07XG4gICAgaWYgKHRhcmdldC52ZXJzaW9uKSB7XG4gICAgICBjb25maWcubW9kdWxlW3RhcmdldC5tb2R1bGVLZXldW1widmVyc2lvblwiXSA9IHRhcmdldC52ZXJzaW9uO1xuICAgIH1cblxuICAgIGNvbnN0IG91dGRpciA9IHByb2Nlc3MuY3dkKCk7XG4gICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4ob3V0ZGlyLCBcIm1haW4udGYuanNvblwiKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KGNvbmZpZykpO1xuXG4gICAgYXdhaXQgZXhlYyh0ZXJyYWZvcm1CaW5hcnlOYW1lLCBbXCJnZXRcIl0sIHsgY3dkOiBvdXRkaXIgfSk7XG4gICAgaWYgKGNvbmZpZy5tb2R1bGUpIHtcbiAgICAgIG1vZHVsZVNjaGVtYSA9IGF3YWl0IGhhcnZlc3RNb2R1bGVTY2hlbWEoXG4gICAgICAgIG91dGRpcixcbiAgICAgICAgT2JqZWN0LmtleXMoY29uZmlnLm1vZHVsZSlcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbW9kdWxlU2NoZW1hO1xufVxuIl19