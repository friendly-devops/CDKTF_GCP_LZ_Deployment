"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineGoModuleName = exports.ConstructsMaker = exports.generateJsiiLanguage = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const codemaker_1 = require("codemaker");
const commons_1 = require("@cdktf/commons");
const commons_2 = require("@cdktf/commons");
const commons_3 = require("@cdktf/commons");
const provider_generator_1 = require("./generator/provider-generator");
const module_generator_1 = require("./generator/module-generator");
const glob_1 = require("glob");
const provider_schema_1 = require("@cdktf/provider-schema");
const pacmakModule = require.resolve("jsii-pacmak/bin/jsii-pacmak");
const jsiiModule = require.resolve("jsii/bin/jsii");
async function generateJsiiLanguage(code, opts, outputPath, disallowedFileGlobs = []) {
    await (0, commons_1.mkdtemp)(async (staging) => {
        // this is not typescript, so we generate in a staging directory and
        // use jsii-srcmak to compile and extract the language-specific source
        // into our project.
        await code.save(staging);
        // as the above generated the Typescript code for all providers and modules,
        // we need to filter out the ones we don't need so they don't end up in the JSII bundle over and over again.
        const filesToDelete = disallowedFileGlobs.flatMap((pattern) => glob_1.glob.sync(pattern, { cwd: staging }));
        await Promise.all(filesToDelete.map((file) => fs.remove(path.join(staging, file))));
        // Compile with JSII
        const jsiiArgs = ["--silence-warnings", "reserved-word"];
        const jsiiEntrypoint = opts.entrypoint;
        const basepath = path.join(path.dirname(jsiiEntrypoint), path.basename(jsiiEntrypoint, ".ts"));
        const moduleKey = opts.moduleKey.replace(/\./g, "").replace(/\//g, "");
        const moduleDirs = opts.deps;
        const targets = {};
        const deps = {};
        for (const dir of moduleDirs) {
            // read module metadata
            const metadata = await fs.readJson(path.join(dir, "package.json"));
            const moduleName = metadata.name;
            const moduleVersion = metadata.version;
            const targetdir = path.join(path.join(staging, "node_modules"), moduleName);
            await fs.mkdirp(path.dirname(targetdir));
            await fs.copy(dir, targetdir);
            // add to "deps" and "peer deps"
            if (!moduleName.startsWith("@types/")) {
                deps[moduleName] = moduleVersion;
            }
        }
        const pkg = {
            name: moduleKey,
            version: "0.0.0",
            author: "generated@generated.com",
            main: `${basepath}.js`,
            types: `${basepath}.d.ts`,
            license: "UNLICENSED",
            repository: { url: "http://generated", type: "git" },
            jsii: {
                outdir: "dist",
                targets: targets,
            },
            dependencies: deps,
            peerDependencies: deps,
        };
        if (opts.exports) {
            pkg.exports = opts.exports;
        }
        if (opts.python) {
            targets.python = {
                distName: "generated",
                module: opts.python.moduleName,
            };
        }
        if (opts.java) {
            targets.java = {
                package: opts.java.package,
                maven: {
                    groupId: "generated",
                    artifactId: "generated",
                },
            };
        }
        if (opts.csharp) {
            targets.dotnet = {
                namespace: opts.csharp.namespace,
                packageId: opts.csharp.namespace,
            };
        }
        if (opts.golang) {
            targets.go = {
                moduleName: opts.golang.moduleName,
                packageName: opts.golang.packageName,
            };
        }
        await fs.writeFile(path.join(staging, "package.json"), JSON.stringify(pkg, undefined, 2));
        const endJsiiTimer = (0, commons_2.logTimespan)("jsii");
        await (0, commons_1.exec)(jsiiModule, jsiiArgs, {
            cwd: staging,
        });
        endJsiiTimer();
        // extract .jsii if requested
        if (opts.jsii) {
            await fs.copy(path.join(staging, ".jsii"), opts.jsii.path);
        }
        // run pacmak to generate code
        const endJsiiPacmakTimer = (0, commons_2.logTimespan)("jsii-pacmak");
        await (0, commons_1.exec)(pacmakModule, ["--code-only"], { cwd: staging });
        endJsiiPacmakTimer();
        if (opts.python) {
            const reldir = opts.python.moduleName.replace(/\./g, "/"); // jsii replaces "." with "/"
            const source = path.resolve(path.join(staging, "dist/python/src", reldir));
            const target = path.join(opts.python.outdir, reldir);
            await fs.move(source, target, { overwrite: true });
        }
        if (opts.java) {
            const source = path.resolve(path.join(staging, "dist/java/src/"));
            const target = path.join(opts.java.outdir, "src/");
            await fs.mkdirp(target); // make sure target directory exists
            await fs.copy(source, target, { recursive: true, overwrite: false });
        }
        if (opts.csharp) {
            const reldir = opts.csharp.namespace;
            const source = path.resolve(path.join(staging, "dist/dotnet/", reldir));
            const target = path.join(opts.csharp.outdir, reldir);
            await fs.move(source, target, { overwrite: true });
        }
        if (opts.golang) {
            const reldir = opts.golang.packageName;
            const source = path.resolve(path.join(staging, "dist/go/", reldir));
            const target = path.join(opts.golang.outdir, reldir);
            await fs.move(source, target, { overwrite: true });
            // remove go.mod as this would make it a submodule
            await fs.remove(path.join(target, "go.mod"));
        }
        ["versions.json", "constraints.json"].forEach((file) => {
            try {
                fs.copySync(path.resolve(staging, file), path.resolve(outputPath, file));
            }
            catch (e) {
                commons_2.logger.debug(`Failed to copy ${file}: ${e}`);
            }
        });
    });
}
exports.generateJsiiLanguage = generateJsiiLanguage;
class ConstructsMaker {
    constructor(options, schemaCachePath, reportTelemetry = async () => { }) {
        this.options = options;
        this.schemaCachePath = schemaCachePath;
        this.reportTelemetry = reportTelemetry;
        this.codeMakerOutdir = path.resolve(this.options.codeMakerOutput);
        fs.mkdirpSync(this.codeMakerOutdir);
        this.code = new codemaker_1.CodeMaker();
        this.versions = {};
    }
    async generateTypescriptProvider(target, schema) {
        const endTSTimer = (0, commons_2.logTimespan)(`Generate Typescript for ${target.name}`);
        const generator = new provider_generator_1.TerraformProviderGenerator(this.code, schema);
        generator.generate(target);
        this.versions = { ...this.versions, ...generator.versions };
        endTSTimer();
    }
    async filterAlreadyGenerated(constraints) {
        let constraintsFile = "{}";
        try {
            constraintsFile = await fs.readFile(path.join(this.codeMakerOutdir, "constraints.json"), "utf8");
        }
        catch (e) {
            commons_2.logger.debug(`Could not find constraints.json file while filtering: ${e}. This means no providers were generated, so all constraints need to be generated.`);
            return constraints;
        }
        commons_2.logger.debug(`Found constraints.json file: ${constraintsFile}`);
        let previousConstraints = {};
        try {
            previousConstraints = JSON.parse(constraintsFile);
        }
        catch (e) {
            commons_2.logger.info(`Could not parse constraints.json file while filtering: ${e}. Generating all constraints.`);
            return constraints;
        }
        commons_2.logger.debug(`Found previous constraints: ${JSON.stringify(previousConstraints, null, 2)}`);
        if (!previousConstraints.providers ||
            typeof previousConstraints.providers !== "object") {
            commons_2.logger.info(`Could not find providers in constraints.json file, generating all constraints. The constraints file was ${JSON.stringify(previousConstraints, null, 2)}`);
            return constraints;
        }
        if (previousConstraints.cdktf !== commons_3.DISPLAY_VERSION) {
            commons_2.logger.info(`The CDKTF version has changed, generating all constraints. The previous version was ${previousConstraints.cdktf}, the current version is ${commons_3.DISPLAY_VERSION}`);
            return constraints;
        }
        const constraintsToGenerate = constraints.filter((constraint) => {
            const constraintMatches = previousConstraints.providers[constraint.fqn] === constraint.version;
            let providerFolderExists = false;
            switch (this.options.targetLanguage) {
                case commons_3.Language.TYPESCRIPT:
                    providerFolderExists = fs.existsSync(path.join(this.codeMakerOutdir, "providers", constraint.name));
                    break;
                case commons_3.Language.PYTHON:
                case commons_3.Language.JAVA:
                case commons_3.Language.CSHARP:
                    providerFolderExists = fs.existsSync(path.join(this.codeMakerOutdir, constraint.name));
                    break;
                case commons_3.Language.GO:
                    providerFolderExists = fs.existsSync(path.join(this.codeMakerOutdir, constraint.namespace || "hashicorp", constraint.name));
                    break;
            }
            const providerExists = constraintMatches && providerFolderExists;
            return !providerExists;
        });
        commons_2.logger.debug(`Constraints to generate: ${JSON.stringify(constraintsToGenerate, null, 2)}`);
        return constraintsToGenerate;
    }
    async generateTypescriptModule(target, schema) {
        const endTSTimer = (0, commons_2.logTimespan)(`Generate Typescript for ${target.name}`);
        target.spec = schema;
        new module_generator_1.ModuleGenerator(this.code, [target]);
        endTSTimer();
    }
    async generateTypescript(target, schemas) {
        var _a;
        if (target.isModule) {
            const schema = (_a = schemas.moduleSchema) === null || _a === void 0 ? void 0 : _a[target.moduleKey];
            if (!schema) {
                throw commons_2.Errors.Internal(`Could not generate schema for module ${target.moduleKey}`);
            }
            await this.generateTypescriptModule(target, schema);
        }
        else if (target.isProvider) {
            if (!schemas.providerSchema) {
                throw commons_2.Errors.Internal(`Could not generate schema for providers`);
            }
            await this.generateTypescriptProvider(target, schemas.providerSchema);
        }
        else {
            throw new Error(`Unknown target type used to generate bindings: ${target.name}`);
        }
    }
    // emits a versions.json file with a map of the used version for each provider fqpn
    updateVersionsFile(allowedConstraints) {
        commons_2.logger.debug(`Updating versions file with generated versions ${JSON.stringify(this.versions, null, 2)} with allowed constraints ${JSON.stringify(allowedConstraints, null, 2)}`);
        const filePath = "versions.json";
        let previousVersions = {};
        try {
            previousVersions = JSON.parse(fs.readFileSync(path.resolve(this.codeMakerOutdir, filePath), "utf8"));
            commons_2.logger.debug(`Read existing versions file: ${JSON.stringify(previousVersions, null, 2)}`);
        }
        catch (e) {
            // ignore
            commons_2.logger.debug(`Could not read versions file, this is expected if there are no pre-existing local providers: ${e}`);
        }
        const versions = allowedConstraints.reduce((acc, constraint) => {
            const provider = Object.entries(previousVersions).find(([name]) => 
            // This could be more refined, but it's good enough for now
            name.endsWith(constraint.fqn));
            if (provider) {
                const [name, version] = provider;
                return { ...acc, [name]: version };
            }
            return acc;
        }, {});
        commons_2.logger.debug(`Writing versions file (${filePath}): ${JSON.stringify(versions, null, 2)}`);
        this.code.openFile(filePath);
        this.code.line(JSON.stringify({ ...versions, ...this.versions }, null, 2));
        this.code.closeFile(filePath);
        return filePath;
    }
    async removeFoldersThatShouldNotExist(constraintsThatShouldExist) {
        commons_2.logger.debug(`Removing providers except for ${JSON.stringify(constraintsThatShouldExist, null, 2)}`);
        // All languages besides TS keep their providers in the same folders as modules
        // this makes it impossible for us to distinguish a no longer required provider
        // from a manually written construct or a module
        if (!this.isJavascriptTarget) {
            return;
        }
        let filesInProviders = [];
        const providersFolder = path.resolve(this.codeMakerOutdir, "providers");
        try {
            filesInProviders = await fs.readdir(providersFolder);
        }
        catch (e) {
            commons_2.logger.debug(`Error listing files in providers folder '${providersFolder}': ${e}`);
        }
        const folders = filesInProviders.filter((file) => fs
            .statSync(path.resolve(this.codeMakerOutdir, "providers", file))
            .isDirectory());
        return folders.forEach((folder) => {
            const shouldExist = constraintsThatShouldExist.some((constraint) => constraint.name === folder);
            if (!shouldExist) {
                commons_2.logger.debug(`Removing folder ${folder} from providers`);
                fs.removeSync(path.resolve(this.codeMakerOutdir, "providers", folder));
            }
        });
    }
    // emits a constraints.json file with a map of the used provider fqpns and version constraints
    // this is used for caching purposes
    emitConstraintsFile(allowedConstraints) {
        const filePath = "constraints.json";
        const content = {
            cdktf: commons_3.DISPLAY_VERSION,
            providers: allowedConstraints
                .sort((a, b) => a.fqn.localeCompare(b.fqn))
                .reduce((carry, item) => ({
                ...carry,
                [item.fqn]: item.version,
            }), {}),
        };
        this.code.openFile(filePath);
        this.code.line(JSON.stringify(content, null, 2));
        this.code.closeFile(filePath);
        return filePath;
    }
    async generateJsiiLanguage(target) {
        var _a;
        // these are the module dependencies we compile against
        const deps = ["@types/node", "constructs", "cdktf"];
        const opts = {
            entrypoint: target.fileName,
            deps: deps.map((dep) => path.dirname(require.resolve(`${dep}/package.json`))),
            moduleKey: target.moduleKey,
            exports: target.isProvider // Modules are small enough that we don't need this optimization
                ? {
                    ".": {
                        import: `./providers/${target.name}/index.js`,
                        require: `./providers/${target.name}/lazy-index.js`,
                    },
                }
                : undefined,
        };
        // used for testing.
        if (this.options.outputJsii) {
            opts.jsii = { path: this.options.outputJsii };
        }
        if (this.isPythonTarget) {
            opts.python = {
                outdir: this.codeMakerOutdir,
                moduleName: target.srcMakName,
            };
        }
        if (this.isJavaTarget) {
            if (this.options.codeMakerOutput.includes("/") ||
                this.options.codeMakerOutput.includes("\\")) {
                throw commons_2.Errors.Usage(`When using Java the "codeMakerOutput" option in the cdktf.json must be the organization identifier for your project (e.g. com.my-company), not a path. The generated Java code will be placed in a subdirectory of the given directory. If you are migrating from a < 0.19 version of cdktf you want to change the codemakerOutput to "imports".`);
            }
            opts.java = {
                outdir: ".",
                package: `${this.options.codeMakerOutput}.${target.srcMakName}`,
            };
        }
        if (this.isCsharpTarget) {
            opts.csharp = {
                outdir: this.codeMakerOutdir,
                namespace: target.srcMakName,
            };
        }
        if (this.isGoTarget) {
            // TODO: check if needed for modules somehow
            // const targetType = target.isProvider ? 'provider' : 'module';
            // jsii-srcmac will produce a folder inside this dir named after "packageName"
            // so this results in e.g. .gen/hashicorp/random
            const outdir = path.join(this.codeMakerOutdir, (_a = target.namespace) !== null && _a !== void 0 ? _a : "");
            opts.golang = {
                outdir,
                moduleName: await (0, exports.determineGoModuleName)(outdir),
                packageName: target.srcMakName, // package will be named e.g. random for hashicorp/random
            };
        }
        if (process.env.NODE_OPTIONS &&
            !process.env.NODE_OPTIONS.includes(`--max-old-space-size`)) {
            commons_2.logger.warn(`found NODE_OPTIONS environment variable without a setting for --max-old-space-size.
The provider generation needs a substantial amount of memory (~13GB) for some providers and languages.
So cdktf-cli sets it to NODE_OPTIONS="--max-old-space-size=16384" by default. As your environment already contains
a NODE_OPTIONS variable, we won't override it. Hence, the provider generation might fail with an out of memory error.`);
        }
        else {
            // increase memory to allow generating large providers (i.e. aws or azurerm for Go)
            // srcmak is going to spawn a childprocess (for jsii-pacmak) which is going to be affected by this env var
            process.env.NODE_OPTIONS = "--max-old-space-size=16384";
        }
        const jsiiTimer = (0, commons_2.logTimespan)("JSII");
        await generateJsiiLanguage(this.code, opts, this.codeMakerOutdir, [
            target.isModule ? "providers/**" : "modules/**",
        ]);
        jsiiTimer();
    }
    async getSchemas(targets) {
        return await (0, provider_schema_1.readSchema)(targets, this.schemaCachePath);
    }
    async generate(allConstraints, constraintsToGenerate = allConstraints) {
        const targets = constraintsToGenerate.map((constraint) => commons_2.ConstructsMakerTarget.from(constraint, this.options.targetLanguage));
        const endSchemaTimer = (0, commons_2.logTimespan)("Gathering schema");
        const schemas = await this.getSchemas(constraintsToGenerate);
        endSchemaTimer();
        const endGenerateTimer = (0, commons_2.logTimespan)("Generate TS");
        await Promise.all(targets.map((target) => this.generateTypescript(target, schemas)));
        endGenerateTimer();
        this.updateVersionsFile(allConstraints);
        this.emitConstraintsFile(allConstraints);
        if (this.isJavascriptTarget) {
            await this.save();
        }
        if (!this.isJavascriptTarget || this.options.outputJsii) {
            const numberOfWorkers = Math.max(1, this.options.jsiiParallelism === -1
                ? targets.length
                : this.options.jsiiParallelism || 1);
            const work = [...targets];
            const workers = new Array(numberOfWorkers).fill(async () => {
                let target;
                while ((target = work.pop())) {
                    const endJsiiTarget = (0, commons_2.logTimespan)(`Generating JSII bindings for ${target.name}`);
                    await this.generateJsiiLanguage(target);
                    endJsiiTarget();
                }
            });
            await Promise.all(workers.map((fn) => fn()));
        }
        for (const target of targets) {
            await this.reportTelemetry({
                trackingPayload: target.trackingPayload,
                targetLanguage: target.targetLanguage,
            });
        }
        if (this.isPythonTarget) {
            const endPythonTimer = (0, commons_2.logTimespan)("Python post-processing");
            // Remove from . import ... statements from root level __init__.py
            // This removes root-level imports of namespaces, but saves 25s synth time for the aws provider alone
            const allInitPyPaths = glob_1.glob
                .sync("**/__init__.py", {
                cwd: this.codeMakerOutdir,
            })
                // sort by depth, so we start with the shallowest files
                .sort((a, b) => a.split("/").length - b.split("/").length);
            const visitedDirectories = [];
            for (const initPyPath of allInitPyPaths) {
                const directoryPath = path.dirname(initPyPath);
                if (visitedDirectories.some((dir) => directoryPath.startsWith(dir))) {
                    // we already processed this directory
                    continue;
                }
                visitedDirectories.push(directoryPath);
                const absoluteInitPyPath = path.join(this.codeMakerOutdir, initPyPath);
                const initPy = await fs.readFile(absoluteInitPyPath, "utf8");
                const initPyWithoutImports = initPy.replace(/from \. import .*\n/g, "");
                await fs.writeFile(absoluteInitPyPath, initPyWithoutImports);
            }
            endPythonTimer();
        }
    }
    async save(outdir = this.codeMakerOutdir) {
        await this.code.save(outdir);
    }
    get isJavascriptTarget() {
        return this.options.targetLanguage === commons_3.Language.TYPESCRIPT;
    }
    get isPythonTarget() {
        return this.options.targetLanguage === commons_3.Language.PYTHON;
    }
    get isJavaTarget() {
        return this.options.targetLanguage === commons_3.Language.JAVA;
    }
    get isCsharpTarget() {
        return this.options.targetLanguage === commons_3.Language.CSHARP;
    }
    get isGoTarget() {
        return this.options.targetLanguage === commons_3.Language.GO;
    }
}
exports.ConstructsMaker = ConstructsMaker;
/**
 * searches for the closest `go.mod` file and returns the nested go module name for `dir`
 * e.g. (/dir/.gen/) => cdk.tf/stack/.gen if the parent dir of .gen has a go.mod for "module cdk.tf/stack"
 *
 * @param dir the directory to start the search from (searches upwards)
 * @returns the package name for `dir`
 * @throws an Error if no go.mod was found
 */
const determineGoModuleName = async (dir) => {
    let previousDir;
    let currentDir = path.resolve(dir);
    do {
        let files = [];
        try {
            files = await fs.readdir(currentDir);
        }
        catch (e) {
            // directory might not exist yet, but we still walk upwards from there, so ignore 'ENOENT'
            if (e.code !== "ENOENT") {
                throw e;
            }
        }
        if (files.includes("go.mod")) {
            const file = path.resolve(currentDir, "go.mod");
            const gomod = await fs.readFile(file);
            const match = /^module\s*(\S*)\s*$/m.exec(gomod.toString());
            if (match && match[1]) {
                const childdir = path.relative(currentDir, dir).replace(/\\/g, "/"); // replace '\' with '/' for windows paths
                return childdir.length > 0 ? `${match[1]}/${childdir}` : match[1];
            }
            throw new Error(`Could not determine the root Go module name. Found ${file} but failed to regex match the module name directive`);
        }
        // go up one directory. As dirname('/') will return '/' we cancel the loop
        // as soon as the dir does not change anymore.
        previousDir = currentDir;
        currentDir = path.dirname(currentDir);
    } while (currentDir !== previousDir);
    throw new Error(`Could not determine the root Go module name. No go.mod found in ${dir} and any parent directories`);
};
exports.determineGoModuleName = determineGoModuleName;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RydWN0cy1tYWtlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbnN0cnVjdHMtbWFrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DLDZDQUErQjtBQUMvQiwyQ0FBNkI7QUFDN0IseUNBQXNDO0FBQ3RDLDRDQUErQztBQUMvQyw0Q0FVd0I7QUFDeEIsNENBQTJEO0FBQzNELHVFQUE0RTtBQUM1RSxtRUFBK0Q7QUFDL0QsK0JBQTRCO0FBQzVCLDREQUFvRDtBQUVwRCxNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLDZCQUE2QixDQUFDLENBQUM7QUFDcEUsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztBQWlEN0MsS0FBSyxVQUFVLG9CQUFvQixDQUN4QyxJQUFlLEVBQ2YsSUFBeUIsRUFDekIsVUFBa0IsRUFDbEIsc0JBQWdDLEVBQUU7SUFFbEMsTUFBTSxJQUFBLGlCQUFPLEVBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxFQUFFO1FBQzlCLG9FQUFvRTtRQUNwRSxzRUFBc0U7UUFDdEUsb0JBQW9CO1FBQ3BCLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV6Qiw0RUFBNEU7UUFDNUUsNEdBQTRHO1FBQzVHLE1BQU0sYUFBYSxHQUFHLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQzVELFdBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQ3JDLENBQUM7UUFDRixNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQ2YsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQ2pFLENBQUM7UUFFRixvQkFBb0I7UUFDcEIsTUFBTSxRQUFRLEdBQUcsQ0FBQyxvQkFBb0IsRUFBRSxlQUFlLENBQUMsQ0FBQztRQUN6RCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBQ3ZDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQ3hCLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLEVBQzVCLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxFQUFFLEtBQUssQ0FBQyxDQUNyQyxDQUFDO1FBRUYsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDdkUsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUM3QixNQUFNLE9BQU8sR0FBd0IsRUFBRSxDQUFDO1FBQ3hDLE1BQU0sSUFBSSxHQUEyQixFQUFFLENBQUM7UUFDeEMsS0FBSyxNQUFNLEdBQUcsSUFBSSxVQUFVLEVBQUU7WUFDNUIsdUJBQXVCO1lBQ3ZCLE1BQU0sUUFBUSxHQUFHLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ25FLE1BQU0sVUFBVSxHQUFXLFFBQVEsQ0FBQyxJQUFJLENBQUM7WUFDekMsTUFBTSxhQUFhLEdBQVcsUUFBUSxDQUFDLE9BQU8sQ0FBQztZQUUvQyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUMsRUFDbEMsVUFBVSxDQUNYLENBQUM7WUFDRixNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFFOUIsZ0NBQWdDO1lBQ2hDLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUNyQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsYUFBYSxDQUFDO2FBQ2xDO1NBQ0Y7UUFDRCxNQUFNLEdBQUcsR0FBRztZQUNWLElBQUksRUFBRSxTQUFTO1lBQ2YsT0FBTyxFQUFFLE9BQU87WUFDaEIsTUFBTSxFQUFFLHlCQUF5QjtZQUNqQyxJQUFJLEVBQUUsR0FBRyxRQUFRLEtBQUs7WUFDdEIsS0FBSyxFQUFFLEdBQUcsUUFBUSxPQUFPO1lBQ3pCLE9BQU8sRUFBRSxZQUFZO1lBQ3JCLFVBQVUsRUFBRSxFQUFFLEdBQUcsRUFBRSxrQkFBa0IsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFO1lBQ3BELElBQUksRUFBRTtnQkFDSixNQUFNLEVBQUUsTUFBTTtnQkFDZCxPQUFPLEVBQUUsT0FBTzthQUNqQjtZQUNELFlBQVksRUFBRSxJQUFJO1lBQ2xCLGdCQUFnQixFQUFFLElBQUk7U0FDdkIsQ0FBQztRQUVGLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNmLEdBQTJCLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7U0FDckQ7UUFDRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixPQUFPLENBQUMsTUFBTSxHQUFHO2dCQUNmLFFBQVEsRUFBRSxXQUFXO2dCQUNyQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVO2FBQy9CLENBQUM7U0FDSDtRQUVELElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUNiLE9BQU8sQ0FBQyxJQUFJLEdBQUc7Z0JBQ2IsT0FBTyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTztnQkFDMUIsS0FBSyxFQUFFO29CQUNMLE9BQU8sRUFBRSxXQUFXO29CQUNwQixVQUFVLEVBQUUsV0FBVztpQkFDeEI7YUFDRixDQUFDO1NBQ0g7UUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixPQUFPLENBQUMsTUFBTSxHQUFHO2dCQUNmLFNBQVMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVM7Z0JBQ2hDLFNBQVMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVM7YUFDakMsQ0FBQztTQUNIO1FBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2YsT0FBTyxDQUFDLEVBQUUsR0FBRztnQkFDWCxVQUFVLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVO2dCQUNsQyxXQUFXLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXO2FBQ3JDLENBQUM7U0FDSDtRQUVELE1BQU0sRUFBRSxDQUFDLFNBQVMsQ0FDaEIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsY0FBYyxDQUFDLEVBQ2xDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FDbEMsQ0FBQztRQUVGLE1BQU0sWUFBWSxHQUFHLElBQUEscUJBQVcsRUFBQyxNQUFNLENBQUMsQ0FBQztRQUN6QyxNQUFNLElBQUEsY0FBSSxFQUFDLFVBQVUsRUFBRSxRQUFRLEVBQUU7WUFDL0IsR0FBRyxFQUFFLE9BQU87U0FDYixDQUFDLENBQUM7UUFDSCxZQUFZLEVBQUUsQ0FBQztRQUVmLDZCQUE2QjtRQUM3QixJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDYixNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM1RDtRQUVELDhCQUE4QjtRQUM5QixNQUFNLGtCQUFrQixHQUFHLElBQUEscUJBQVcsRUFBQyxhQUFhLENBQUMsQ0FBQztRQUN0RCxNQUFNLElBQUEsY0FBSSxFQUFDLFlBQVksRUFBRSxDQUFDLGFBQWEsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDNUQsa0JBQWtCLEVBQUUsQ0FBQztRQUVyQixJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsNkJBQTZCO1lBQ3hGLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sQ0FBQyxDQUM5QyxDQUFDO1lBQ0YsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztZQUNyRCxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1NBQ3BEO1FBRUQsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7WUFDbEUsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztZQUNuRCxNQUFNLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxvQ0FBb0M7WUFDN0QsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ3RFO1FBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2YsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUM7WUFDckMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUN4RSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ3JELE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7U0FDcEQ7UUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQztZQUN2QyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ3BFLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDckQsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUNuRCxrREFBa0Q7WUFDbEQsTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7U0FDOUM7UUFFRCxDQUFDLGVBQWUsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ3JELElBQUk7Z0JBQ0YsRUFBRSxDQUFDLFFBQVEsQ0FDVCxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsRUFDM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQy9CLENBQUM7YUFDSDtZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLGdCQUFNLENBQUMsS0FBSyxDQUFDLGtCQUFrQixJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUM5QztRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBcktELG9EQXFLQztBQWVELE1BQWEsZUFBZTtJQUsxQixZQUNtQixPQUFtQixFQUNuQixlQUF3QixFQUN4QixrQkFHSyxLQUFLLElBQUksRUFBRSxHQUFFLENBQUM7UUFMbkIsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUNuQixvQkFBZSxHQUFmLGVBQWUsQ0FBUztRQUN4QixvQkFBZSxHQUFmLGVBQWUsQ0FHSTtRQUVwQyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNsRSxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNwQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUkscUJBQVMsRUFBRSxDQUFDO1FBQzVCLElBQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFDTyxLQUFLLENBQUMsMEJBQTBCLENBQ3RDLE1BQXFDLEVBQ3JDLE1BQXNCO1FBRXRCLE1BQU0sVUFBVSxHQUFHLElBQUEscUJBQVcsRUFBQywyQkFBMkIsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7UUFDekUsTUFBTSxTQUFTLEdBQUcsSUFBSSwrQ0FBMEIsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3BFLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFM0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUM1RCxVQUFVLEVBQUUsQ0FBQztJQUNmLENBQUM7SUFFTSxLQUFLLENBQUMsc0JBQXNCLENBQ2pDLFdBQTRDO1FBRTVDLElBQUksZUFBZSxHQUFHLElBQUksQ0FBQztRQUMzQixJQUFJO1lBQ0YsZUFBZSxHQUFHLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLGtCQUFrQixDQUFDLEVBQ25ELE1BQU0sQ0FDUCxDQUFDO1NBQ0g7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLGdCQUFNLENBQUMsS0FBSyxDQUNWLHlEQUF5RCxDQUFDLG9GQUFvRixDQUMvSSxDQUFDO1lBQ0YsT0FBTyxXQUFXLENBQUM7U0FDcEI7UUFDRCxnQkFBTSxDQUFDLEtBQUssQ0FBQyxnQ0FBZ0MsZUFBZSxFQUFFLENBQUMsQ0FBQztRQUVoRSxJQUFJLG1CQUFtQixHQUE0QixFQUFFLENBQUM7UUFDdEQsSUFBSTtZQUNGLG1CQUFtQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUM7U0FDbkQ7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLGdCQUFNLENBQUMsSUFBSSxDQUNULDBEQUEwRCxDQUFDLCtCQUErQixDQUMzRixDQUFDO1lBQ0YsT0FBTyxXQUFXLENBQUM7U0FDcEI7UUFFRCxnQkFBTSxDQUFDLEtBQUssQ0FDViwrQkFBK0IsSUFBSSxDQUFDLFNBQVMsQ0FDM0MsbUJBQW1CLEVBQ25CLElBQUksRUFDSixDQUFDLENBQ0YsRUFBRSxDQUNKLENBQUM7UUFFRixJQUNFLENBQUMsbUJBQW1CLENBQUMsU0FBUztZQUM5QixPQUFPLG1CQUFtQixDQUFDLFNBQVMsS0FBSyxRQUFRLEVBQ2pEO1lBQ0EsZ0JBQU0sQ0FBQyxJQUFJLENBQ1QsMkdBQTJHLElBQUksQ0FBQyxTQUFTLENBQ3ZILG1CQUFtQixFQUNuQixJQUFJLEVBQ0osQ0FBQyxDQUNGLEVBQUUsQ0FDSixDQUFDO1lBQ0YsT0FBTyxXQUFXLENBQUM7U0FDcEI7UUFFRCxJQUFJLG1CQUFtQixDQUFDLEtBQUssS0FBSyx5QkFBZSxFQUFFO1lBQ2pELGdCQUFNLENBQUMsSUFBSSxDQUNULHVGQUF1RixtQkFBbUIsQ0FBQyxLQUFLLDRCQUE0Qix5QkFBZSxFQUFFLENBQzlKLENBQUM7WUFDRixPQUFPLFdBQVcsQ0FBQztTQUNwQjtRQUVELE1BQU0scUJBQXFCLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQzlELE1BQU0saUJBQWlCLEdBQ3JCLG1CQUFtQixDQUFDLFNBQVUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEtBQUssVUFBVSxDQUFDLE9BQU8sQ0FBQztZQUN4RSxJQUFJLG9CQUFvQixHQUFHLEtBQUssQ0FBQztZQUVqQyxRQUFRLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFO2dCQUNuQyxLQUFLLGtCQUFRLENBQUMsVUFBVTtvQkFDdEIsb0JBQW9CLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQzlELENBQUM7b0JBQ0YsTUFBTTtnQkFDUixLQUFLLGtCQUFRLENBQUMsTUFBTSxDQUFDO2dCQUNyQixLQUFLLGtCQUFRLENBQUMsSUFBSSxDQUFDO2dCQUNuQixLQUFLLGtCQUFRLENBQUMsTUFBTTtvQkFDbEIsb0JBQW9CLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FDakQsQ0FBQztvQkFDRixNQUFNO2dCQUNSLEtBQUssa0JBQVEsQ0FBQyxFQUFFO29CQUNkLG9CQUFvQixHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQ2xDLElBQUksQ0FBQyxJQUFJLENBQ1AsSUFBSSxDQUFDLGVBQWUsRUFDcEIsVUFBVSxDQUFDLFNBQVMsSUFBSSxXQUFXLEVBQ25DLFVBQVUsQ0FBQyxJQUFJLENBQ2hCLENBQ0YsQ0FBQztvQkFDRixNQUFNO2FBQ1Q7WUFFRCxNQUFNLGNBQWMsR0FBRyxpQkFBaUIsSUFBSSxvQkFBb0IsQ0FBQztZQUNqRSxPQUFPLENBQUMsY0FBYyxDQUFDO1FBQ3pCLENBQUMsQ0FBQyxDQUFDO1FBRUgsZ0JBQU0sQ0FBQyxLQUFLLENBQ1YsNEJBQTRCLElBQUksQ0FBQyxTQUFTLENBQ3hDLHFCQUFxQixFQUNyQixJQUFJLEVBQ0osQ0FBQyxDQUNGLEVBQUUsQ0FDSixDQUFDO1FBRUYsT0FBTyxxQkFBcUIsQ0FBQztJQUMvQixDQUFDO0lBRU8sS0FBSyxDQUFDLHdCQUF3QixDQUNwQyxNQUFtQyxFQUNuQyxNQUFvQjtRQUVwQixNQUFNLFVBQVUsR0FBRyxJQUFBLHFCQUFXLEVBQUMsMkJBQTJCLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ3pFLE1BQU0sQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksa0NBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN6QyxVQUFVLEVBQUUsQ0FBQztJQUNmLENBQUM7SUFFTyxLQUFLLENBQUMsa0JBQWtCLENBQzlCLE1BQTZCLEVBQzdCLE9BQStDOztRQUUvQyxJQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUU7WUFDbkIsTUFBTSxNQUFNLEdBQUcsTUFBQSxPQUFPLENBQUMsWUFBWSwwQ0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDeEQsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDWCxNQUFNLGdCQUFNLENBQUMsUUFBUSxDQUNuQix3Q0FBd0MsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUMzRCxDQUFDO2FBQ0g7WUFFRCxNQUFNLElBQUksQ0FBQyx3QkFBd0IsQ0FDakMsTUFBcUMsRUFDckMsTUFBTSxDQUNQLENBQUM7U0FDSDthQUFNLElBQUksTUFBTSxDQUFDLFVBQVUsRUFBRTtZQUM1QixJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRTtnQkFDM0IsTUFBTSxnQkFBTSxDQUFDLFFBQVEsQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO2FBQ2xFO1lBRUQsTUFBTSxJQUFJLENBQUMsMEJBQTBCLENBQ25DLE1BQXVDLEVBQ3ZDLE9BQU8sQ0FBQyxjQUFjLENBQ3ZCLENBQUM7U0FDSDthQUFNO1lBQ0wsTUFBTSxJQUFJLEtBQUssQ0FDYixrREFBa0QsTUFBTSxDQUFDLElBQUksRUFBRSxDQUNoRSxDQUFDO1NBQ0g7SUFDSCxDQUFDO0lBRUQsbUZBQW1GO0lBQzNFLGtCQUFrQixDQUN4QixrQkFBbUQ7UUFFbkQsZ0JBQU0sQ0FBQyxLQUFLLENBQ1Ysa0RBQWtELElBQUksQ0FBQyxTQUFTLENBQzlELElBQUksQ0FBQyxRQUFRLEVBQ2IsSUFBSSxFQUNKLENBQUMsQ0FDRiw2QkFBNkIsSUFBSSxDQUFDLFNBQVMsQ0FDMUMsa0JBQWtCLEVBQ2xCLElBQUksRUFDSixDQUFDLENBQ0YsRUFBRSxDQUNKLENBQUM7UUFDRixNQUFNLFFBQVEsR0FBRyxlQUFlLENBQUM7UUFDakMsSUFBSSxnQkFBZ0IsR0FBMkIsRUFBRSxDQUFDO1FBQ2xELElBQUk7WUFDRixnQkFBZ0IsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUMzQixFQUFFLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxRQUFRLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FDdEUsQ0FBQztZQUVGLGdCQUFNLENBQUMsS0FBSyxDQUNWLGdDQUFnQyxJQUFJLENBQUMsU0FBUyxDQUM1QyxnQkFBZ0IsRUFDaEIsSUFBSSxFQUNKLENBQUMsQ0FDRixFQUFFLENBQ0osQ0FBQztTQUNIO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixTQUFTO1lBQ1QsZ0JBQU0sQ0FBQyxLQUFLLENBQ1YsZ0dBQWdHLENBQUMsRUFBRSxDQUNwRyxDQUFDO1NBQ0g7UUFFRCxNQUFNLFFBQVEsR0FBRyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsVUFBVSxFQUFFLEVBQUU7WUFDN0QsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNoRSwyREFBMkQ7WUFDM0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQzlCLENBQUM7WUFFRixJQUFJLFFBQVEsRUFBRTtnQkFDWixNQUFNLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxHQUFHLFFBQVEsQ0FBQztnQkFDakMsT0FBTyxFQUFFLEdBQUcsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUM7YUFDcEM7WUFFRCxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVQLGdCQUFNLENBQUMsS0FBSyxDQUNWLDBCQUEwQixRQUFRLE1BQU0sSUFBSSxDQUFDLFNBQVMsQ0FDcEQsUUFBUSxFQUNSLElBQUksRUFDSixDQUFDLENBQ0YsRUFBRSxDQUNKLENBQUM7UUFFRixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsR0FBRyxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0UsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDOUIsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztJQUVNLEtBQUssQ0FBQywrQkFBK0IsQ0FDMUMsMEJBQTJEO1FBRTNELGdCQUFNLENBQUMsS0FBSyxDQUNWLGlDQUFpQyxJQUFJLENBQUMsU0FBUyxDQUM3QywwQkFBMEIsRUFDMUIsSUFBSSxFQUNKLENBQUMsQ0FDRixFQUFFLENBQ0osQ0FBQztRQUVGLCtFQUErRTtRQUMvRSwrRUFBK0U7UUFDL0UsZ0RBQWdEO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDNUIsT0FBTztTQUNSO1FBRUQsSUFBSSxnQkFBZ0IsR0FBYSxFQUFFLENBQUM7UUFDcEMsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ3hFLElBQUk7WUFDRixnQkFBZ0IsR0FBRyxNQUFNLEVBQUUsQ0FBQyxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7U0FDdEQ7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLGdCQUFNLENBQUMsS0FBSyxDQUNWLDRDQUE0QyxlQUFlLE1BQU0sQ0FBQyxFQUFFLENBQ3JFLENBQUM7U0FDSDtRQUVELE1BQU0sT0FBTyxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQy9DLEVBQUU7YUFDQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUMvRCxXQUFXLEVBQUUsQ0FDakIsQ0FBQztRQUVGLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ2hDLE1BQU0sV0FBVyxHQUFHLDBCQUEwQixDQUFDLElBQUksQ0FDakQsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUMzQyxDQUFDO1lBRUYsSUFBSSxDQUFDLFdBQVcsRUFBRTtnQkFDaEIsZ0JBQU0sQ0FBQyxLQUFLLENBQUMsbUJBQW1CLE1BQU0saUJBQWlCLENBQUMsQ0FBQztnQkFDekQsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7YUFDeEU7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCw4RkFBOEY7SUFDOUYsb0NBQW9DO0lBQzVCLG1CQUFtQixDQUN6QixrQkFBbUQ7UUFFbkQsTUFBTSxRQUFRLEdBQUcsa0JBQWtCLENBQUM7UUFFcEMsTUFBTSxPQUFPLEdBQW1CO1lBQzlCLEtBQUssRUFBRSx5QkFBZTtZQUN0QixTQUFTLEVBQUUsa0JBQWtCO2lCQUMxQixJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQzFDLE1BQU0sQ0FDTCxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ2hCLEdBQUcsS0FBSztnQkFDUixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsT0FBTzthQUN6QixDQUFDLEVBQ0YsRUFBRSxDQUNIO1NBQ0osQ0FBQztRQUVGLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzdCLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzlCLE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFTyxLQUFLLENBQUMsb0JBQW9CLENBQUMsTUFBNkI7O1FBQzlELHVEQUF1RDtRQUN2RCxNQUFNLElBQUksR0FBRyxDQUFDLGFBQWEsRUFBRSxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDcEQsTUFBTSxJQUFJLEdBQXdCO1lBQ2hDLFVBQVUsRUFBRSxNQUFNLENBQUMsUUFBUTtZQUMzQixJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FDckQ7WUFDRCxTQUFTLEVBQUUsTUFBTSxDQUFDLFNBQVM7WUFDM0IsT0FBTyxFQUFFLE1BQU0sQ0FBQyxVQUFVLENBQUMsZ0VBQWdFO2dCQUN6RixDQUFDLENBQUM7b0JBQ0UsR0FBRyxFQUFFO3dCQUNILE1BQU0sRUFBRSxlQUFlLE1BQU0sQ0FBQyxJQUFJLFdBQVc7d0JBQzdDLE9BQU8sRUFBRSxlQUFlLE1BQU0sQ0FBQyxJQUFJLGdCQUFnQjtxQkFDcEQ7aUJBQ0Y7Z0JBQ0gsQ0FBQyxDQUFDLFNBQVM7U0FDZCxDQUFDO1FBRUYsb0JBQW9CO1FBQ3BCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUU7WUFDM0IsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxDQUFDO1NBQy9DO1FBRUQsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxNQUFNLEdBQUc7Z0JBQ1osTUFBTSxFQUFFLElBQUksQ0FBQyxlQUFlO2dCQUM1QixVQUFVLEVBQUUsTUFBTSxDQUFDLFVBQVU7YUFDOUIsQ0FBQztTQUNIO1FBRUQsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ3JCLElBQ0UsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQztnQkFDMUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUMzQztnQkFDQSxNQUFNLGdCQUFNLENBQUMsS0FBSyxDQUNoQixrVkFBa1YsQ0FDblYsQ0FBQzthQUNIO1lBRUQsSUFBSSxDQUFDLElBQUksR0FBRztnQkFDVixNQUFNLEVBQUUsR0FBRztnQkFDWCxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsSUFBSSxNQUFNLENBQUMsVUFBVSxFQUFFO2FBQ2hFLENBQUM7U0FDSDtRQUVELElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUN2QixJQUFJLENBQUMsTUFBTSxHQUFHO2dCQUNaLE1BQU0sRUFBRSxJQUFJLENBQUMsZUFBZTtnQkFDNUIsU0FBUyxFQUFFLE1BQU0sQ0FBQyxVQUFVO2FBQzdCLENBQUM7U0FDSDtRQUVELElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNuQiw0Q0FBNEM7WUFDNUMsZ0VBQWdFO1lBRWhFLDhFQUE4RTtZQUM5RSxnREFBZ0Q7WUFDaEQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLE1BQUEsTUFBTSxDQUFDLFNBQVMsbUNBQUksRUFBRSxDQUFDLENBQUM7WUFFdkUsSUFBSSxDQUFDLE1BQU0sR0FBRztnQkFDWixNQUFNO2dCQUNOLFVBQVUsRUFBRSxNQUFNLElBQUEsNkJBQXFCLEVBQUMsTUFBTSxDQUFDO2dCQUMvQyxXQUFXLEVBQUUsTUFBTSxDQUFDLFVBQVUsRUFBRSx5REFBeUQ7YUFDMUYsQ0FBQztTQUNIO1FBRUQsSUFDRSxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVk7WUFDeEIsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsc0JBQXNCLENBQUMsRUFDMUQ7WUFDQSxnQkFBTSxDQUFDLElBQUksQ0FBQzs7O3NIQUdvRyxDQUFDLENBQUM7U0FDbkg7YUFBTTtZQUNMLG1GQUFtRjtZQUNuRiwwR0FBMEc7WUFDMUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLEdBQUcsNEJBQTRCLENBQUM7U0FDekQ7UUFFRCxNQUFNLFNBQVMsR0FBRyxJQUFBLHFCQUFXLEVBQUMsTUFBTSxDQUFDLENBQUM7UUFDdEMsTUFBTSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ2hFLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsWUFBWTtTQUNoRCxDQUFDLENBQUM7UUFDSCxTQUFTLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFFTSxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQXdDO1FBQzlELE9BQU8sTUFBTSxJQUFBLDRCQUFVLEVBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRU0sS0FBSyxDQUFDLFFBQVEsQ0FDbkIsY0FBK0MsRUFDL0MscUJBQXFCLEdBQUcsY0FBYztRQUV0QyxNQUFNLE9BQU8sR0FBRyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUN2RCwrQkFBcUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQ3BFLENBQUM7UUFFRixNQUFNLGNBQWMsR0FBRyxJQUFBLHFCQUFXLEVBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUN2RCxNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMscUJBQXFCLENBQUMsQ0FBQztRQUM3RCxjQUFjLEVBQUUsQ0FBQztRQUVqQixNQUFNLGdCQUFnQixHQUFHLElBQUEscUJBQVcsRUFBQyxhQUFhLENBQUMsQ0FBQztRQUNwRCxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQ2YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUNsRSxDQUFDO1FBQ0YsZ0JBQWdCLEVBQUUsQ0FBQztRQUVuQixJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDeEMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXpDLElBQUksSUFBSSxDQUFDLGtCQUFrQixFQUFFO1lBQzNCLE1BQU0sSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ25CO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRTtZQUN2RCxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUM5QixDQUFDLEVBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEtBQUssQ0FBQyxDQUFDO2dCQUNqQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU07Z0JBQ2hCLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsSUFBSSxDQUFDLENBQ3RDLENBQUM7WUFFRixNQUFNLElBQUksR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUM7WUFDMUIsTUFBTSxPQUFPLEdBQUcsSUFBSSxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxFQUFFO2dCQUN6RCxJQUFJLE1BQXlDLENBQUM7Z0JBQzlDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUU7b0JBQzVCLE1BQU0sYUFBYSxHQUFHLElBQUEscUJBQVcsRUFDL0IsZ0NBQWdDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FDOUMsQ0FBQztvQkFDRixNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDeEMsYUFBYSxFQUFFLENBQUM7aUJBQ2pCO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFFSCxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQzlDO1FBRUQsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUU7WUFDNUIsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDO2dCQUN6QixlQUFlLEVBQUUsTUFBTSxDQUFDLGVBQWU7Z0JBQ3ZDLGNBQWMsRUFBRSxNQUFNLENBQUMsY0FBYzthQUN0QyxDQUFDLENBQUM7U0FDSjtRQUVELElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUN2QixNQUFNLGNBQWMsR0FBRyxJQUFBLHFCQUFXLEVBQUMsd0JBQXdCLENBQUMsQ0FBQztZQUM3RCxrRUFBa0U7WUFDbEUscUdBQXFHO1lBQ3JHLE1BQU0sY0FBYyxHQUFHLFdBQUk7aUJBQ3hCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDdEIsR0FBRyxFQUFFLElBQUksQ0FBQyxlQUFlO2FBQzFCLENBQUM7Z0JBQ0YsdURBQXVEO2lCQUN0RCxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTdELE1BQU0sa0JBQWtCLEdBQWEsRUFBRSxDQUFDO1lBQ3hDLEtBQUssTUFBTSxVQUFVLElBQUksY0FBYyxFQUFFO2dCQUN2QyxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUMvQyxJQUFJLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO29CQUNuRSxzQ0FBc0M7b0JBQ3RDLFNBQVM7aUJBQ1Y7Z0JBQ0Qsa0JBQWtCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2dCQUV2QyxNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDdkUsTUFBTSxNQUFNLEdBQUcsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLGtCQUFrQixFQUFFLE1BQU0sQ0FBQyxDQUFDO2dCQUM3RCxNQUFNLG9CQUFvQixHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsc0JBQXNCLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ3hFLE1BQU0sRUFBRSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO2FBQzlEO1lBRUQsY0FBYyxFQUFFLENBQUM7U0FDbEI7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWU7UUFDOUMsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQsSUFBWSxrQkFBa0I7UUFDNUIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsS0FBSyxrQkFBUSxDQUFDLFVBQVUsQ0FBQztJQUM3RCxDQUFDO0lBRUQsSUFBWSxjQUFjO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEtBQUssa0JBQVEsQ0FBQyxNQUFNLENBQUM7SUFDekQsQ0FBQztJQUVELElBQVksWUFBWTtRQUN0QixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxLQUFLLGtCQUFRLENBQUMsSUFBSSxDQUFDO0lBQ3ZELENBQUM7SUFFRCxJQUFZLGNBQWM7UUFDeEIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsS0FBSyxrQkFBUSxDQUFDLE1BQU0sQ0FBQztJQUN6RCxDQUFDO0lBRUQsSUFBWSxVQUFVO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEtBQUssa0JBQVEsQ0FBQyxFQUFFLENBQUM7SUFDckQsQ0FBQztDQUNGO0FBOWZELDBDQThmQztBQUVEOzs7Ozs7O0dBT0c7QUFDSSxNQUFNLHFCQUFxQixHQUFHLEtBQUssRUFBRSxHQUFXLEVBQW1CLEVBQUU7SUFDMUUsSUFBSSxXQUFXLENBQUM7SUFDaEIsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUVuQyxHQUFHO1FBQ0QsSUFBSSxLQUFLLEdBQWEsRUFBRSxDQUFDO1FBQ3pCLElBQUk7WUFDRixLQUFLLEdBQUcsTUFBTSxFQUFFLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3RDO1FBQUMsT0FBTyxDQUFNLEVBQUU7WUFDZiwwRkFBMEY7WUFDMUYsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtnQkFDdkIsTUFBTSxDQUFDLENBQUM7YUFDVDtTQUNGO1FBQ0QsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzVCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ2hELE1BQU0sS0FBSyxHQUFHLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN0QyxNQUFNLEtBQUssR0FBRyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDNUQsSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNyQixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMseUNBQXlDO2dCQUM5RyxPQUFPLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ25FO1lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FDYixzREFBc0QsSUFBSSxzREFBc0QsQ0FDakgsQ0FBQztTQUNIO1FBQ0QsMEVBQTBFO1FBQzFFLDhDQUE4QztRQUM5QyxXQUFXLEdBQUcsVUFBVSxDQUFDO1FBQ3pCLFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQ3ZDLFFBQVEsVUFBVSxLQUFLLFdBQVcsRUFBRTtJQUVyQyxNQUFNLElBQUksS0FBSyxDQUNiLG1FQUFtRSxHQUFHLDZCQUE2QixDQUNwRyxDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBbkNXLFFBQUEscUJBQXFCLHlCQW1DaEMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzLWV4dHJhXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyBDb2RlTWFrZXIgfSBmcm9tIFwiY29kZW1ha2VyXCI7XG5pbXBvcnQgeyBleGVjLCBta2R0ZW1wIH0gZnJvbSBcIkBjZGt0Zi9jb21tb25zXCI7XG5pbXBvcnQge1xuICBUZXJyYWZvcm1EZXBlbmRlbmN5Q29uc3RyYWludCxcbiAgbG9nZ2VyLFxuICBsb2dUaW1lc3BhbixcbiAgQ29uc3RydWN0c01ha2VyUHJvdmlkZXJUYXJnZXQsXG4gIENvbnN0cnVjdHNNYWtlck1vZHVsZVRhcmdldCxcbiAgQ29uc3RydWN0c01ha2VyVGFyZ2V0LFxuICBQcm92aWRlclNjaGVtYSxcbiAgTW9kdWxlU2NoZW1hLFxuICBFcnJvcnMsXG59IGZyb20gXCJAY2RrdGYvY29tbW9uc1wiO1xuaW1wb3J0IHsgRElTUExBWV9WRVJTSU9OLCBMYW5ndWFnZSB9IGZyb20gXCJAY2RrdGYvY29tbW9uc1wiO1xuaW1wb3J0IHsgVGVycmFmb3JtUHJvdmlkZXJHZW5lcmF0b3IgfSBmcm9tIFwiLi9nZW5lcmF0b3IvcHJvdmlkZXItZ2VuZXJhdG9yXCI7XG5pbXBvcnQgeyBNb2R1bGVHZW5lcmF0b3IgfSBmcm9tIFwiLi9nZW5lcmF0b3IvbW9kdWxlLWdlbmVyYXRvclwiO1xuaW1wb3J0IHsgZ2xvYiB9IGZyb20gXCJnbG9iXCI7XG5pbXBvcnQgeyByZWFkU2NoZW1hIH0gZnJvbSBcIkBjZGt0Zi9wcm92aWRlci1zY2hlbWFcIjtcblxuY29uc3QgcGFjbWFrTW9kdWxlID0gcmVxdWlyZS5yZXNvbHZlKFwianNpaS1wYWNtYWsvYmluL2pzaWktcGFjbWFrXCIpO1xuY29uc3QganNpaU1vZHVsZSA9IHJlcXVpcmUucmVzb2x2ZShcImpzaWkvYmluL2pzaWlcIik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJhdGVKU0lJT3B0aW9ucyB7XG4gIGVudHJ5cG9pbnQ6IHN0cmluZztcbiAgZGVwczogc3RyaW5nW107XG4gIG1vZHVsZUtleTogc3RyaW5nO1xuICBleHBvcnRzPzogUmVjb3JkPHN0cmluZywgRXhwb3J0RGVmaW5pdGlvbiB8IHN0cmluZz47XG4gIGpzaWk/OiBKc2lpT3V0cHV0T3B0aW9ucztcbiAgcHl0aG9uPzogUHl0aG9uT3V0cHV0T3B0aW9ucztcbiAgamF2YT86IEphdmFPdXRwdXRPcHRpb25zO1xuICBjc2hhcnA/OiBDU2hhcnBPdXRwdXRPcHRpb25zO1xuICBnb2xhbmc/OiBHb0xhbmdPdXRwdXRPcHRpb25zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEpzaWlPdXRwdXRPcHRpb25zIHtcbiAgcGF0aDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFB5dGhvbk91dHB1dE9wdGlvbnMge1xuICBvdXRkaXI6IHN0cmluZztcbiAgbW9kdWxlTmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEphdmFPdXRwdXRPcHRpb25zIHtcbiAgb3V0ZGlyOiBzdHJpbmc7XG4gIHBhY2thZ2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDU2hhcnBPdXRwdXRPcHRpb25zIHtcbiAgb3V0ZGlyOiBzdHJpbmc7XG4gIG5hbWVzcGFjZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdvTGFuZ091dHB1dE9wdGlvbnMge1xuICBvdXRkaXI6IHN0cmluZztcbiAgbW9kdWxlTmFtZTogc3RyaW5nO1xuICBwYWNrYWdlTmFtZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3BhY2thZ2VzLmh0bWwjY29uZGl0aW9uYWwtZXhwb3J0cyBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4cG9ydERlZmluaXRpb24ge1xuICBub2RlPzogc3RyaW5nO1xuICBpbXBvcnQ/OiBzdHJpbmc7XG4gIHJlcXVpcmU/OiBzdHJpbmc7XG4gIGRlZmF1bHQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUpzaWlMYW5ndWFnZShcbiAgY29kZTogQ29kZU1ha2VyLFxuICBvcHRzOiBHZW5lcmF0ZUpTSUlPcHRpb25zLFxuICBvdXRwdXRQYXRoOiBzdHJpbmcsXG4gIGRpc2FsbG93ZWRGaWxlR2xvYnM6IHN0cmluZ1tdID0gW11cbikge1xuICBhd2FpdCBta2R0ZW1wKGFzeW5jIChzdGFnaW5nKSA9PiB7XG4gICAgLy8gdGhpcyBpcyBub3QgdHlwZXNjcmlwdCwgc28gd2UgZ2VuZXJhdGUgaW4gYSBzdGFnaW5nIGRpcmVjdG9yeSBhbmRcbiAgICAvLyB1c2UganNpaS1zcmNtYWsgdG8gY29tcGlsZSBhbmQgZXh0cmFjdCB0aGUgbGFuZ3VhZ2Utc3BlY2lmaWMgc291cmNlXG4gICAgLy8gaW50byBvdXIgcHJvamVjdC5cbiAgICBhd2FpdCBjb2RlLnNhdmUoc3RhZ2luZyk7XG5cbiAgICAvLyBhcyB0aGUgYWJvdmUgZ2VuZXJhdGVkIHRoZSBUeXBlc2NyaXB0IGNvZGUgZm9yIGFsbCBwcm92aWRlcnMgYW5kIG1vZHVsZXMsXG4gICAgLy8gd2UgbmVlZCB0byBmaWx0ZXIgb3V0IHRoZSBvbmVzIHdlIGRvbid0IG5lZWQgc28gdGhleSBkb24ndCBlbmQgdXAgaW4gdGhlIEpTSUkgYnVuZGxlIG92ZXIgYW5kIG92ZXIgYWdhaW4uXG4gICAgY29uc3QgZmlsZXNUb0RlbGV0ZSA9IGRpc2FsbG93ZWRGaWxlR2xvYnMuZmxhdE1hcCgocGF0dGVybikgPT5cbiAgICAgIGdsb2Iuc3luYyhwYXR0ZXJuLCB7IGN3ZDogc3RhZ2luZyB9KVxuICAgICk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBmaWxlc1RvRGVsZXRlLm1hcCgoZmlsZSkgPT4gZnMucmVtb3ZlKHBhdGguam9pbihzdGFnaW5nLCBmaWxlKSkpXG4gICAgKTtcblxuICAgIC8vIENvbXBpbGUgd2l0aCBKU0lJXG4gICAgY29uc3QganNpaUFyZ3MgPSBbXCItLXNpbGVuY2Utd2FybmluZ3NcIiwgXCJyZXNlcnZlZC13b3JkXCJdO1xuICAgIGNvbnN0IGpzaWlFbnRyeXBvaW50ID0gb3B0cy5lbnRyeXBvaW50O1xuICAgIGNvbnN0IGJhc2VwYXRoID0gcGF0aC5qb2luKFxuICAgICAgcGF0aC5kaXJuYW1lKGpzaWlFbnRyeXBvaW50KSxcbiAgICAgIHBhdGguYmFzZW5hbWUoanNpaUVudHJ5cG9pbnQsIFwiLnRzXCIpXG4gICAgKTtcblxuICAgIGNvbnN0IG1vZHVsZUtleSA9IG9wdHMubW9kdWxlS2V5LnJlcGxhY2UoL1xcLi9nLCBcIlwiKS5yZXBsYWNlKC9cXC8vZywgXCJcIik7XG4gICAgY29uc3QgbW9kdWxlRGlycyA9IG9wdHMuZGVwcztcbiAgICBjb25zdCB0YXJnZXRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG4gICAgY29uc3QgZGVwczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIGZvciAoY29uc3QgZGlyIG9mIG1vZHVsZURpcnMpIHtcbiAgICAgIC8vIHJlYWQgbW9kdWxlIG1ldGFkYXRhXG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGZzLnJlYWRKc29uKHBhdGguam9pbihkaXIsIFwicGFja2FnZS5qc29uXCIpKTtcbiAgICAgIGNvbnN0IG1vZHVsZU5hbWU6IHN0cmluZyA9IG1ldGFkYXRhLm5hbWU7XG4gICAgICBjb25zdCBtb2R1bGVWZXJzaW9uOiBzdHJpbmcgPSBtZXRhZGF0YS52ZXJzaW9uO1xuXG4gICAgICBjb25zdCB0YXJnZXRkaXIgPSBwYXRoLmpvaW4oXG4gICAgICAgIHBhdGguam9pbihzdGFnaW5nLCBcIm5vZGVfbW9kdWxlc1wiKSxcbiAgICAgICAgbW9kdWxlTmFtZVxuICAgICAgKTtcbiAgICAgIGF3YWl0IGZzLm1rZGlycChwYXRoLmRpcm5hbWUodGFyZ2V0ZGlyKSk7XG4gICAgICBhd2FpdCBmcy5jb3B5KGRpciwgdGFyZ2V0ZGlyKTtcblxuICAgICAgLy8gYWRkIHRvIFwiZGVwc1wiIGFuZCBcInBlZXIgZGVwc1wiXG4gICAgICBpZiAoIW1vZHVsZU5hbWUuc3RhcnRzV2l0aChcIkB0eXBlcy9cIikpIHtcbiAgICAgICAgZGVwc1ttb2R1bGVOYW1lXSA9IG1vZHVsZVZlcnNpb247XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBrZyA9IHtcbiAgICAgIG5hbWU6IG1vZHVsZUtleSxcbiAgICAgIHZlcnNpb246IFwiMC4wLjBcIixcbiAgICAgIGF1dGhvcjogXCJnZW5lcmF0ZWRAZ2VuZXJhdGVkLmNvbVwiLFxuICAgICAgbWFpbjogYCR7YmFzZXBhdGh9LmpzYCxcbiAgICAgIHR5cGVzOiBgJHtiYXNlcGF0aH0uZC50c2AsXG4gICAgICBsaWNlbnNlOiBcIlVOTElDRU5TRURcIixcbiAgICAgIHJlcG9zaXRvcnk6IHsgdXJsOiBcImh0dHA6Ly9nZW5lcmF0ZWRcIiwgdHlwZTogXCJnaXRcIiB9LFxuICAgICAganNpaToge1xuICAgICAgICBvdXRkaXI6IFwiZGlzdFwiLFxuICAgICAgICB0YXJnZXRzOiB0YXJnZXRzLFxuICAgICAgfSxcbiAgICAgIGRlcGVuZGVuY2llczogZGVwcyxcbiAgICAgIHBlZXJEZXBlbmRlbmNpZXM6IGRlcHMsXG4gICAgfTtcblxuICAgIGlmIChvcHRzLmV4cG9ydHMpIHtcbiAgICAgIChwa2cgYXMgUmVjb3JkPHN0cmluZywgYW55PikuZXhwb3J0cyA9IG9wdHMuZXhwb3J0cztcbiAgICB9XG4gICAgaWYgKG9wdHMucHl0aG9uKSB7XG4gICAgICB0YXJnZXRzLnB5dGhvbiA9IHtcbiAgICAgICAgZGlzdE5hbWU6IFwiZ2VuZXJhdGVkXCIsXG4gICAgICAgIG1vZHVsZTogb3B0cy5weXRob24ubW9kdWxlTmFtZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuamF2YSkge1xuICAgICAgdGFyZ2V0cy5qYXZhID0ge1xuICAgICAgICBwYWNrYWdlOiBvcHRzLmphdmEucGFja2FnZSxcbiAgICAgICAgbWF2ZW46IHtcbiAgICAgICAgICBncm91cElkOiBcImdlbmVyYXRlZFwiLFxuICAgICAgICAgIGFydGlmYWN0SWQ6IFwiZ2VuZXJhdGVkXCIsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChvcHRzLmNzaGFycCkge1xuICAgICAgdGFyZ2V0cy5kb3RuZXQgPSB7XG4gICAgICAgIG5hbWVzcGFjZTogb3B0cy5jc2hhcnAubmFtZXNwYWNlLFxuICAgICAgICBwYWNrYWdlSWQ6IG9wdHMuY3NoYXJwLm5hbWVzcGFjZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZ29sYW5nKSB7XG4gICAgICB0YXJnZXRzLmdvID0ge1xuICAgICAgICBtb2R1bGVOYW1lOiBvcHRzLmdvbGFuZy5tb2R1bGVOYW1lLFxuICAgICAgICBwYWNrYWdlTmFtZTogb3B0cy5nb2xhbmcucGFja2FnZU5hbWUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShcbiAgICAgIHBhdGguam9pbihzdGFnaW5nLCBcInBhY2thZ2UuanNvblwiKSxcbiAgICAgIEpTT04uc3RyaW5naWZ5KHBrZywgdW5kZWZpbmVkLCAyKVxuICAgICk7XG5cbiAgICBjb25zdCBlbmRKc2lpVGltZXIgPSBsb2dUaW1lc3BhbihcImpzaWlcIik7XG4gICAgYXdhaXQgZXhlYyhqc2lpTW9kdWxlLCBqc2lpQXJncywge1xuICAgICAgY3dkOiBzdGFnaW5nLFxuICAgIH0pO1xuICAgIGVuZEpzaWlUaW1lcigpO1xuXG4gICAgLy8gZXh0cmFjdCAuanNpaSBpZiByZXF1ZXN0ZWRcbiAgICBpZiAob3B0cy5qc2lpKSB7XG4gICAgICBhd2FpdCBmcy5jb3B5KHBhdGguam9pbihzdGFnaW5nLCBcIi5qc2lpXCIpLCBvcHRzLmpzaWkucGF0aCk7XG4gICAgfVxuXG4gICAgLy8gcnVuIHBhY21hayB0byBnZW5lcmF0ZSBjb2RlXG4gICAgY29uc3QgZW5kSnNpaVBhY21ha1RpbWVyID0gbG9nVGltZXNwYW4oXCJqc2lpLXBhY21ha1wiKTtcbiAgICBhd2FpdCBleGVjKHBhY21ha01vZHVsZSwgW1wiLS1jb2RlLW9ubHlcIl0sIHsgY3dkOiBzdGFnaW5nIH0pO1xuICAgIGVuZEpzaWlQYWNtYWtUaW1lcigpO1xuXG4gICAgaWYgKG9wdHMucHl0aG9uKSB7XG4gICAgICBjb25zdCByZWxkaXIgPSBvcHRzLnB5dGhvbi5tb2R1bGVOYW1lLnJlcGxhY2UoL1xcLi9nLCBcIi9cIik7IC8vIGpzaWkgcmVwbGFjZXMgXCIuXCIgd2l0aCBcIi9cIlxuICAgICAgY29uc3Qgc291cmNlID0gcGF0aC5yZXNvbHZlKFxuICAgICAgICBwYXRoLmpvaW4oc3RhZ2luZywgXCJkaXN0L3B5dGhvbi9zcmNcIiwgcmVsZGlyKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHBhdGguam9pbihvcHRzLnB5dGhvbi5vdXRkaXIsIHJlbGRpcik7XG4gICAgICBhd2FpdCBmcy5tb3ZlKHNvdXJjZSwgdGFyZ2V0LCB7IG92ZXJ3cml0ZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5qYXZhKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBwYXRoLnJlc29sdmUocGF0aC5qb2luKHN0YWdpbmcsIFwiZGlzdC9qYXZhL3NyYy9cIikpO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gcGF0aC5qb2luKG9wdHMuamF2YS5vdXRkaXIsIFwic3JjL1wiKTtcbiAgICAgIGF3YWl0IGZzLm1rZGlycCh0YXJnZXQpOyAvLyBtYWtlIHN1cmUgdGFyZ2V0IGRpcmVjdG9yeSBleGlzdHNcbiAgICAgIGF3YWl0IGZzLmNvcHkoc291cmNlLCB0YXJnZXQsIHsgcmVjdXJzaXZlOiB0cnVlLCBvdmVyd3JpdGU6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmNzaGFycCkge1xuICAgICAgY29uc3QgcmVsZGlyID0gb3B0cy5jc2hhcnAubmFtZXNwYWNlO1xuICAgICAgY29uc3Qgc291cmNlID0gcGF0aC5yZXNvbHZlKHBhdGguam9pbihzdGFnaW5nLCBcImRpc3QvZG90bmV0L1wiLCByZWxkaXIpKTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHBhdGguam9pbihvcHRzLmNzaGFycC5vdXRkaXIsIHJlbGRpcik7XG4gICAgICBhd2FpdCBmcy5tb3ZlKHNvdXJjZSwgdGFyZ2V0LCB7IG92ZXJ3cml0ZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5nb2xhbmcpIHtcbiAgICAgIGNvbnN0IHJlbGRpciA9IG9wdHMuZ29sYW5nLnBhY2thZ2VOYW1lO1xuICAgICAgY29uc3Qgc291cmNlID0gcGF0aC5yZXNvbHZlKHBhdGguam9pbihzdGFnaW5nLCBcImRpc3QvZ28vXCIsIHJlbGRpcikpO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gcGF0aC5qb2luKG9wdHMuZ29sYW5nLm91dGRpciwgcmVsZGlyKTtcbiAgICAgIGF3YWl0IGZzLm1vdmUoc291cmNlLCB0YXJnZXQsIHsgb3ZlcndyaXRlOiB0cnVlIH0pO1xuICAgICAgLy8gcmVtb3ZlIGdvLm1vZCBhcyB0aGlzIHdvdWxkIG1ha2UgaXQgYSBzdWJtb2R1bGVcbiAgICAgIGF3YWl0IGZzLnJlbW92ZShwYXRoLmpvaW4odGFyZ2V0LCBcImdvLm1vZFwiKSk7XG4gICAgfVxuXG4gICAgW1widmVyc2lvbnMuanNvblwiLCBcImNvbnN0cmFpbnRzLmpzb25cIl0uZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY29weVN5bmMoXG4gICAgICAgICAgcGF0aC5yZXNvbHZlKHN0YWdpbmcsIGZpbGUpLFxuICAgICAgICAgIHBhdGgucmVzb2x2ZShvdXRwdXRQYXRoLCBmaWxlKVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYEZhaWxlZCB0byBjb3B5ICR7ZmlsZX06ICR7ZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbnR5cGUgQ29uc3RyYWludEZpbGUgPSB7IHByb3ZpZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjsgY2RrdGY6IHN0cmluZyB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIEdldE9wdGlvbnMge1xuICByZWFkb25seSB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2U7XG4gIHJlYWRvbmx5IGNvZGVNYWtlck91dHB1dDogc3RyaW5nO1xuICByZWFkb25seSBqc2lpUGFyYWxsZWxpc20/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBQYXRoIHRvIGNvcHkgdGhlIG91dHB1dCAuanNpaSBmaWxlLlxuICAgKiBAZGVmYXVsdCAtIGpzaWkgZmlsZSBpcyBub3QgZW1pdHRlZFxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0SnNpaT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIENvbnN0cnVjdHNNYWtlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29kZU1ha2VyT3V0ZGlyOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgY29kZTogQ29kZU1ha2VyO1xuICBwcml2YXRlIHZlcnNpb25zOiB7IFtwcm92aWRlck5hbWU6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogR2V0T3B0aW9ucyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNjaGVtYUNhY2hlUGF0aD86IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlcG9ydFRlbGVtZXRyeTogKHBheWxvYWQ6IHtcbiAgICAgIHRhcmdldExhbmd1YWdlOiBzdHJpbmc7XG4gICAgICB0cmFja2luZ1BheWxvYWQ6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgfSkgPT4gUHJvbWlzZTx2b2lkPiA9IGFzeW5jICgpID0+IHt9XG4gICkge1xuICAgIHRoaXMuY29kZU1ha2VyT3V0ZGlyID0gcGF0aC5yZXNvbHZlKHRoaXMub3B0aW9ucy5jb2RlTWFrZXJPdXRwdXQpO1xuICAgIGZzLm1rZGlycFN5bmModGhpcy5jb2RlTWFrZXJPdXRkaXIpO1xuICAgIHRoaXMuY29kZSA9IG5ldyBDb2RlTWFrZXIoKTtcbiAgICB0aGlzLnZlcnNpb25zID0ge307XG4gIH1cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZVR5cGVzY3JpcHRQcm92aWRlcihcbiAgICB0YXJnZXQ6IENvbnN0cnVjdHNNYWtlclByb3ZpZGVyVGFyZ2V0LFxuICAgIHNjaGVtYTogUHJvdmlkZXJTY2hlbWFcbiAgKSB7XG4gICAgY29uc3QgZW5kVFNUaW1lciA9IGxvZ1RpbWVzcGFuKGBHZW5lcmF0ZSBUeXBlc2NyaXB0IGZvciAke3RhcmdldC5uYW1lfWApO1xuICAgIGNvbnN0IGdlbmVyYXRvciA9IG5ldyBUZXJyYWZvcm1Qcm92aWRlckdlbmVyYXRvcih0aGlzLmNvZGUsIHNjaGVtYSk7XG4gICAgZ2VuZXJhdG9yLmdlbmVyYXRlKHRhcmdldCk7XG5cbiAgICB0aGlzLnZlcnNpb25zID0geyAuLi50aGlzLnZlcnNpb25zLCAuLi5nZW5lcmF0b3IudmVyc2lvbnMgfTtcbiAgICBlbmRUU1RpbWVyKCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZmlsdGVyQWxyZWFkeUdlbmVyYXRlZChcbiAgICBjb25zdHJhaW50czogVGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnRbXVxuICApIHtcbiAgICBsZXQgY29uc3RyYWludHNGaWxlID0gXCJ7fVwiO1xuICAgIHRyeSB7XG4gICAgICBjb25zdHJhaW50c0ZpbGUgPSBhd2FpdCBmcy5yZWFkRmlsZShcbiAgICAgICAgcGF0aC5qb2luKHRoaXMuY29kZU1ha2VyT3V0ZGlyLCBcImNvbnN0cmFpbnRzLmpzb25cIiksXG4gICAgICAgIFwidXRmOFwiXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYENvdWxkIG5vdCBmaW5kIGNvbnN0cmFpbnRzLmpzb24gZmlsZSB3aGlsZSBmaWx0ZXJpbmc6ICR7ZX0uIFRoaXMgbWVhbnMgbm8gcHJvdmlkZXJzIHdlcmUgZ2VuZXJhdGVkLCBzbyBhbGwgY29uc3RyYWludHMgbmVlZCB0byBiZSBnZW5lcmF0ZWQuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgICB9XG4gICAgbG9nZ2VyLmRlYnVnKGBGb3VuZCBjb25zdHJhaW50cy5qc29uIGZpbGU6ICR7Y29uc3RyYWludHNGaWxlfWApO1xuXG4gICAgbGV0IHByZXZpb3VzQ29uc3RyYWludHM6IFBhcnRpYWw8Q29uc3RyYWludEZpbGU+ID0ge307XG4gICAgdHJ5IHtcbiAgICAgIHByZXZpb3VzQ29uc3RyYWludHMgPSBKU09OLnBhcnNlKGNvbnN0cmFpbnRzRmlsZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgIGBDb3VsZCBub3QgcGFyc2UgY29uc3RyYWludHMuanNvbiBmaWxlIHdoaWxlIGZpbHRlcmluZzogJHtlfS4gR2VuZXJhdGluZyBhbGwgY29uc3RyYWludHMuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgICB9XG5cbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgRm91bmQgcHJldmlvdXMgY29uc3RyYWludHM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHByZXZpb3VzQ29uc3RyYWludHMsXG4gICAgICAgIG51bGwsXG4gICAgICAgIDJcbiAgICAgICl9YFxuICAgICk7XG5cbiAgICBpZiAoXG4gICAgICAhcHJldmlvdXNDb25zdHJhaW50cy5wcm92aWRlcnMgfHxcbiAgICAgIHR5cGVvZiBwcmV2aW91c0NvbnN0cmFpbnRzLnByb3ZpZGVycyAhPT0gXCJvYmplY3RcIlxuICAgICkge1xuICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgIGBDb3VsZCBub3QgZmluZCBwcm92aWRlcnMgaW4gY29uc3RyYWludHMuanNvbiBmaWxlLCBnZW5lcmF0aW5nIGFsbCBjb25zdHJhaW50cy4gVGhlIGNvbnN0cmFpbnRzIGZpbGUgd2FzICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgcHJldmlvdXNDb25zdHJhaW50cyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIDJcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH1cblxuICAgIGlmIChwcmV2aW91c0NvbnN0cmFpbnRzLmNka3RmICE9PSBESVNQTEFZX1ZFUlNJT04pIHtcbiAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICBgVGhlIENES1RGIHZlcnNpb24gaGFzIGNoYW5nZWQsIGdlbmVyYXRpbmcgYWxsIGNvbnN0cmFpbnRzLiBUaGUgcHJldmlvdXMgdmVyc2lvbiB3YXMgJHtwcmV2aW91c0NvbnN0cmFpbnRzLmNka3RmfSwgdGhlIGN1cnJlbnQgdmVyc2lvbiBpcyAke0RJU1BMQVlfVkVSU0lPTn1gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnN0cmFpbnRzVG9HZW5lcmF0ZSA9IGNvbnN0cmFpbnRzLmZpbHRlcigoY29uc3RyYWludCkgPT4ge1xuICAgICAgY29uc3QgY29uc3RyYWludE1hdGNoZXMgPVxuICAgICAgICBwcmV2aW91c0NvbnN0cmFpbnRzLnByb3ZpZGVycyFbY29uc3RyYWludC5mcW5dID09PSBjb25zdHJhaW50LnZlcnNpb247XG4gICAgICBsZXQgcHJvdmlkZXJGb2xkZXJFeGlzdHMgPSBmYWxzZTtcblxuICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2UpIHtcbiAgICAgICAgY2FzZSBMYW5ndWFnZS5UWVBFU0NSSVBUOlxuICAgICAgICAgIHByb3ZpZGVyRm9sZGVyRXhpc3RzID0gZnMuZXhpc3RzU3luYyhcbiAgICAgICAgICAgIHBhdGguam9pbih0aGlzLmNvZGVNYWtlck91dGRpciwgXCJwcm92aWRlcnNcIiwgY29uc3RyYWludC5uYW1lKVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGFuZ3VhZ2UuUFlUSE9OOlxuICAgICAgICBjYXNlIExhbmd1YWdlLkpBVkE6XG4gICAgICAgIGNhc2UgTGFuZ3VhZ2UuQ1NIQVJQOlxuICAgICAgICAgIHByb3ZpZGVyRm9sZGVyRXhpc3RzID0gZnMuZXhpc3RzU3luYyhcbiAgICAgICAgICAgIHBhdGguam9pbih0aGlzLmNvZGVNYWtlck91dGRpciwgY29uc3RyYWludC5uYW1lKVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTGFuZ3VhZ2UuR086XG4gICAgICAgICAgcHJvdmlkZXJGb2xkZXJFeGlzdHMgPSBmcy5leGlzdHNTeW5jKFxuICAgICAgICAgICAgcGF0aC5qb2luKFxuICAgICAgICAgICAgICB0aGlzLmNvZGVNYWtlck91dGRpcixcbiAgICAgICAgICAgICAgY29uc3RyYWludC5uYW1lc3BhY2UgfHwgXCJoYXNoaWNvcnBcIixcbiAgICAgICAgICAgICAgY29uc3RyYWludC5uYW1lXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvdmlkZXJFeGlzdHMgPSBjb25zdHJhaW50TWF0Y2hlcyAmJiBwcm92aWRlckZvbGRlckV4aXN0cztcbiAgICAgIHJldHVybiAhcHJvdmlkZXJFeGlzdHM7XG4gICAgfSk7XG5cbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgQ29uc3RyYWludHMgdG8gZ2VuZXJhdGU6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIGNvbnN0cmFpbnRzVG9HZW5lcmF0ZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMlxuICAgICAgKX1gXG4gICAgKTtcblxuICAgIHJldHVybiBjb25zdHJhaW50c1RvR2VuZXJhdGU7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlVHlwZXNjcmlwdE1vZHVsZShcbiAgICB0YXJnZXQ6IENvbnN0cnVjdHNNYWtlck1vZHVsZVRhcmdldCxcbiAgICBzY2hlbWE6IE1vZHVsZVNjaGVtYVxuICApIHtcbiAgICBjb25zdCBlbmRUU1RpbWVyID0gbG9nVGltZXNwYW4oYEdlbmVyYXRlIFR5cGVzY3JpcHQgZm9yICR7dGFyZ2V0Lm5hbWV9YCk7XG4gICAgdGFyZ2V0LnNwZWMgPSBzY2hlbWE7XG4gICAgbmV3IE1vZHVsZUdlbmVyYXRvcih0aGlzLmNvZGUsIFt0YXJnZXRdKTtcbiAgICBlbmRUU1RpbWVyKCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlVHlwZXNjcmlwdChcbiAgICB0YXJnZXQ6IENvbnN0cnVjdHNNYWtlclRhcmdldCxcbiAgICBzY2hlbWFzOiBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIHJlYWRTY2hlbWE+PlxuICApIHtcbiAgICBpZiAodGFyZ2V0LmlzTW9kdWxlKSB7XG4gICAgICBjb25zdCBzY2hlbWEgPSBzY2hlbWFzLm1vZHVsZVNjaGVtYT8uW3RhcmdldC5tb2R1bGVLZXldO1xuICAgICAgaWYgKCFzY2hlbWEpIHtcbiAgICAgICAgdGhyb3cgRXJyb3JzLkludGVybmFsKFxuICAgICAgICAgIGBDb3VsZCBub3QgZ2VuZXJhdGUgc2NoZW1hIGZvciBtb2R1bGUgJHt0YXJnZXQubW9kdWxlS2V5fWBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5nZW5lcmF0ZVR5cGVzY3JpcHRNb2R1bGUoXG4gICAgICAgIHRhcmdldCBhcyBDb25zdHJ1Y3RzTWFrZXJNb2R1bGVUYXJnZXQsXG4gICAgICAgIHNjaGVtYVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5pc1Byb3ZpZGVyKSB7XG4gICAgICBpZiAoIXNjaGVtYXMucHJvdmlkZXJTY2hlbWEpIHtcbiAgICAgICAgdGhyb3cgRXJyb3JzLkludGVybmFsKGBDb3VsZCBub3QgZ2VuZXJhdGUgc2NoZW1hIGZvciBwcm92aWRlcnNgKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5nZW5lcmF0ZVR5cGVzY3JpcHRQcm92aWRlcihcbiAgICAgICAgdGFyZ2V0IGFzIENvbnN0cnVjdHNNYWtlclByb3ZpZGVyVGFyZ2V0LFxuICAgICAgICBzY2hlbWFzLnByb3ZpZGVyU2NoZW1hXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBVbmtub3duIHRhcmdldCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYmluZGluZ3M6ICR7dGFyZ2V0Lm5hbWV9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBlbWl0cyBhIHZlcnNpb25zLmpzb24gZmlsZSB3aXRoIGEgbWFwIG9mIHRoZSB1c2VkIHZlcnNpb24gZm9yIGVhY2ggcHJvdmlkZXIgZnFwblxuICBwcml2YXRlIHVwZGF0ZVZlcnNpb25zRmlsZShcbiAgICBhbGxvd2VkQ29uc3RyYWludHM6IFRlcnJhZm9ybURlcGVuZGVuY3lDb25zdHJhaW50W11cbiAgKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgYFVwZGF0aW5nIHZlcnNpb25zIGZpbGUgd2l0aCBnZW5lcmF0ZWQgdmVyc2lvbnMgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgdGhpcy52ZXJzaW9ucyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMlxuICAgICAgKX0gd2l0aCBhbGxvd2VkIGNvbnN0cmFpbnRzICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIGFsbG93ZWRDb25zdHJhaW50cyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMlxuICAgICAgKX1gXG4gICAgKTtcbiAgICBjb25zdCBmaWxlUGF0aCA9IFwidmVyc2lvbnMuanNvblwiO1xuICAgIGxldCBwcmV2aW91c1ZlcnNpb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgdHJ5IHtcbiAgICAgIHByZXZpb3VzVmVyc2lvbnMgPSBKU09OLnBhcnNlKFxuICAgICAgICBmcy5yZWFkRmlsZVN5bmMocGF0aC5yZXNvbHZlKHRoaXMuY29kZU1ha2VyT3V0ZGlyLCBmaWxlUGF0aCksIFwidXRmOFwiKVxuICAgICAgKTtcblxuICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICBgUmVhZCBleGlzdGluZyB2ZXJzaW9ucyBmaWxlOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHByZXZpb3VzVmVyc2lvbnMsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAyXG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZ25vcmVcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYENvdWxkIG5vdCByZWFkIHZlcnNpb25zIGZpbGUsIHRoaXMgaXMgZXhwZWN0ZWQgaWYgdGhlcmUgYXJlIG5vIHByZS1leGlzdGluZyBsb2NhbCBwcm92aWRlcnM6ICR7ZX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHZlcnNpb25zID0gYWxsb3dlZENvbnN0cmFpbnRzLnJlZHVjZSgoYWNjLCBjb25zdHJhaW50KSA9PiB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IE9iamVjdC5lbnRyaWVzKHByZXZpb3VzVmVyc2lvbnMpLmZpbmQoKFtuYW1lXSkgPT5cbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBtb3JlIHJlZmluZWQsIGJ1dCBpdCdzIGdvb2QgZW5vdWdoIGZvciBub3dcbiAgICAgICAgbmFtZS5lbmRzV2l0aChjb25zdHJhaW50LmZxbilcbiAgICAgICk7XG5cbiAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICBjb25zdCBbbmFtZSwgdmVyc2lvbl0gPSBwcm92aWRlcjtcbiAgICAgICAgcmV0dXJuIHsgLi4uYWNjLCBbbmFtZV06IHZlcnNpb24gfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG5cbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgV3JpdGluZyB2ZXJzaW9ucyBmaWxlICgke2ZpbGVQYXRofSk6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHZlcnNpb25zLFxuICAgICAgICBudWxsLFxuICAgICAgICAyXG4gICAgICApfWBcbiAgICApO1xuXG4gICAgdGhpcy5jb2RlLm9wZW5GaWxlKGZpbGVQYXRoKTtcbiAgICB0aGlzLmNvZGUubGluZShKU09OLnN0cmluZ2lmeSh7IC4uLnZlcnNpb25zLCAuLi50aGlzLnZlcnNpb25zIH0sIG51bGwsIDIpKTtcbiAgICB0aGlzLmNvZGUuY2xvc2VGaWxlKGZpbGVQYXRoKTtcbiAgICByZXR1cm4gZmlsZVBhdGg7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVtb3ZlRm9sZGVyc1RoYXRTaG91bGROb3RFeGlzdChcbiAgICBjb25zdHJhaW50c1RoYXRTaG91bGRFeGlzdDogVGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnRbXVxuICApIHtcbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgUmVtb3ZpbmcgcHJvdmlkZXJzIGV4Y2VwdCBmb3IgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgY29uc3RyYWludHNUaGF0U2hvdWxkRXhpc3QsXG4gICAgICAgIG51bGwsXG4gICAgICAgIDJcbiAgICAgICl9YFxuICAgICk7XG5cbiAgICAvLyBBbGwgbGFuZ3VhZ2VzIGJlc2lkZXMgVFMga2VlcCB0aGVpciBwcm92aWRlcnMgaW4gdGhlIHNhbWUgZm9sZGVycyBhcyBtb2R1bGVzXG4gICAgLy8gdGhpcyBtYWtlcyBpdCBpbXBvc3NpYmxlIGZvciB1cyB0byBkaXN0aW5ndWlzaCBhIG5vIGxvbmdlciByZXF1aXJlZCBwcm92aWRlclxuICAgIC8vIGZyb20gYSBtYW51YWxseSB3cml0dGVuIGNvbnN0cnVjdCBvciBhIG1vZHVsZVxuICAgIGlmICghdGhpcy5pc0phdmFzY3JpcHRUYXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZmlsZXNJblByb3ZpZGVyczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBwcm92aWRlcnNGb2xkZXIgPSBwYXRoLnJlc29sdmUodGhpcy5jb2RlTWFrZXJPdXRkaXIsIFwicHJvdmlkZXJzXCIpO1xuICAgIHRyeSB7XG4gICAgICBmaWxlc0luUHJvdmlkZXJzID0gYXdhaXQgZnMucmVhZGRpcihwcm92aWRlcnNGb2xkZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYEVycm9yIGxpc3RpbmcgZmlsZXMgaW4gcHJvdmlkZXJzIGZvbGRlciAnJHtwcm92aWRlcnNGb2xkZXJ9JzogJHtlfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9sZGVycyA9IGZpbGVzSW5Qcm92aWRlcnMuZmlsdGVyKChmaWxlKSA9PlxuICAgICAgZnNcbiAgICAgICAgLnN0YXRTeW5jKHBhdGgucmVzb2x2ZSh0aGlzLmNvZGVNYWtlck91dGRpciwgXCJwcm92aWRlcnNcIiwgZmlsZSkpXG4gICAgICAgIC5pc0RpcmVjdG9yeSgpXG4gICAgKTtcblxuICAgIHJldHVybiBmb2xkZXJzLmZvckVhY2goKGZvbGRlcikgPT4ge1xuICAgICAgY29uc3Qgc2hvdWxkRXhpc3QgPSBjb25zdHJhaW50c1RoYXRTaG91bGRFeGlzdC5zb21lKFxuICAgICAgICAoY29uc3RyYWludCkgPT4gY29uc3RyYWludC5uYW1lID09PSBmb2xkZXJcbiAgICAgICk7XG5cbiAgICAgIGlmICghc2hvdWxkRXhpc3QpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBSZW1vdmluZyBmb2xkZXIgJHtmb2xkZXJ9IGZyb20gcHJvdmlkZXJzYCk7XG4gICAgICAgIGZzLnJlbW92ZVN5bmMocGF0aC5yZXNvbHZlKHRoaXMuY29kZU1ha2VyT3V0ZGlyLCBcInByb3ZpZGVyc1wiLCBmb2xkZXIpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGVtaXRzIGEgY29uc3RyYWludHMuanNvbiBmaWxlIHdpdGggYSBtYXAgb2YgdGhlIHVzZWQgcHJvdmlkZXIgZnFwbnMgYW5kIHZlcnNpb24gY29uc3RyYWludHNcbiAgLy8gdGhpcyBpcyB1c2VkIGZvciBjYWNoaW5nIHB1cnBvc2VzXG4gIHByaXZhdGUgZW1pdENvbnN0cmFpbnRzRmlsZShcbiAgICBhbGxvd2VkQ29uc3RyYWludHM6IFRlcnJhZm9ybURlcGVuZGVuY3lDb25zdHJhaW50W11cbiAgKSB7XG4gICAgY29uc3QgZmlsZVBhdGggPSBcImNvbnN0cmFpbnRzLmpzb25cIjtcblxuICAgIGNvbnN0IGNvbnRlbnQ6IENvbnN0cmFpbnRGaWxlID0ge1xuICAgICAgY2RrdGY6IERJU1BMQVlfVkVSU0lPTixcbiAgICAgIHByb3ZpZGVyczogYWxsb3dlZENvbnN0cmFpbnRzXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmZxbi5sb2NhbGVDb21wYXJlKGIuZnFuKSlcbiAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAoY2FycnksIGl0ZW0pID0+ICh7XG4gICAgICAgICAgICAuLi5jYXJyeSxcbiAgICAgICAgICAgIFtpdGVtLmZxbl06IGl0ZW0udmVyc2lvbixcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7fVxuICAgICAgICApLFxuICAgIH07XG5cbiAgICB0aGlzLmNvZGUub3BlbkZpbGUoZmlsZVBhdGgpO1xuICAgIHRoaXMuY29kZS5saW5lKEpTT04uc3RyaW5naWZ5KGNvbnRlbnQsIG51bGwsIDIpKTtcbiAgICB0aGlzLmNvZGUuY2xvc2VGaWxlKGZpbGVQYXRoKTtcbiAgICByZXR1cm4gZmlsZVBhdGg7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlSnNpaUxhbmd1YWdlKHRhcmdldDogQ29uc3RydWN0c01ha2VyVGFyZ2V0KSB7XG4gICAgLy8gdGhlc2UgYXJlIHRoZSBtb2R1bGUgZGVwZW5kZW5jaWVzIHdlIGNvbXBpbGUgYWdhaW5zdFxuICAgIGNvbnN0IGRlcHMgPSBbXCJAdHlwZXMvbm9kZVwiLCBcImNvbnN0cnVjdHNcIiwgXCJjZGt0ZlwiXTtcbiAgICBjb25zdCBvcHRzOiBHZW5lcmF0ZUpTSUlPcHRpb25zID0ge1xuICAgICAgZW50cnlwb2ludDogdGFyZ2V0LmZpbGVOYW1lLFxuICAgICAgZGVwczogZGVwcy5tYXAoKGRlcCkgPT5cbiAgICAgICAgcGF0aC5kaXJuYW1lKHJlcXVpcmUucmVzb2x2ZShgJHtkZXB9L3BhY2thZ2UuanNvbmApKVxuICAgICAgKSxcbiAgICAgIG1vZHVsZUtleTogdGFyZ2V0Lm1vZHVsZUtleSxcbiAgICAgIGV4cG9ydHM6IHRhcmdldC5pc1Byb3ZpZGVyIC8vIE1vZHVsZXMgYXJlIHNtYWxsIGVub3VnaCB0aGF0IHdlIGRvbid0IG5lZWQgdGhpcyBvcHRpbWl6YXRpb25cbiAgICAgICAgPyB7XG4gICAgICAgICAgICBcIi5cIjoge1xuICAgICAgICAgICAgICBpbXBvcnQ6IGAuL3Byb3ZpZGVycy8ke3RhcmdldC5uYW1lfS9pbmRleC5qc2AsXG4gICAgICAgICAgICAgIHJlcXVpcmU6IGAuL3Byb3ZpZGVycy8ke3RhcmdldC5uYW1lfS9sYXp5LWluZGV4LmpzYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICB9O1xuXG4gICAgLy8gdXNlZCBmb3IgdGVzdGluZy5cbiAgICBpZiAodGhpcy5vcHRpb25zLm91dHB1dEpzaWkpIHtcbiAgICAgIG9wdHMuanNpaSA9IHsgcGF0aDogdGhpcy5vcHRpb25zLm91dHB1dEpzaWkgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1B5dGhvblRhcmdldCkge1xuICAgICAgb3B0cy5weXRob24gPSB7XG4gICAgICAgIG91dGRpcjogdGhpcy5jb2RlTWFrZXJPdXRkaXIsXG4gICAgICAgIG1vZHVsZU5hbWU6IHRhcmdldC5zcmNNYWtOYW1lLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0phdmFUYXJnZXQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvZGVNYWtlck91dHB1dC5pbmNsdWRlcyhcIi9cIikgfHxcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvZGVNYWtlck91dHB1dC5pbmNsdWRlcyhcIlxcXFxcIilcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoXG4gICAgICAgICAgYFdoZW4gdXNpbmcgSmF2YSB0aGUgXCJjb2RlTWFrZXJPdXRwdXRcIiBvcHRpb24gaW4gdGhlIGNka3RmLmpzb24gbXVzdCBiZSB0aGUgb3JnYW5pemF0aW9uIGlkZW50aWZpZXIgZm9yIHlvdXIgcHJvamVjdCAoZS5nLiBjb20ubXktY29tcGFueSksIG5vdCBhIHBhdGguIFRoZSBnZW5lcmF0ZWQgSmF2YSBjb2RlIHdpbGwgYmUgcGxhY2VkIGluIGEgc3ViZGlyZWN0b3J5IG9mIHRoZSBnaXZlbiBkaXJlY3RvcnkuIElmIHlvdSBhcmUgbWlncmF0aW5nIGZyb20gYSA8IDAuMTkgdmVyc2lvbiBvZiBjZGt0ZiB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIGNvZGVtYWtlck91dHB1dCB0byBcImltcG9ydHNcIi5gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG9wdHMuamF2YSA9IHtcbiAgICAgICAgb3V0ZGlyOiBcIi5cIiwgLy8gZ2VuZXJhdGVkIGphdmEgZmlsZXMgYXJlbid0IHBhY2thZ2VkLCBzbyBqdXN0IGluY2x1ZGUgZGlyZWN0bHkgaW4gYXBwXG4gICAgICAgIHBhY2thZ2U6IGAke3RoaXMub3B0aW9ucy5jb2RlTWFrZXJPdXRwdXR9LiR7dGFyZ2V0LnNyY01ha05hbWV9YCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDc2hhcnBUYXJnZXQpIHtcbiAgICAgIG9wdHMuY3NoYXJwID0ge1xuICAgICAgICBvdXRkaXI6IHRoaXMuY29kZU1ha2VyT3V0ZGlyLFxuICAgICAgICBuYW1lc3BhY2U6IHRhcmdldC5zcmNNYWtOYW1lLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0dvVGFyZ2V0KSB7XG4gICAgICAvLyBUT0RPOiBjaGVjayBpZiBuZWVkZWQgZm9yIG1vZHVsZXMgc29tZWhvd1xuICAgICAgLy8gY29uc3QgdGFyZ2V0VHlwZSA9IHRhcmdldC5pc1Byb3ZpZGVyID8gJ3Byb3ZpZGVyJyA6ICdtb2R1bGUnO1xuXG4gICAgICAvLyBqc2lpLXNyY21hYyB3aWxsIHByb2R1Y2UgYSBmb2xkZXIgaW5zaWRlIHRoaXMgZGlyIG5hbWVkIGFmdGVyIFwicGFja2FnZU5hbWVcIlxuICAgICAgLy8gc28gdGhpcyByZXN1bHRzIGluIGUuZy4gLmdlbi9oYXNoaWNvcnAvcmFuZG9tXG4gICAgICBjb25zdCBvdXRkaXIgPSBwYXRoLmpvaW4odGhpcy5jb2RlTWFrZXJPdXRkaXIsIHRhcmdldC5uYW1lc3BhY2UgPz8gXCJcIik7XG5cbiAgICAgIG9wdHMuZ29sYW5nID0ge1xuICAgICAgICBvdXRkaXIsXG4gICAgICAgIG1vZHVsZU5hbWU6IGF3YWl0IGRldGVybWluZUdvTW9kdWxlTmFtZShvdXRkaXIpLCAvLyBlLmcuIGBnaXRodWIuY29tL29yZy91c2VycHJvamVjdC8uZ2VuL2hhc2hpY29ycGBcbiAgICAgICAgcGFja2FnZU5hbWU6IHRhcmdldC5zcmNNYWtOYW1lLCAvLyBwYWNrYWdlIHdpbGwgYmUgbmFtZWQgZS5nLiByYW5kb20gZm9yIGhhc2hpY29ycC9yYW5kb21cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9PUFRJT05TICYmXG4gICAgICAhcHJvY2Vzcy5lbnYuTk9ERV9PUFRJT05TLmluY2x1ZGVzKGAtLW1heC1vbGQtc3BhY2Utc2l6ZWApXG4gICAgKSB7XG4gICAgICBsb2dnZXIud2FybihgZm91bmQgTk9ERV9PUFRJT05TIGVudmlyb25tZW50IHZhcmlhYmxlIHdpdGhvdXQgYSBzZXR0aW5nIGZvciAtLW1heC1vbGQtc3BhY2Utc2l6ZS5cblRoZSBwcm92aWRlciBnZW5lcmF0aW9uIG5lZWRzIGEgc3Vic3RhbnRpYWwgYW1vdW50IG9mIG1lbW9yeSAofjEzR0IpIGZvciBzb21lIHByb3ZpZGVycyBhbmQgbGFuZ3VhZ2VzLlxuU28gY2RrdGYtY2xpIHNldHMgaXQgdG8gTk9ERV9PUFRJT05TPVwiLS1tYXgtb2xkLXNwYWNlLXNpemU9MTYzODRcIiBieSBkZWZhdWx0LiBBcyB5b3VyIGVudmlyb25tZW50IGFscmVhZHkgY29udGFpbnNcbmEgTk9ERV9PUFRJT05TIHZhcmlhYmxlLCB3ZSB3b24ndCBvdmVycmlkZSBpdC4gSGVuY2UsIHRoZSBwcm92aWRlciBnZW5lcmF0aW9uIG1pZ2h0IGZhaWwgd2l0aCBhbiBvdXQgb2YgbWVtb3J5IGVycm9yLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmNyZWFzZSBtZW1vcnkgdG8gYWxsb3cgZ2VuZXJhdGluZyBsYXJnZSBwcm92aWRlcnMgKGkuZS4gYXdzIG9yIGF6dXJlcm0gZm9yIEdvKVxuICAgICAgLy8gc3JjbWFrIGlzIGdvaW5nIHRvIHNwYXduIGEgY2hpbGRwcm9jZXNzIChmb3IganNpaS1wYWNtYWspIHdoaWNoIGlzIGdvaW5nIHRvIGJlIGFmZmVjdGVkIGJ5IHRoaXMgZW52IHZhclxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9PUFRJT05TID0gXCItLW1heC1vbGQtc3BhY2Utc2l6ZT0xNjM4NFwiO1xuICAgIH1cblxuICAgIGNvbnN0IGpzaWlUaW1lciA9IGxvZ1RpbWVzcGFuKFwiSlNJSVwiKTtcbiAgICBhd2FpdCBnZW5lcmF0ZUpzaWlMYW5ndWFnZSh0aGlzLmNvZGUsIG9wdHMsIHRoaXMuY29kZU1ha2VyT3V0ZGlyLCBbXG4gICAgICB0YXJnZXQuaXNNb2R1bGUgPyBcInByb3ZpZGVycy8qKlwiIDogXCJtb2R1bGVzLyoqXCIsXG4gICAgXSk7XG4gICAganNpaVRpbWVyKCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0U2NoZW1hcyh0YXJnZXRzOiBUZXJyYWZvcm1EZXBlbmRlbmN5Q29uc3RyYWludFtdKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlYWRTY2hlbWEodGFyZ2V0cywgdGhpcy5zY2hlbWFDYWNoZVBhdGgpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdlbmVyYXRlKFxuICAgIGFsbENvbnN0cmFpbnRzOiBUZXJyYWZvcm1EZXBlbmRlbmN5Q29uc3RyYWludFtdLFxuICAgIGNvbnN0cmFpbnRzVG9HZW5lcmF0ZSA9IGFsbENvbnN0cmFpbnRzXG4gICkge1xuICAgIGNvbnN0IHRhcmdldHMgPSBjb25zdHJhaW50c1RvR2VuZXJhdGUubWFwKChjb25zdHJhaW50KSA9PlxuICAgICAgQ29uc3RydWN0c01ha2VyVGFyZ2V0LmZyb20oY29uc3RyYWludCwgdGhpcy5vcHRpb25zLnRhcmdldExhbmd1YWdlKVxuICAgICk7XG5cbiAgICBjb25zdCBlbmRTY2hlbWFUaW1lciA9IGxvZ1RpbWVzcGFuKFwiR2F0aGVyaW5nIHNjaGVtYVwiKTtcbiAgICBjb25zdCBzY2hlbWFzID0gYXdhaXQgdGhpcy5nZXRTY2hlbWFzKGNvbnN0cmFpbnRzVG9HZW5lcmF0ZSk7XG4gICAgZW5kU2NoZW1hVGltZXIoKTtcblxuICAgIGNvbnN0IGVuZEdlbmVyYXRlVGltZXIgPSBsb2dUaW1lc3BhbihcIkdlbmVyYXRlIFRTXCIpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdGFyZ2V0cy5tYXAoKHRhcmdldCkgPT4gdGhpcy5nZW5lcmF0ZVR5cGVzY3JpcHQodGFyZ2V0LCBzY2hlbWFzKSlcbiAgICApO1xuICAgIGVuZEdlbmVyYXRlVGltZXIoKTtcblxuICAgIHRoaXMudXBkYXRlVmVyc2lvbnNGaWxlKGFsbENvbnN0cmFpbnRzKTtcbiAgICB0aGlzLmVtaXRDb25zdHJhaW50c0ZpbGUoYWxsQ29uc3RyYWludHMpO1xuXG4gICAgaWYgKHRoaXMuaXNKYXZhc2NyaXB0VGFyZ2V0KSB7XG4gICAgICBhd2FpdCB0aGlzLnNhdmUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNKYXZhc2NyaXB0VGFyZ2V0IHx8IHRoaXMub3B0aW9ucy5vdXRwdXRKc2lpKSB7XG4gICAgICBjb25zdCBudW1iZXJPZldvcmtlcnMgPSBNYXRoLm1heChcbiAgICAgICAgMSxcbiAgICAgICAgdGhpcy5vcHRpb25zLmpzaWlQYXJhbGxlbGlzbSA9PT0gLTFcbiAgICAgICAgICA/IHRhcmdldHMubGVuZ3RoXG4gICAgICAgICAgOiB0aGlzLm9wdGlvbnMuanNpaVBhcmFsbGVsaXNtIHx8IDFcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHdvcmsgPSBbLi4udGFyZ2V0c107XG4gICAgICBjb25zdCB3b3JrZXJzID0gbmV3IEFycmF5KG51bWJlck9mV29ya2VycykuZmlsbChhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCB0YXJnZXQ6IENvbnN0cnVjdHNNYWtlclRhcmdldCB8IHVuZGVmaW5lZDtcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQgPSB3b3JrLnBvcCgpKSkge1xuICAgICAgICAgIGNvbnN0IGVuZEpzaWlUYXJnZXQgPSBsb2dUaW1lc3BhbihcbiAgICAgICAgICAgIGBHZW5lcmF0aW5nIEpTSUkgYmluZGluZ3MgZm9yICR7dGFyZ2V0Lm5hbWV9YFxuICAgICAgICAgICk7XG4gICAgICAgICAgYXdhaXQgdGhpcy5nZW5lcmF0ZUpzaWlMYW5ndWFnZSh0YXJnZXQpO1xuICAgICAgICAgIGVuZEpzaWlUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHdvcmtlcnMubWFwKChmbikgPT4gZm4oKSkpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgdHJhY2tpbmdQYXlsb2FkOiB0YXJnZXQudHJhY2tpbmdQYXlsb2FkLFxuICAgICAgICB0YXJnZXRMYW5ndWFnZTogdGFyZ2V0LnRhcmdldExhbmd1YWdlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNQeXRob25UYXJnZXQpIHtcbiAgICAgIGNvbnN0IGVuZFB5dGhvblRpbWVyID0gbG9nVGltZXNwYW4oXCJQeXRob24gcG9zdC1wcm9jZXNzaW5nXCIpO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gLiBpbXBvcnQgLi4uIHN0YXRlbWVudHMgZnJvbSByb290IGxldmVsIF9faW5pdF9fLnB5XG4gICAgICAvLyBUaGlzIHJlbW92ZXMgcm9vdC1sZXZlbCBpbXBvcnRzIG9mIG5hbWVzcGFjZXMsIGJ1dCBzYXZlcyAyNXMgc3ludGggdGltZSBmb3IgdGhlIGF3cyBwcm92aWRlciBhbG9uZVxuICAgICAgY29uc3QgYWxsSW5pdFB5UGF0aHMgPSBnbG9iXG4gICAgICAgIC5zeW5jKFwiKiovX19pbml0X18ucHlcIiwge1xuICAgICAgICAgIGN3ZDogdGhpcy5jb2RlTWFrZXJPdXRkaXIsXG4gICAgICAgIH0pXG4gICAgICAgIC8vIHNvcnQgYnkgZGVwdGgsIHNvIHdlIHN0YXJ0IHdpdGggdGhlIHNoYWxsb3dlc3QgZmlsZXNcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuc3BsaXQoXCIvXCIpLmxlbmd0aCAtIGIuc3BsaXQoXCIvXCIpLmxlbmd0aCk7XG5cbiAgICAgIGNvbnN0IHZpc2l0ZWREaXJlY3Rvcmllczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgaW5pdFB5UGF0aCBvZiBhbGxJbml0UHlQYXRocykge1xuICAgICAgICBjb25zdCBkaXJlY3RvcnlQYXRoID0gcGF0aC5kaXJuYW1lKGluaXRQeVBhdGgpO1xuICAgICAgICBpZiAodmlzaXRlZERpcmVjdG9yaWVzLnNvbWUoKGRpcikgPT4gZGlyZWN0b3J5UGF0aC5zdGFydHNXaXRoKGRpcikpKSB7XG4gICAgICAgICAgLy8gd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhpcyBkaXJlY3RvcnlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkRGlyZWN0b3JpZXMucHVzaChkaXJlY3RvcnlQYXRoKTtcblxuICAgICAgICBjb25zdCBhYnNvbHV0ZUluaXRQeVBhdGggPSBwYXRoLmpvaW4odGhpcy5jb2RlTWFrZXJPdXRkaXIsIGluaXRQeVBhdGgpO1xuICAgICAgICBjb25zdCBpbml0UHkgPSBhd2FpdCBmcy5yZWFkRmlsZShhYnNvbHV0ZUluaXRQeVBhdGgsIFwidXRmOFwiKTtcbiAgICAgICAgY29uc3QgaW5pdFB5V2l0aG91dEltcG9ydHMgPSBpbml0UHkucmVwbGFjZSgvZnJvbSBcXC4gaW1wb3J0IC4qXFxuL2csIFwiXCIpO1xuICAgICAgICBhd2FpdCBmcy53cml0ZUZpbGUoYWJzb2x1dGVJbml0UHlQYXRoLCBpbml0UHlXaXRob3V0SW1wb3J0cyk7XG4gICAgICB9XG5cbiAgICAgIGVuZFB5dGhvblRpbWVyKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzYXZlKG91dGRpciA9IHRoaXMuY29kZU1ha2VyT3V0ZGlyKSB7XG4gICAgYXdhaXQgdGhpcy5jb2RlLnNhdmUob3V0ZGlyKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGlzSmF2YXNjcmlwdFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRhcmdldExhbmd1YWdlID09PSBMYW5ndWFnZS5UWVBFU0NSSVBUO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaXNQeXRob25UYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50YXJnZXRMYW5ndWFnZSA9PT0gTGFuZ3VhZ2UuUFlUSE9OO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaXNKYXZhVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2UgPT09IExhbmd1YWdlLkpBVkE7XG4gIH1cblxuICBwcml2YXRlIGdldCBpc0NzaGFycFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRhcmdldExhbmd1YWdlID09PSBMYW5ndWFnZS5DU0hBUlA7XG4gIH1cblxuICBwcml2YXRlIGdldCBpc0dvVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2UgPT09IExhbmd1YWdlLkdPO1xuICB9XG59XG5cbi8qKlxuICogc2VhcmNoZXMgZm9yIHRoZSBjbG9zZXN0IGBnby5tb2RgIGZpbGUgYW5kIHJldHVybnMgdGhlIG5lc3RlZCBnbyBtb2R1bGUgbmFtZSBmb3IgYGRpcmBcbiAqIGUuZy4gKC9kaXIvLmdlbi8pID0+IGNkay50Zi9zdGFjay8uZ2VuIGlmIHRoZSBwYXJlbnQgZGlyIG9mIC5nZW4gaGFzIGEgZ28ubW9kIGZvciBcIm1vZHVsZSBjZGsudGYvc3RhY2tcIlxuICpcbiAqIEBwYXJhbSBkaXIgdGhlIGRpcmVjdG9yeSB0byBzdGFydCB0aGUgc2VhcmNoIGZyb20gKHNlYXJjaGVzIHVwd2FyZHMpXG4gKiBAcmV0dXJucyB0aGUgcGFja2FnZSBuYW1lIGZvciBgZGlyYFxuICogQHRocm93cyBhbiBFcnJvciBpZiBubyBnby5tb2Qgd2FzIGZvdW5kXG4gKi9cbmV4cG9ydCBjb25zdCBkZXRlcm1pbmVHb01vZHVsZU5hbWUgPSBhc3luYyAoZGlyOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICBsZXQgcHJldmlvdXNEaXI7XG4gIGxldCBjdXJyZW50RGlyID0gcGF0aC5yZXNvbHZlKGRpcik7XG5cbiAgZG8ge1xuICAgIGxldCBmaWxlczogc3RyaW5nW10gPSBbXTtcbiAgICB0cnkge1xuICAgICAgZmlsZXMgPSBhd2FpdCBmcy5yZWFkZGlyKGN1cnJlbnREaXIpO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgLy8gZGlyZWN0b3J5IG1pZ2h0IG5vdCBleGlzdCB5ZXQsIGJ1dCB3ZSBzdGlsbCB3YWxrIHVwd2FyZHMgZnJvbSB0aGVyZSwgc28gaWdub3JlICdFTk9FTlQnXG4gICAgICBpZiAoZS5jb2RlICE9PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaWxlcy5pbmNsdWRlcyhcImdvLm1vZFwiKSkge1xuICAgICAgY29uc3QgZmlsZSA9IHBhdGgucmVzb2x2ZShjdXJyZW50RGlyLCBcImdvLm1vZFwiKTtcbiAgICAgIGNvbnN0IGdvbW9kID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZSk7XG4gICAgICBjb25zdCBtYXRjaCA9IC9ebW9kdWxlXFxzKihcXFMqKVxccyokL20uZXhlYyhnb21vZC50b1N0cmluZygpKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBjaGlsZGRpciA9IHBhdGgucmVsYXRpdmUoY3VycmVudERpciwgZGlyKS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTsgLy8gcmVwbGFjZSAnXFwnIHdpdGggJy8nIGZvciB3aW5kb3dzIHBhdGhzXG4gICAgICAgIHJldHVybiBjaGlsZGRpci5sZW5ndGggPiAwID8gYCR7bWF0Y2hbMV19LyR7Y2hpbGRkaXJ9YCA6IG1hdGNoWzFdO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGRldGVybWluZSB0aGUgcm9vdCBHbyBtb2R1bGUgbmFtZS4gRm91bmQgJHtmaWxlfSBidXQgZmFpbGVkIHRvIHJlZ2V4IG1hdGNoIHRoZSBtb2R1bGUgbmFtZSBkaXJlY3RpdmVgXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBnbyB1cCBvbmUgZGlyZWN0b3J5LiBBcyBkaXJuYW1lKCcvJykgd2lsbCByZXR1cm4gJy8nIHdlIGNhbmNlbCB0aGUgbG9vcFxuICAgIC8vIGFzIHNvb24gYXMgdGhlIGRpciBkb2VzIG5vdCBjaGFuZ2UgYW55bW9yZS5cbiAgICBwcmV2aW91c0RpciA9IGN1cnJlbnREaXI7XG4gICAgY3VycmVudERpciA9IHBhdGguZGlybmFtZShjdXJyZW50RGlyKTtcbiAgfSB3aGlsZSAoY3VycmVudERpciAhPT0gcHJldmlvdXNEaXIpO1xuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgQ291bGQgbm90IGRldGVybWluZSB0aGUgcm9vdCBHbyBtb2R1bGUgbmFtZS4gTm8gZ28ubW9kIGZvdW5kIGluICR7ZGlyfSBhbmQgYW55IHBhcmVudCBkaXJlY3Rvcmllc2BcbiAgKTtcbn07XG4iXX0=