"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceParser = exports.sanitizeClassOrNamespaceName = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const codemaker_1 = require("codemaker");
const commons_1 = require("@cdktf/commons");
const provider_schema_1 = require("@cdktf/provider-schema");
const models_1 = require("./models");
const loop_detection_1 = require("./loop-detection");
const skipped_attributes_1 = require("./skipped-attributes");
// Can't be used in expressions like "export * as <keyword> from ... "
// filtered from all keywords from: https://github.com/microsoft/TypeScript/blob/503604c884bd0557c851b11b699ef98cdb65b93b/src/compiler/types.ts#L114-L197
const RESERVED_KEYWORDS_FOR_NAMESPACES = [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield",
    "await",
];
const COLLIDING_NAMESPACE_NAMES = [
    // e.g. hashicorp/consul – collides with the LICENSE file on case-insensitive filesystems in the Go package (#2627)
    "license",
    // collides for Go packages
    "version",
];
const isReservedClassOrNamespaceName = (className) => {
    return [
        "string",
        "object",
        "function",
        ...RESERVED_KEYWORDS_FOR_NAMESPACES,
        ...COLLIDING_NAMESPACE_NAMES,
    ].includes(className.toLowerCase());
};
const isReservedStructClassName = (className) => {
    return className.toLowerCase().endsWith("list");
};
const getFileName = (provider, baseName) => {
    if (baseName === "index") {
        return "index-resource/index.ts";
    }
    if (baseName === `${provider}_provider`) {
        return "provider/index.ts";
    }
    return `${(0, codemaker_1.toSnakeCase)(baseName).replace(/_/g, "-")}/index.ts`;
};
function sanitizeClassOrNamespaceName(baseName, isProvider = false) {
    const resourceIsNamedProvider = !isProvider && baseName === "provider";
    if (isReservedClassOrNamespaceName(baseName) || resourceIsNamedProvider) {
        return `${baseName}_resource`;
    }
    else {
        return baseName;
    }
}
exports.sanitizeClassOrNamespaceName = sanitizeClassOrNamespaceName;
/**
 * Remove attributes that may conflict after being snake cased
 * Example: oci_core_ipsec_connection_tunnel_management (hashicorp/oci@=5.21.0) has bgp_ipv6_state and bgp_ipv6state
 * (which both result in "bgpIpv6State" when camel-cased, with the second one being deprecated: true)
 * As we currently don't handle any deprecated ones at all, we'll just delete one of the two attributes for now
 * @param attributes
 */
function deduplicateAttributesWithSameName(attributes) {
    return attributes.filter((attr, idx) => {
        const hasOtherWithSameName = attributes
            .slice(idx + 1) // only search after the index of the current attribute to avoid deleting both
            .some((other) => other.name === attr.name && other !== attr);
        return !hasOtherWithSameName;
    });
}
class Parser {
    constructor(classNames) {
        this.classNames = classNames;
        this.structs = new Array();
    }
    uniqueClassName(className) {
        if (this.classNames.includes(className)) {
            className = `${className}A`;
        }
        this.classNames.push(className);
        return className;
    }
    resourceFrom(fqpn, type, schema, terraformSchemaType, constraint) {
        let baseName = type;
        const providerNameFromConstraint = constraint
            ? constraint.name
            : undefined;
        const providerNameFromFQPN = (0, provider_schema_1.parseFQPN)(fqpn).name;
        if (baseName.startsWith(`${providerNameFromFQPN}_`)) {
            baseName = baseName.substr(providerNameFromFQPN.length + 1);
        }
        const providerName = providerNameFromConstraint
            ? providerNameFromConstraint
            : providerNameFromFQPN;
        const isProvider = terraformSchemaType === "provider";
        if (isProvider) {
            baseName = `${providerName}_${baseName}`;
            if (!("attributes" in schema.block)) {
                schema.block = {
                    attributes: {},
                    block_types: schema.block.block_types || {},
                };
            }
            // somehow missing from provider schema
            schema.block.attributes["alias"] = {
                type: "string",
                description: "Alias name",
                optional: true,
                computed: false,
            };
        }
        baseName = sanitizeClassOrNamespaceName(baseName, isProvider);
        const className = this.uniqueClassName((0, codemaker_1.toPascalCase)(baseName));
        // avoid naming collision - see https://github.com/hashicorp/terraform-cdk/issues/299
        const configStructName = this.uniqueClassName(`${className}Config`);
        const fileName = getFileName(providerName, baseName);
        const filePath = `providers/${(0, codemaker_1.toSnakeCase)(providerName)}/${fileName}`;
        let attributes = this.renderAttributesForBlock(new models_1.Scope({
            name: baseName,
            isProvider,
            parent: isProvider
                ? undefined
                : new models_1.Scope({ name: providerName, isProvider: true }),
        }), schema.block);
        function getStructAttribute(attributes, path) {
            const [first, ...rest] = path.split(".");
            const attribute = attributes.find((att) => {
                return att.terraformName === first;
            });
            if (!attribute)
                throw new Error(`Expected to find recursive attribute at path: ${path}`);
            if (!attribute.type.struct)
                throw new Error(`Expected to find struct type attribute at path: ${path} but got ${attribute.type.storedClassType}`);
            if (rest.length === 0)
                return attribute;
            return getStructAttribute(attribute.type.struct.attributes, rest.join("."));
        }
        // Introduce recursion for some attributes
        const recursiveAttributePaths = (0, loop_detection_1.detectAttributeLoops)(attributes);
        Object.entries(recursiveAttributePaths).forEach(([attributePath, structPath]) => {
            // TODO: build this to be a bit more defensive (e.g. remove ! operator)
            const recursionTargetStructAttribute = getStructAttribute(attributes, structPath);
            const parts = attributePath.split(".");
            const attributeName = parts.pop();
            const parentAttribute = getStructAttribute(attributes, parts.join("."));
            const indexToReplace = parentAttribute.type.struct.attributes.findIndex((att) => att.terraformName === attributeName);
            if (indexToReplace === -1)
                throw new Error("Can't find attribute at path " + attributePath);
            const previousAttribute = parentAttribute.type.struct.attributes[indexToReplace];
            parentAttribute.type.struct.attributes[indexToReplace] =
                recursionTargetStructAttribute; // introduce recursion
            // ugly, pls c̶a̶l̶l̶ refactor me maybe
            // we store all structs in this.structs – now we need to dispose all structs that are part of previousAttribute
            const disposeStructs = (attr) => {
                if (attr.type.struct) {
                    attr.type.struct.attributes.forEach(disposeStructs);
                    this.structs = this.structs.filter((s) => s !== attr.type.struct);
                }
            };
            disposeStructs(previousAttribute);
        });
        attributes = deduplicateAttributesWithSameName(attributes);
        const resourceModel = new models_1.ResourceModel({
            terraformType: type,
            baseName,
            fileName,
            filePath,
            className,
            schema,
            fqpn,
            attributes,
            terraformSchemaType,
            structs: this.structs,
            configStructName,
        });
        return resourceModel;
    }
    renderAttributeType(scope, attributeType, parentKind) {
        const parent = scope[scope.length - 1];
        if ((0, skipped_attributes_1.shouldSkipAttribute)(parent.baseName)) {
            return new models_1.MapAttributeTypeModel(new models_1.SimpleAttributeTypeModel("any"));
        }
        if (typeof attributeType === "string") {
            switch (attributeType) {
                case "bool":
                    return new models_1.SimpleAttributeTypeModel("boolean");
                case "string":
                    return new models_1.SimpleAttributeTypeModel("string");
                case "number":
                    return new models_1.SimpleAttributeTypeModel("number");
                case "dynamic":
                    return new models_1.MapAttributeTypeModel(new models_1.SimpleAttributeTypeModel("any"));
                default:
                    throw new Error(`invalid primitive type ${attributeType}`);
            }
        }
        if (Array.isArray(attributeType)) {
            if (attributeType.length !== 2) {
                throw new Error(`unexpected array`);
            }
            const [kind, type] = attributeType;
            if (kind === "set" || kind === "list") {
                const elementType = this.renderAttributeType(scope, type, [kind, parentKind].join(""));
                return kind === "list"
                    ? new models_1.ListAttributeTypeModel(elementType, false, false)
                    : new models_1.SetAttributeTypeModel(elementType, false, false);
            }
            if (kind === "map") {
                const valueType = this.renderAttributeType(scope, type, [kind, parentKind].join(""));
                return new models_1.MapAttributeTypeModel(valueType);
            }
            if (kind === "object") {
                const objAttributes = type;
                const attributes = {};
                for (const [name, type] of Object.entries(objAttributes)) {
                    attributes[name] = { type };
                }
                const struct = this.addAnonymousStruct(scope, attributes, parentKind !== null && parentKind !== void 0 ? parentKind : kind);
                return new models_1.StructAttributeTypeModel(struct);
            }
        }
        if ((0, commons_1.isAttributeNestedType)(attributeType)) {
            let struct = undefined;
            let typeModel = undefined;
            switch (attributeType.nesting_mode) {
                case "list":
                    struct = this.addAnonymousStruct(scope, attributeType.attributes, attributeType.nesting_mode);
                    typeModel = new models_1.ListAttributeTypeModel(new models_1.StructAttributeTypeModel(struct), false, false);
                    break;
                case "set":
                    struct = this.addAnonymousStruct(scope, attributeType.attributes, attributeType.nesting_mode);
                    typeModel = new models_1.SetAttributeTypeModel(new models_1.StructAttributeTypeModel(struct), false, false);
                    break;
                case "map":
                    struct = this.addAnonymousStruct(scope, attributeType.attributes, attributeType.nesting_mode);
                    typeModel = new models_1.MapAttributeTypeModel(new models_1.StructAttributeTypeModel(struct));
                    break;
                case "single":
                    struct = this.addAnonymousStruct(scope, attributeType.attributes, attributeType.nesting_mode);
                    typeModel = new models_1.StructAttributeTypeModel(struct);
                    break;
                default: {
                    throw new Error(`nested_type with nesting_mode "${attributeType.nesting_mode}" not supported (attribute scope: ${scope
                        .map((s) => s.fullName)
                        .join(",")}`);
                }
            }
            return typeModel;
        }
        throw new Error(`unknown type ${JSON.stringify(attributeType)}`);
    }
    renderAttributesForBlock(parentType, block) {
        const attributes = new Array();
        for (const [terraformAttributeName, att] of Object.entries(block.attributes || {})) {
            let type;
            let forcePlainGetterType = false;
            if ((0, skipped_attributes_1.shouldSkipAttribute)(parentType.fullName(terraformAttributeName))) {
                type = new models_1.SkippedAttributeTypeModel();
                forcePlainGetterType = true;
            }
            else {
                type = this.renderAttributeType([
                    parentType,
                    new models_1.Scope({
                        name: terraformAttributeName,
                        parent: parentType,
                        isProvider: parentType.isProvider,
                        isComputed: !!att.computed,
                        isOptional: !!att.optional,
                        isRequired: !!att.required,
                        isNestedType: (0, commons_1.isNestedTypeAttribute)(att),
                    }),
                ], att.type || att.nested_type);
            }
            const name = (0, codemaker_1.toCamelCase)(terraformAttributeName);
            attributes.push(new models_1.AttributeModel({
                terraformFullName: parentType.fullName(terraformAttributeName),
                description: att.description,
                name,
                storageName: `_${name}`,
                computed: !!att.computed,
                optional: !!att.optional,
                terraformName: terraformAttributeName,
                type,
                provider: parentType.isProvider,
                required: !!att.required,
                forcePlainGetterType,
            }));
        }
        for (const [blockTypeName, blockType] of Object.entries(block.block_types || {})) {
            if ((0, skipped_attributes_1.shouldSkipAttribute)(parentType.fullName(blockTypeName))) {
                const name = (0, codemaker_1.toCamelCase)(blockTypeName);
                const parent = new models_1.Scope({
                    name: blockTypeName,
                    parent: parentType,
                    isProvider: parentType.isProvider,
                });
                attributes.push(new models_1.AttributeModel({
                    name,
                    terraformName: blockTypeName,
                    terraformFullName: parent.fullName(blockTypeName),
                    type: new models_1.SkippedAttributeTypeModel(),
                    description: `${blockTypeName} block`,
                    storageName: `_${name}`,
                    optional: true,
                    computed: false,
                    provider: parentType.isProvider,
                    required: false,
                }));
                continue;
            }
            // create a struct for this block
            let blockAttributes = this.renderAttributesForBlock(new models_1.Scope({
                name: `${parentType.name}_${blockTypeName}`,
                parent: parentType,
                isProvider: parentType.isProvider,
                inBlockType: true,
            }), blockType.block);
            blockAttributes = deduplicateAttributesWithSameName(blockAttributes);
            const blockStruct = this.addStruct([
                parentType,
                new models_1.Scope({
                    name: blockTypeName,
                    parent: parentType,
                    isProvider: parentType.isProvider,
                }),
            ], blockAttributes, blockType.nesting_mode, (blockType.nesting_mode === "list" ||
                blockType.nesting_mode === "set") &&
                blockType.max_items === 1);
            // define the attribute
            attributes.push(attributeForBlockType(blockTypeName, blockType, blockStruct, parentType.isProvider, parentType));
        }
        return attributes;
        function attributeForBlockType(terraformName, blockType, struct, isProvider, parent) {
            const name = (0, codemaker_1.toCamelCase)(terraformName);
            let optional;
            let required;
            switch (blockType.nesting_mode) {
                case "single":
                    optional = !struct.attributes.some((x) => !x.optional);
                    required = !struct.attributes.some((x) => !x.required);
                    // This is for bug #3570 as both optional and required evaluate to false under some circumstances
                    // (this then causes the computed block to not be part of assignableAttributes and thus skipped in the generated code)
                    // Hence: If both optional and required are false, set optional to true IF at least one
                    // attribute in the block has optional = true or required = true, as this would mean that at least something can be set
                    // and the block is not all computed.
                    if (!optional && !required) {
                        optional = struct.attributes.some((x) => x.optional || x.required);
                    }
                    return new models_1.AttributeModel({
                        name,
                        terraformName,
                        terraformFullName: parent.fullName(terraformName),
                        type: new models_1.StructAttributeTypeModel(struct),
                        description: `${terraformName} block`,
                        storageName: `_${name}`,
                        optional,
                        computed: false,
                        provider: isProvider,
                        required,
                    });
                case "map":
                    return new models_1.AttributeModel({
                        name,
                        terraformName,
                        terraformFullName: parent.fullName(terraformName),
                        type: new models_1.MapAttributeTypeModel(new models_1.StructAttributeTypeModel(struct)),
                        description: `${terraformName} block`,
                        storageName: `_${name}`,
                        optional: false,
                        computed: false,
                        provider: isProvider,
                        required: false,
                    });
                case "list":
                case "set":
                    optional =
                        blockType.min_items === undefined ? true : blockType.min_items < 1;
                    required =
                        blockType.min_items === undefined ? false : blockType.min_items > 0;
                    return new models_1.AttributeModel({
                        name,
                        terraformName: terraformName,
                        terraformFullName: parent.fullName(terraformName),
                        type: blockType.nesting_mode === "list"
                            ? new models_1.ListAttributeTypeModel(new models_1.StructAttributeTypeModel(struct), blockType.max_items === 1, true)
                            : new models_1.SetAttributeTypeModel(new models_1.StructAttributeTypeModel(struct), blockType.max_items === 1, true),
                        description: `${terraformName} block`,
                        storageName: `_${name}`,
                        optional,
                        computed: false,
                        provider: isProvider,
                        required,
                    });
            }
        }
    }
    addAnonymousStruct(scope, attrs, nesting_mode) {
        let attributes = new Array();
        const parent = scope[scope.length - 1];
        if (attrs) {
            for (const [terraformName, att] of Object.entries(attrs || {})) {
                // nested types support computed, optional and required on attribute level
                // if parent is computed, child always is computed as well
                const computed = !!parent.isComputed || (parent.isNestedType && !!att.computed);
                const optional = parent.isNestedType
                    ? !!att.optional
                    : !!parent.isOptional;
                const required = parent.isNestedType
                    ? !!att.required
                    : !!parent.isRequired;
                const name = (0, codemaker_1.toCamelCase)(terraformName);
                const type = this.renderAttributeType([
                    ...scope,
                    new models_1.Scope({
                        name: terraformName,
                        parent,
                        isProvider: parent.isProvider,
                        isComputed: computed,
                        isOptional: optional,
                        isRequired: required,
                        isNestedType: parent.isNestedType,
                    }),
                ], att.type || att.nested_type);
                attributes.push(new models_1.AttributeModel({
                    name,
                    storageName: `_${name}`,
                    computed: computed,
                    description: att.description,
                    optional: optional,
                    terraformName,
                    terraformFullName: parent.fullName(terraformName),
                    type,
                    provider: parent.isProvider,
                    required: required,
                }));
            }
        }
        attributes = deduplicateAttributesWithSameName(attributes);
        return this.addStruct(scope, attributes, nesting_mode);
    }
    addStruct(scope, attributes, nesting_mode, isSingleItem = false) {
        const possibleName = (0, codemaker_1.toPascalCase)(scope.map((x) => (0, codemaker_1.toSnakeCase)(x.name)).join("_"));
        const name = this.uniqueClassName(isReservedStructClassName(possibleName)
            ? `${possibleName}Struct`
            : possibleName);
        const parent = scope[scope.length - 1];
        // blockType.nesting_mode => list/set & blockType.max_items === 1,
        const isClass = (parent.isComputed && !parent.isOptional) || isSingleItem;
        const isAnonymous = true;
        const s = new models_1.Struct(name, attributes, isClass, isAnonymous, isSingleItem, nesting_mode);
        this.structs.push(s);
        return s;
    }
}
class ResourceParser {
    constructor() {
        this.uniqueClassnames = [];
        this.resources = {};
    }
    parse(fqpn, type, schema, terraformType, constraint) {
        if (this.resources[type]) {
            return this.resources[type];
        }
        const parser = new Parser(this.uniqueClassnames);
        const resource = parser.resourceFrom(fqpn, type, schema, terraformType, constraint);
        this.resources[type] = resource;
        return resource;
    }
    // Used by convert to determine the right name for a class
    getClassNameForResource(terraformType) {
        const resource = this.resources[terraformType];
        return resource ? resource.className : "";
    }
    // Used by convert to determine the right name for a namespace
    getNamespaceNameForResource(terraformType) {
        // Special case external provider since the name of resource doesn't have a prefix
        if (terraformType === "data_external_") {
            terraformType = "data_external";
        }
        const resource = this.resources[terraformType];
        if (!resource) {
            return "";
        }
        const folder = `providers/${resource.provider}`;
        return resource.filePath.replace(`${folder}/`, "").replace("/index.ts", "");
    }
}
exports.ResourceParser = ResourceParser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb3VyY2UtcGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicmVzb3VyY2UtcGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMseUNBQW1FO0FBQ25FLDRDQVV3QjtBQUN4Qiw0REFBdUU7QUFDdkUscUNBWWtCO0FBQ2xCLHFEQUF3RDtBQUN4RCw2REFBMkQ7QUFFM0Qsc0VBQXNFO0FBQ3RFLHlKQUF5SjtBQUN6SixNQUFNLGdDQUFnQyxHQUFHO0lBQ3ZDLFlBQVk7SUFDWixXQUFXO0lBQ1gsS0FBSztJQUNMLFNBQVM7SUFDVCxTQUFTO0lBQ1QsV0FBVztJQUNYLFFBQVE7SUFDUixRQUFRO0lBQ1IsT0FBTztJQUNQLE9BQU87Q0FDUixDQUFDO0FBRUYsTUFBTSx5QkFBeUIsR0FBRztJQUNoQyxtSEFBbUg7SUFDbkgsU0FBUztJQUNULDJCQUEyQjtJQUMzQixTQUFTO0NBQ1YsQ0FBQztBQUVGLE1BQU0sOEJBQThCLEdBQUcsQ0FBQyxTQUFpQixFQUFXLEVBQUU7SUFDcEUsT0FBTztRQUNMLFFBQVE7UUFDUixRQUFRO1FBQ1IsVUFBVTtRQUNWLEdBQUcsZ0NBQWdDO1FBQ25DLEdBQUcseUJBQXlCO0tBQzdCLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0FBQ3RDLENBQUMsQ0FBQztBQUVGLE1BQU0seUJBQXlCLEdBQUcsQ0FBQyxTQUFpQixFQUFXLEVBQUU7SUFDL0QsT0FBTyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2xELENBQUMsQ0FBQztBQUVGLE1BQU0sV0FBVyxHQUFHLENBQUMsUUFBc0IsRUFBRSxRQUFnQixFQUFVLEVBQUU7SUFDdkUsSUFBSSxRQUFRLEtBQUssT0FBTyxFQUFFO1FBQ3hCLE9BQU8seUJBQXlCLENBQUM7S0FDbEM7SUFFRCxJQUFJLFFBQVEsS0FBSyxHQUFH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QWtGO1FBQ2xGLElBQUksYUFBYSxLQUFLLGdCQUFnQixFQUFFO1lBQ3RDLGFBQWEsR0FBRyxlQUFlLENBQUM7U0FDakM7UUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDYixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQ0QsTUFBTSxNQUFNLEdBQUcsYUFBYSxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDaEQsT0FBTyxRQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLE1BQU0sR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDOUUsQ0FBQztDQUNGO0FBL0NELHdDQStDQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgSGFzaGlDb3JwLCBJbmNcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNUEwtMi4wXG5pbXBvcnQgeyB0b0NhbWVsQ2FzZSwgdG9QYXNjYWxDYXNlLCB0b1NuYWtlQ2FzZSB9IGZyb20gXCJjb2RlbWFrZXJcIjtcbmltcG9ydCB7XG4gIEF0dHJpYnV0ZSxcbiAgQXR0cmlidXRlTmVzdGVkVHlwZSxcbiAgQXR0cmlidXRlVHlwZSxcbiAgQmxvY2ssXG4gIEJsb2NrVHlwZSxcbiAgQ29uc3RydWN0c01ha2VyVGFyZ2V0LFxuICBpc0F0dHJpYnV0ZU5lc3RlZFR5cGUsXG4gIGlzTmVzdGVkVHlwZUF0dHJpYnV0ZSxcbiAgU2NoZW1hLFxufSBmcm9tIFwiQGNka3RmL2NvbW1vbnNcIjtcbmltcG9ydCB7IFByb3ZpZGVyTmFtZSwgRlFQTiwgcGFyc2VGUVBOIH0gZnJvbSBcIkBjZGt0Zi9wcm92aWRlci1zY2hlbWFcIjtcbmltcG9ydCB7XG4gIFJlc291cmNlTW9kZWwsXG4gIEF0dHJpYnV0ZVR5cGVNb2RlbCxcbiAgU3RydWN0LFxuICBTY29wZSxcbiAgQXR0cmlidXRlTW9kZWwsXG4gIFNpbXBsZUF0dHJpYnV0ZVR5cGVNb2RlbCxcbiAgTGlzdEF0dHJpYnV0ZVR5cGVNb2RlbCxcbiAgU2V0QXR0cmlidXRlVHlwZU1vZGVsLFxuICBNYXBBdHRyaWJ1dGVUeXBlTW9kZWwsXG4gIFN0cnVjdEF0dHJpYnV0ZVR5cGVNb2RlbCxcbiAgU2tpcHBlZEF0dHJpYnV0ZVR5cGVNb2RlbCxcbn0gZnJvbSBcIi4vbW9kZWxzXCI7XG5pbXBvcnQgeyBkZXRlY3RBdHRyaWJ1dGVMb29wcyB9IGZyb20gXCIuL2xvb3AtZGV0ZWN0aW9uXCI7XG5pbXBvcnQgeyBzaG91bGRTa2lwQXR0cmlidXRlIH0gZnJvbSBcIi4vc2tpcHBlZC1hdHRyaWJ1dGVzXCI7XG5cbi8vIENhbid0IGJlIHVzZWQgaW4gZXhwcmVzc2lvbnMgbGlrZSBcImV4cG9ydCAqIGFzIDxrZXl3b3JkPiBmcm9tIC4uLiBcIlxuLy8gZmlsdGVyZWQgZnJvbSBhbGwga2V5d29yZHMgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2Jsb2IvNTAzNjA0Yzg4NGJkMDU1N2M4NTFiMTFiNjk5ZWY5OGNkYjY1YjkzYi9zcmMvY29tcGlsZXIvdHlwZXMudHMjTDExNC1MMTk3XG5jb25zdCBSRVNFUlZFRF9LRVlXT1JEU19GT1JfTkFNRVNQQUNFUyA9IFtcbiAgXCJpbXBsZW1lbnRzXCIsXG4gIFwiaW50ZXJmYWNlXCIsXG4gIFwibGV0XCIsXG4gIFwicGFja2FnZVwiLFxuICBcInByaXZhdGVcIixcbiAgXCJwcm90ZWN0ZWRcIixcbiAgXCJwdWJsaWNcIixcbiAgXCJzdGF0aWNcIixcbiAgXCJ5aWVsZFwiLFxuICBcImF3YWl0XCIsXG5dO1xuXG5jb25zdCBDT0xMSURJTkdfTkFNRVNQQUNFX05BTUVTID0gW1xuICAvLyBlLmcuIGhhc2hpY29ycC9jb25zdWwg4oCTIGNvbGxpZGVzIHdpdGggdGhlIExJQ0VOU0UgZmlsZSBvbiBjYXNlLWluc2Vuc2l0aXZlIGZpbGVzeXN0ZW1zIGluIHRoZSBHbyBwYWNrYWdlICgjMjYyNylcbiAgXCJsaWNlbnNlXCIsXG4gIC8vIGNvbGxpZGVzIGZvciBHbyBwYWNrYWdlc1xuICBcInZlcnNpb25cIixcbl07XG5cbmNvbnN0IGlzUmVzZXJ2ZWRDbGFzc09yTmFtZXNwYWNlTmFtZSA9IChjbGFzc05hbWU6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gW1xuICAgIFwic3RyaW5nXCIsXG4gICAgXCJvYmplY3RcIixcbiAgICBcImZ1bmN0aW9uXCIsXG4gICAgLi4uUkVTRVJWRURfS0VZV09SRFNfRk9SX05BTUVTUEFDRVMsXG4gICAgLi4uQ09MTElESU5HX05BTUVTUEFDRV9OQU1FUyxcbiAgXS5pbmNsdWRlcyhjbGFzc05hbWUudG9Mb3dlckNhc2UoKSk7XG59O1xuXG5jb25zdCBpc1Jlc2VydmVkU3RydWN0Q2xhc3NOYW1lID0gKGNsYXNzTmFtZTogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiBjbGFzc05hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcImxpc3RcIik7XG59O1xuXG5jb25zdCBnZXRGaWxlTmFtZSA9IChwcm92aWRlcjogUHJvdmlkZXJOYW1lLCBiYXNlTmFtZTogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgaWYgKGJhc2VOYW1lID09PSBcImluZGV4XCIpIHtcbiAgICByZXR1cm4gXCJpbmRleC1yZXNvdXJjZS9pbmRleC50c1wiO1xuICB9XG5cbiAgaWYgKGJhc2VOYW1lID09PSBgJHtwcm92aWRlcn1fcHJvdmlkZXJgKSB7XG4gICAgcmV0dXJuIFwicHJvdmlkZXIvaW5kZXgudHNcIjtcbiAgfVxuXG4gIHJldHVybiBgJHt0b1NuYWtlQ2FzZShiYXNlTmFtZSkucmVwbGFjZSgvXy9nLCBcIi1cIil9L2luZGV4LnRzYDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzYW5pdGl6ZUNsYXNzT3JOYW1lc3BhY2VOYW1lKFxuICBiYXNlTmFtZTogc3RyaW5nLFxuICBpc1Byb3ZpZGVyID0gZmFsc2Vcbikge1xuICBjb25zdCByZXNvdXJjZUlzTmFtZWRQcm92aWRlciA9ICFpc1Byb3ZpZGVyICYmIGJhc2VOYW1lID09PSBcInByb3ZpZGVyXCI7XG5cbiAgaWYgKGlzUmVzZXJ2ZWRDbGFzc09yTmFtZXNwYWNlTmFtZShiYXNlTmFtZSkgfHwgcmVzb3VyY2VJc05hbWVkUHJvdmlkZXIpIHtcbiAgICByZXR1cm4gYCR7YmFzZU5hbWV9X3Jlc291cmNlYDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZU5hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgYXR0cmlidXRlcyB0aGF0IG1heSBjb25mbGljdCBhZnRlciBiZWluZyBzbmFrZSBjYXNlZFxuICogRXhhbXBsZTogb2NpX2NvcmVfaXBzZWNfY29ubmVjdGlvbl90dW5uZWxfbWFuYWdlbWVudCAoaGFzaGljb3JwL29jaUA9NS4yMS4wKSBoYXMgYmdwX2lwdjZfc3RhdGUgYW5kIGJncF9pcHY2c3RhdGVcbiAqICh3aGljaCBib3RoIHJlc3VsdCBpbiBcImJncElwdjZTdGF0ZVwiIHdoZW4gY2FtZWwtY2FzZWQsIHdpdGggdGhlIHNlY29uZCBvbmUgYmVpbmcgZGVwcmVjYXRlZDogdHJ1ZSlcbiAqIEFzIHdlIGN1cnJlbnRseSBkb24ndCBoYW5kbGUgYW55IGRlcHJlY2F0ZWQgb25lcyBhdCBhbGwsIHdlJ2xsIGp1c3QgZGVsZXRlIG9uZSBvZiB0aGUgdHdvIGF0dHJpYnV0ZXMgZm9yIG5vd1xuICogQHBhcmFtIGF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gZGVkdXBsaWNhdGVBdHRyaWJ1dGVzV2l0aFNhbWVOYW1lKFxuICBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVNb2RlbFtdXG4pOiBBdHRyaWJ1dGVNb2RlbFtdIHtcbiAgcmV0dXJuIGF0dHJpYnV0ZXMuZmlsdGVyKChhdHRyLCBpZHgpID0+IHtcbiAgICBjb25zdCBoYXNPdGhlcldpdGhTYW1lTmFtZSA9IGF0dHJpYnV0ZXNcbiAgICAgIC5zbGljZShpZHggKyAxKSAvLyBvbmx5IHNlYXJjaCBhZnRlciB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgYXR0cmlidXRlIHRvIGF2b2lkIGRlbGV0aW5nIGJvdGhcbiAgICAgIC5zb21lKChvdGhlcikgPT4gb3RoZXIubmFtZSA9PT0gYXR0ci5uYW1lICYmIG90aGVyICE9PSBhdHRyKTtcbiAgICByZXR1cm4gIWhhc090aGVyV2l0aFNhbWVOYW1lO1xuICB9KTtcbn1cblxuY2xhc3MgUGFyc2VyIHtcbiAgcHJpdmF0ZSBzdHJ1Y3RzID0gbmV3IEFycmF5PFN0cnVjdD4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNsYXNzTmFtZXM6IHN0cmluZ1tdKSB7fVxuXG4gIHByaXZhdGUgdW5pcXVlQ2xhc3NOYW1lKGNsYXNzTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5jbGFzc05hbWVzLmluY2x1ZGVzKGNsYXNzTmFtZSkpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGAke2NsYXNzTmFtZX1BYDtcbiAgICB9XG4gICAgdGhpcy5jbGFzc05hbWVzLnB1c2goY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG5cbiAgcHVibGljIHJlc291cmNlRnJvbShcbiAgICBmcXBuOiBGUVBOLFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBzY2hlbWE6IFNjaGVtYSxcbiAgICB0ZXJyYWZvcm1TY2hlbWFUeXBlOiBzdHJpbmcsXG4gICAgY29uc3RyYWludD86IENvbnN0cnVjdHNNYWtlclRhcmdldFxuICApOiBSZXNvdXJjZU1vZGVsIHtcbiAgICBsZXQgYmFzZU5hbWUgPSB0eXBlO1xuXG4gICAgY29uc3QgcHJvdmlkZXJOYW1lRnJvbUNvbnN0cmFpbnQgPSBjb25zdHJhaW50XG4gICAgICA/IChjb25zdHJhaW50Lm5hbWUgYXMgUHJvdmlkZXJOYW1lKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgcHJvdmlkZXJOYW1lRnJvbUZRUE4gPSBwYXJzZUZRUE4oZnFwbikubmFtZTtcblxuICAgIGlmIChiYXNlTmFtZS5zdGFydHNXaXRoKGAke3Byb3ZpZGVyTmFtZUZyb21GUVBOfV9gKSkge1xuICAgICAgYmFzZU5hbWUgPSBiYXNlTmFtZS5zdWJzdHIocHJvdmlkZXJOYW1lRnJvbUZRUE4ubGVuZ3RoICsgMSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdmlkZXJOYW1lID0gcHJvdmlkZXJOYW1lRnJvbUNvbnN0cmFpbnRcbiAgICAgID8gcHJvdmlkZXJOYW1lRnJvbUNvbnN0cmFpbnRcbiAgICAgIDogcHJvdmlkZXJOYW1lRnJvbUZRUE47XG5cbiAgICBjb25zdCBpc1Byb3ZpZGVyID0gdGVycmFmb3JtU2NoZW1hVHlwZSA9PT0gXCJwcm92aWRlclwiO1xuICAgIGlmIChpc1Byb3ZpZGVyKSB7XG4gICAgICBiYXNlTmFtZSA9IGAke3Byb3ZpZGVyTmFtZX1fJHtiYXNlTmFtZX1gO1xuICAgICAgaWYgKCEoXCJhdHRyaWJ1dGVzXCIgaW4gc2NoZW1hLmJsb2NrKSkge1xuICAgICAgICBzY2hlbWEuYmxvY2sgPSB7XG4gICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgICAgYmxvY2tfdHlwZXM6IChzY2hlbWEuYmxvY2sgYXMgQmxvY2spLmJsb2NrX3R5cGVzIHx8IHt9LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gc29tZWhvdyBtaXNzaW5nIGZyb20gcHJvdmlkZXIgc2NoZW1hXG4gICAgICBzY2hlbWEuYmxvY2suYXR0cmlidXRlc1tcImFsaWFzXCJdID0ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJBbGlhcyBuYW1lXCIsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGJhc2VOYW1lID0gc2FuaXRpemVDbGFzc09yTmFtZXNwYWNlTmFtZShiYXNlTmFtZSwgaXNQcm92aWRlcik7XG5cbiAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLnVuaXF1ZUNsYXNzTmFtZSh0b1Bhc2NhbENhc2UoYmFzZU5hbWUpKTtcbiAgICAvLyBhdm9pZCBuYW1pbmcgY29sbGlzaW9uIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9oYXNoaWNvcnAvdGVycmFmb3JtLWNkay9pc3N1ZXMvMjk5XG4gICAgY29uc3QgY29uZmlnU3RydWN0TmFtZSA9IHRoaXMudW5pcXVlQ2xhc3NOYW1lKGAke2NsYXNzTmFtZX1Db25maWdgKTtcbiAgICBjb25zdCBmaWxlTmFtZSA9IGdldEZpbGVOYW1lKHByb3ZpZGVyTmFtZSwgYmFzZU5hbWUpO1xuXG4gICAgY29uc3QgZmlsZVBhdGggPSBgcHJvdmlkZXJzLyR7dG9TbmFrZUNhc2UocHJvdmlkZXJOYW1lKX0vJHtmaWxlTmFtZX1gO1xuICAgIGxldCBhdHRyaWJ1dGVzID0gdGhpcy5yZW5kZXJBdHRyaWJ1dGVzRm9yQmxvY2soXG4gICAgICBuZXcgU2NvcGUoe1xuICAgICAgICBuYW1lOiBiYXNlTmFtZSxcbiAgICAgICAgaXNQcm92aWRlcixcbiAgICAgICAgcGFyZW50OiBpc1Byb3ZpZGVyXG4gICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICA6IG5ldyBTY29wZSh7IG5hbWU6IHByb3ZpZGVyTmFtZSwgaXNQcm92aWRlcjogdHJ1ZSB9KSxcbiAgICAgIH0pLFxuICAgICAgc2NoZW1hLmJsb2NrXG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGdldFN0cnVjdEF0dHJpYnV0ZShcbiAgICAgIGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZU1vZGVsW10sXG4gICAgICBwYXRoOiBzdHJpbmdcbiAgICApOiBBdHRyaWJ1dGVNb2RlbCB7XG4gICAgICBjb25zdCBbZmlyc3QsIC4uLnJlc3RdID0gcGF0aC5zcGxpdChcIi5cIik7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmZpbmQoKGF0dCkgPT4ge1xuICAgICAgICByZXR1cm4gYXR0LnRlcnJhZm9ybU5hbWUgPT09IGZpcnN0O1xuICAgICAgfSk7XG4gICAgICBpZiAoIWF0dHJpYnV0ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFeHBlY3RlZCB0byBmaW5kIHJlY3Vyc2l2ZSBhdHRyaWJ1dGUgYXQgcGF0aDogJHtwYXRofWBcbiAgICAgICAgKTtcbiAgICAgIGlmICghYXR0cmlidXRlLnR5cGUuc3RydWN0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIHRvIGZpbmQgc3RydWN0IHR5cGUgYXR0cmlidXRlIGF0IHBhdGg6ICR7cGF0aH0gYnV0IGdvdCAke2F0dHJpYnV0ZS50eXBlLnN0b3JlZENsYXNzVHlwZX1gXG4gICAgICAgICk7XG4gICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHJldHVybiBhdHRyaWJ1dGU7XG4gICAgICByZXR1cm4gZ2V0U3RydWN0QXR0cmlidXRlKFxuICAgICAgICBhdHRyaWJ1dGUudHlwZS5zdHJ1Y3QuYXR0cmlidXRlcyxcbiAgICAgICAgcmVzdC5qb2luKFwiLlwiKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBJbnRyb2R1Y2UgcmVjdXJzaW9uIGZvciBzb21lIGF0dHJpYnV0ZXNcbiAgICBjb25zdCByZWN1cnNpdmVBdHRyaWJ1dGVQYXRocyA9IGRldGVjdEF0dHJpYnV0ZUxvb3BzKGF0dHJpYnV0ZXMpO1xuXG4gICAgT2JqZWN0LmVudHJpZXMocmVjdXJzaXZlQXR0cmlidXRlUGF0aHMpLmZvckVhY2goXG4gICAgICAoW2F0dHJpYnV0ZVBhdGgsIHN0cnVjdFBhdGhdKSA9PiB7XG4gICAgICAgIC8vIFRPRE86IGJ1aWxkIHRoaXMgdG8gYmUgYSBiaXQgbW9yZSBkZWZlbnNpdmUgKGUuZy4gcmVtb3ZlICEgb3BlcmF0b3IpXG4gICAgICAgIGNvbnN0IHJlY3Vyc2lvblRhcmdldFN0cnVjdEF0dHJpYnV0ZSA9IGdldFN0cnVjdEF0dHJpYnV0ZShcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgIHN0cnVjdFBhdGhcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBhdHRyaWJ1dGVQYXRoLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgICAgICBjb25zdCBwYXJlbnRBdHRyaWJ1dGUgPSBnZXRTdHJ1Y3RBdHRyaWJ1dGUoYXR0cmlidXRlcywgcGFydHMuam9pbihcIi5cIikpO1xuICAgICAgICBjb25zdCBpbmRleFRvUmVwbGFjZSA9XG4gICAgICAgICAgcGFyZW50QXR0cmlidXRlLnR5cGUuc3RydWN0IS5hdHRyaWJ1dGVzLmZpbmRJbmRleChcbiAgICAgICAgICAgIChhdHQpID0+IGF0dC50ZXJyYWZvcm1OYW1lID09PSBhdHRyaWJ1dGVOYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKGluZGV4VG9SZXBsYWNlID09PSAtMSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIGF0dHJpYnV0ZSBhdCBwYXRoIFwiICsgYXR0cmlidXRlUGF0aCk7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQXR0cmlidXRlID1cbiAgICAgICAgICBwYXJlbnRBdHRyaWJ1dGUudHlwZS5zdHJ1Y3QhLmF0dHJpYnV0ZXNbaW5kZXhUb1JlcGxhY2VdO1xuXG4gICAgICAgIHBhcmVudEF0dHJpYnV0ZS50eXBlLnN0cnVjdCEuYXR0cmlidXRlc1tpbmRleFRvUmVwbGFjZV0gPVxuICAgICAgICAgIHJlY3Vyc2lvblRhcmdldFN0cnVjdEF0dHJpYnV0ZTsgLy8gaW50cm9kdWNlIHJlY3Vyc2lvblxuXG4gICAgICAgIC8vIHVnbHksIHBscyBjzLZhzLZszLZszLYgcmVmYWN0b3IgbWUgbWF5YmVcbiAgICAgICAgLy8gd2Ugc3RvcmUgYWxsIHN0cnVjdHMgaW4gdGhpcy5zdHJ1Y3RzIOKAkyBub3cgd2UgbmVlZCB0byBkaXNwb3NlIGFsbCBzdHJ1Y3RzIHRoYXQgYXJlIHBhcnQgb2YgcHJldmlvdXNBdHRyaWJ1dGVcbiAgICAgICAgY29uc3QgZGlzcG9zZVN0cnVjdHMgPSAoYXR0cjogQXR0cmlidXRlTW9kZWwpID0+IHtcbiAgICAgICAgICBpZiAoYXR0ci50eXBlLnN0cnVjdCkge1xuICAgICAgICAgICAgYXR0ci50eXBlLnN0cnVjdC5hdHRyaWJ1dGVzLmZvckVhY2goZGlzcG9zZVN0cnVjdHMpO1xuICAgICAgICAgICAgdGhpcy5zdHJ1Y3RzID0gdGhpcy5zdHJ1Y3RzLmZpbHRlcigocykgPT4gcyAhPT0gYXR0ci50eXBlLnN0cnVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGRpc3Bvc2VTdHJ1Y3RzKHByZXZpb3VzQXR0cmlidXRlKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgYXR0cmlidXRlcyA9IGRlZHVwbGljYXRlQXR0cmlidXRlc1dpdGhTYW1lTmFtZShhdHRyaWJ1dGVzKTtcblxuICAgIGNvbnN0IHJlc291cmNlTW9kZWwgPSBuZXcgUmVzb3VyY2VNb2RlbCh7XG4gICAgICB0ZXJyYWZvcm1UeXBlOiB0eXBlLFxuICAgICAgYmFzZU5hbWUsXG4gICAgICBmaWxlTmFtZSxcbiAgICAgIGZpbGVQYXRoLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgc2NoZW1hLFxuICAgICAgZnFwbixcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICB0ZXJyYWZvcm1TY2hlbWFUeXBlLFxuICAgICAgc3RydWN0czogdGhpcy5zdHJ1Y3RzLFxuICAgICAgY29uZmlnU3RydWN0TmFtZSxcbiAgICB9KTtcblxuICAgIHJldHVybiByZXNvdXJjZU1vZGVsO1xuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJBdHRyaWJ1dGVUeXBlKFxuICAgIHNjb3BlOiBTY29wZVtdLFxuICAgIGF0dHJpYnV0ZVR5cGU6IEF0dHJpYnV0ZVR5cGUgfCBBdHRyaWJ1dGVOZXN0ZWRUeXBlLFxuICAgIHBhcmVudEtpbmQ/OiBzdHJpbmdcbiAgKTogQXR0cmlidXRlVHlwZU1vZGVsIHtcbiAgICBjb25zdCBwYXJlbnQgPSBzY29wZVtzY29wZS5sZW5ndGggLSAxXTtcbiAgICBpZiAoc2hvdWxkU2tpcEF0dHJpYnV0ZShwYXJlbnQuYmFzZU5hbWUpKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcEF0dHJpYnV0ZVR5cGVNb2RlbChuZXcgU2ltcGxlQXR0cmlidXRlVHlwZU1vZGVsKFwiYW55XCIpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZVR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN3aXRjaCAoYXR0cmlidXRlVHlwZSkge1xuICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgIHJldHVybiBuZXcgU2ltcGxlQXR0cmlidXRlVHlwZU1vZGVsKFwiYm9vbGVhblwiKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiBuZXcgU2ltcGxlQXR0cmlidXRlVHlwZU1vZGVsKFwic3RyaW5nXCIpO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVBdHRyaWJ1dGVUeXBlTW9kZWwoXCJudW1iZXJcIik7XG4gICAgICAgIGNhc2UgXCJkeW5hbWljXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBNYXBBdHRyaWJ1dGVUeXBlTW9kZWwobmV3IFNpbXBsZUF0dHJpYnV0ZVR5cGVNb2RlbChcImFueVwiKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHByaW1pdGl2ZSB0eXBlICR7YXR0cmlidXRlVHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyaWJ1dGVUeXBlKSkge1xuICAgICAgaWYgKGF0dHJpYnV0ZVR5cGUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBhcnJheWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBba2luZCwgdHlwZV0gPSBhdHRyaWJ1dGVUeXBlO1xuXG4gICAgICBpZiAoa2luZCA9PT0gXCJzZXRcIiB8fCBraW5kID09PSBcImxpc3RcIikge1xuICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9IHRoaXMucmVuZGVyQXR0cmlidXRlVHlwZShcbiAgICAgICAgICBzY29wZSxcbiAgICAgICAgICB0eXBlIGFzIEF0dHJpYnV0ZVR5cGUsXG4gICAgICAgICAgW2tpbmQsIHBhcmVudEtpbmRdLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwibGlzdFwiXG4gICAgICAgICAgPyBuZXcgTGlzdEF0dHJpYnV0ZVR5cGVNb2RlbChlbGVtZW50VHlwZSwgZmFsc2UsIGZhbHNlKVxuICAgICAgICAgIDogbmV3IFNldEF0dHJpYnV0ZVR5cGVNb2RlbChlbGVtZW50VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtpbmQgPT09IFwibWFwXCIpIHtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5yZW5kZXJBdHRyaWJ1dGVUeXBlKFxuICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgIHR5cGUgYXMgQXR0cmlidXRlVHlwZSxcbiAgICAgICAgICBba2luZCwgcGFyZW50S2luZF0uam9pbihcIlwiKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3IE1hcEF0dHJpYnV0ZVR5cGVNb2RlbCh2YWx1ZVR5cGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2luZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCBvYmpBdHRyaWJ1dGVzID0gdHlwZSBhcyB7IFtuYW1lOiBzdHJpbmddOiBBdHRyaWJ1dGVUeXBlIH07XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXM6IHsgW25hbWU6IHN0cmluZ106IEF0dHJpYnV0ZSB9ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9iakF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IHsgdHlwZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IHRoaXMuYWRkQW5vbnltb3VzU3RydWN0KFxuICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgcGFyZW50S2luZCA/PyBraW5kXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBuZXcgU3RydWN0QXR0cmlidXRlVHlwZU1vZGVsKHN0cnVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQXR0cmlidXRlTmVzdGVkVHlwZShhdHRyaWJ1dGVUeXBlKSkge1xuICAgICAgbGV0IHN0cnVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIGxldCB0eXBlTW9kZWwgPSB1bmRlZmluZWQ7XG4gICAgICBzd2l0Y2ggKGF0dHJpYnV0ZVR5cGUubmVzdGluZ19tb2RlKSB7XG4gICAgICAgIGNhc2UgXCJsaXN0XCI6XG4gICAgICAgICAgc3RydWN0ID0gdGhpcy5hZGRBbm9ueW1vdXNTdHJ1Y3QoXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZVR5cGUuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZVR5cGUubmVzdGluZ19tb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0eXBlTW9kZWwgPSBuZXcgTGlzdEF0dHJpYnV0ZVR5cGVNb2RlbChcbiAgICAgICAgICAgIG5ldyBTdHJ1Y3RBdHRyaWJ1dGVUeXBlTW9kZWwoc3RydWN0KSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2V0XCI6XG4gICAgICAgICAgc3RydWN0ID0gdGhpcy5hZGRBbm9ueW1vdXNTdHJ1Y3QoXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZVR5cGUuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZVR5cGUubmVzdGluZ19tb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0eXBlTW9kZWwgPSBuZXcgU2V0QXR0cmlidXRlVHlwZU1vZGVsKFxuICAgICAgICAgICAgbmV3IFN0cnVjdEF0dHJpYnV0ZVR5cGVNb2RlbChzdHJ1Y3QpLFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICBzdHJ1Y3QgPSB0aGlzLmFkZEFub255bW91c1N0cnVjdChcbiAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgYXR0cmlidXRlVHlwZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgYXR0cmlidXRlVHlwZS5uZXN0aW5nX21vZGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHR5cGVNb2RlbCA9IG5ldyBNYXBBdHRyaWJ1dGVUeXBlTW9kZWwoXG4gICAgICAgICAgICBuZXcgU3RydWN0QXR0cmlidXRlVHlwZU1vZGVsKHN0cnVjdClcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICAgICAgc3RydWN0ID0gdGhpcy5hZGRBbm9ueW1vdXNTdHJ1Y3QoXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZVR5cGUuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZVR5cGUubmVzdGluZ19tb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0eXBlTW9kZWwgPSBuZXcgU3RydWN0QXR0cmlidXRlVHlwZU1vZGVsKHN0cnVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgbmVzdGVkX3R5cGUgd2l0aCBuZXN0aW5nX21vZGUgXCIke1xuICAgICAgICAgICAgICBhdHRyaWJ1dGVUeXBlLm5lc3RpbmdfbW9kZVxuICAgICAgICAgICAgfVwiIG5vdCBzdXBwb3J0ZWQgKGF0dHJpYnV0ZSBzY29wZTogJHtzY29wZVxuICAgICAgICAgICAgICAubWFwKChzKSA9PiBzLmZ1bGxOYW1lKVxuICAgICAgICAgICAgICAuam9pbihcIixcIil9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlTW9kZWw7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGUgJHtKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGVUeXBlKX1gKTtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXJBdHRyaWJ1dGVzRm9yQmxvY2socGFyZW50VHlwZTogU2NvcGUsIGJsb2NrOiBCbG9jaykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgQXJyYXk8QXR0cmlidXRlTW9kZWw+KCk7XG5cbiAgICBmb3IgKGNvbnN0IFt0ZXJyYWZvcm1BdHRyaWJ1dGVOYW1lLCBhdHRdIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgYmxvY2suYXR0cmlidXRlcyB8fCB7fVxuICAgICkpIHtcbiAgICAgIGxldCB0eXBlOiBBdHRyaWJ1dGVUeXBlTW9kZWw7XG4gICAgICBsZXQgZm9yY2VQbGFpbkdldHRlclR5cGUgPSBmYWxzZTtcbiAgICAgIGlmIChzaG91bGRTa2lwQXR0cmlidXRlKHBhcmVudFR5cGUuZnVsbE5hbWUodGVycmFmb3JtQXR0cmlidXRlTmFtZSkpKSB7XG4gICAgICAgIHR5cGUgPSBuZXcgU2tpcHBlZEF0dHJpYnV0ZVR5cGVNb2RlbCgpO1xuICAgICAgICBmb3JjZVBsYWluR2V0dGVyVHlwZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gdGhpcy5yZW5kZXJBdHRyaWJ1dGVUeXBlKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHBhcmVudFR5cGUsXG4gICAgICAgICAgICBuZXcgU2NvcGUoe1xuICAgICAgICAgICAgICBuYW1lOiB0ZXJyYWZvcm1BdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgICBwYXJlbnQ6IHBhcmVudFR5cGUsXG4gICAgICAgICAgICAgIGlzUHJvdmlkZXI6IHBhcmVudFR5cGUuaXNQcm92aWRlcixcbiAgICAgICAgICAgICAgaXNDb21wdXRlZDogISFhdHQuY29tcHV0ZWQsXG4gICAgICAgICAgICAgIGlzT3B0aW9uYWw6ICEhYXR0Lm9wdGlvbmFsLFxuICAgICAgICAgICAgICBpc1JlcXVpcmVkOiAhIWF0dC5yZXF1aXJlZCxcbiAgICAgICAgICAgICAgaXNOZXN0ZWRUeXBlOiBpc05lc3RlZFR5cGVBdHRyaWJ1dGUoYXR0KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgYXR0LnR5cGUgfHwgYXR0Lm5lc3RlZF90eXBlXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5hbWUgPSB0b0NhbWVsQ2FzZSh0ZXJyYWZvcm1BdHRyaWJ1dGVOYW1lKTtcblxuICAgICAgYXR0cmlidXRlcy5wdXNoKFxuICAgICAgICBuZXcgQXR0cmlidXRlTW9kZWwoe1xuICAgICAgICAgIHRlcnJhZm9ybUZ1bGxOYW1lOiBwYXJlbnRUeXBlLmZ1bGxOYW1lKHRlcnJhZm9ybUF0dHJpYnV0ZU5hbWUpLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBhdHQuZGVzY3JpcHRpb24sXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBzdG9yYWdlTmFtZTogYF8ke25hbWV9YCxcbiAgICAgICAgICBjb21wdXRlZDogISFhdHQuY29tcHV0ZWQsXG4gICAgICAgICAgb3B0aW9uYWw6ICEhYXR0Lm9wdGlvbmFsLFxuICAgICAgICAgIHRlcnJhZm9ybU5hbWU6IHRlcnJhZm9ybUF0dHJpYnV0ZU5hbWUsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBwcm92aWRlcjogcGFyZW50VHlwZS5pc1Byb3ZpZGVyLFxuICAgICAgICAgIHJlcXVpcmVkOiAhIWF0dC5yZXF1aXJlZCxcbiAgICAgICAgICBmb3JjZVBsYWluR2V0dGVyVHlwZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbYmxvY2tUeXBlTmFtZSwgYmxvY2tUeXBlXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgIGJsb2NrLmJsb2NrX3R5cGVzIHx8IHt9XG4gICAgKSkge1xuICAgICAgaWYgKHNob3VsZFNraXBBdHRyaWJ1dGUocGFyZW50VHlwZS5mdWxsTmFtZShibG9ja1R5cGVOYW1lKSkpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRvQ2FtZWxDYXNlKGJsb2NrVHlwZU5hbWUpO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBuZXcgU2NvcGUoe1xuICAgICAgICAgIG5hbWU6IGJsb2NrVHlwZU5hbWUsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnRUeXBlLFxuICAgICAgICAgIGlzUHJvdmlkZXI6IHBhcmVudFR5cGUuaXNQcm92aWRlcixcbiAgICAgICAgfSk7XG4gICAgICAgIGF0dHJpYnV0ZXMucHVzaChcbiAgICAgICAgICBuZXcgQXR0cmlidXRlTW9kZWwoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHRlcnJhZm9ybU5hbWU6IGJsb2NrVHlwZU5hbWUsXG4gICAgICAgICAgICB0ZXJyYWZvcm1GdWxsTmFtZTogcGFyZW50LmZ1bGxOYW1lKGJsb2NrVHlwZU5hbWUpLFxuICAgICAgICAgICAgdHlwZTogbmV3IFNraXBwZWRBdHRyaWJ1dGVUeXBlTW9kZWwoKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtibG9ja1R5cGVOYW1lfSBibG9ja2AsXG4gICAgICAgICAgICBzdG9yYWdlTmFtZTogYF8ke25hbWV9YCxcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHBhcmVudFR5cGUuaXNQcm92aWRlcixcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGNyZWF0ZSBhIHN0cnVjdCBmb3IgdGhpcyBibG9ja1xuICAgICAgbGV0IGJsb2NrQXR0cmlidXRlcyA9IHRoaXMucmVuZGVyQXR0cmlidXRlc0ZvckJsb2NrKFxuICAgICAgICBuZXcgU2NvcGUoe1xuICAgICAgICAgIG5hbWU6IGAke3BhcmVudFR5cGUubmFtZX1fJHtibG9ja1R5cGVOYW1lfWAsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnRUeXBlLFxuICAgICAgICAgIGlzUHJvdmlkZXI6IHBhcmVudFR5cGUuaXNQcm92aWRlcixcbiAgICAgICAgICBpbkJsb2NrVHlwZTogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIGJsb2NrVHlwZS5ibG9ja1xuICAgICAgKTtcblxuICAgICAgYmxvY2tBdHRyaWJ1dGVzID0gZGVkdXBsaWNhdGVBdHRyaWJ1dGVzV2l0aFNhbWVOYW1lKGJsb2NrQXR0cmlidXRlcyk7XG5cbiAgICAgIGNvbnN0IGJsb2NrU3RydWN0ID0gdGhpcy5hZGRTdHJ1Y3QoXG4gICAgICAgIFtcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIG5ldyBTY29wZSh7XG4gICAgICAgICAgICBuYW1lOiBibG9ja1R5cGVOYW1lLFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRUeXBlLFxuICAgICAgICAgICAgaXNQcm92aWRlcjogcGFyZW50VHlwZS5pc1Byb3ZpZGVyLFxuICAgICAgICAgIH0pLFxuICAgICAgICBdLFxuICAgICAgICBibG9ja0F0dHJpYnV0ZXMsXG4gICAgICAgIGJsb2NrVHlwZS5uZXN0aW5nX21vZGUsXG4gICAgICAgIChibG9ja1R5cGUubmVzdGluZ19tb2RlID09PSBcImxpc3RcIiB8fFxuICAgICAgICAgIGJsb2NrVHlwZS5uZXN0aW5nX21vZGUgPT09IFwic2V0XCIpICYmXG4gICAgICAgICAgYmxvY2tUeXBlLm1heF9pdGVtcyA9PT0gMVxuICAgICAgKTtcblxuICAgICAgLy8gZGVmaW5lIHRoZSBhdHRyaWJ1dGVcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChcbiAgICAgICAgYXR0cmlidXRlRm9yQmxvY2tUeXBlKFxuICAgICAgICAgIGJsb2NrVHlwZU5hbWUsXG4gICAgICAgICAgYmxvY2tUeXBlLFxuICAgICAgICAgIGJsb2NrU3RydWN0LFxuICAgICAgICAgIHBhcmVudFR5cGUuaXNQcm92aWRlcixcbiAgICAgICAgICBwYXJlbnRUeXBlXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG5cbiAgICBmdW5jdGlvbiBhdHRyaWJ1dGVGb3JCbG9ja1R5cGUoXG4gICAgICB0ZXJyYWZvcm1OYW1lOiBzdHJpbmcsXG4gICAgICBibG9ja1R5cGU6IEJsb2NrVHlwZSxcbiAgICAgIHN0cnVjdDogU3RydWN0LFxuICAgICAgaXNQcm92aWRlcjogYm9vbGVhbixcbiAgICAgIHBhcmVudDogU2NvcGVcbiAgICApOiBBdHRyaWJ1dGVNb2RlbCB7XG4gICAgICBjb25zdCBuYW1lID0gdG9DYW1lbENhc2UodGVycmFmb3JtTmFtZSk7XG4gICAgICBsZXQgb3B0aW9uYWw6IGJvb2xlYW47XG4gICAgICBsZXQgcmVxdWlyZWQ6IGJvb2xlYW47XG5cbiAgICAgIHN3aXRjaCAoYmxvY2tUeXBlLm5lc3RpbmdfbW9kZSkge1xuICAgICAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICAgICAgb3B0aW9uYWwgPSAhc3RydWN0LmF0dHJpYnV0ZXMuc29tZSgoeCkgPT4gIXgub3B0aW9uYWwpO1xuICAgICAgICAgIHJlcXVpcmVkID0gIXN0cnVjdC5hdHRyaWJ1dGVzLnNvbWUoKHgpID0+ICF4LnJlcXVpcmVkKTtcblxuICAgICAgICAgIC8vIFRoaXMgaXMgZm9yIGJ1ZyAjMzU3MCBhcyBib3RoIG9wdGlvbmFsIGFuZCByZXF1aXJlZCBldmFsdWF0ZSB0byBmYWxzZSB1bmRlciBzb21lIGNpcmN1bXN0YW5jZXNcbiAgICAgICAgICAvLyAodGhpcyB0aGVuIGNhdXNlcyB0aGUgY29tcHV0ZWQgYmxvY2sgdG8gbm90IGJlIHBhcnQgb2YgYXNzaWduYWJsZUF0dHJpYnV0ZXMgYW5kIHRodXMgc2tpcHBlZCBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUpXG4gICAgICAgICAgLy8gSGVuY2U6IElmIGJvdGggb3B0aW9uYWwgYW5kIHJlcXVpcmVkIGFyZSBmYWxzZSwgc2V0IG9wdGlvbmFsIHRvIHRydWUgSUYgYXQgbGVhc3Qgb25lXG4gICAgICAgICAgLy8gYXR0cmlidXRlIGluIHRoZSBibG9jayBoYXMgb3B0aW9uYWwgPSB0cnVlIG9yIHJlcXVpcmVkID0gdHJ1ZSwgYXMgdGhpcyB3b3VsZCBtZWFuIHRoYXQgYXQgbGVhc3Qgc29tZXRoaW5nIGNhbiBiZSBzZXRcbiAgICAgICAgICAvLyBhbmQgdGhlIGJsb2NrIGlzIG5vdCBhbGwgY29tcHV0ZWQuXG4gICAgICAgICAgaWYgKCFvcHRpb25hbCAmJiAhcmVxdWlyZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsID0gc3RydWN0LmF0dHJpYnV0ZXMuc29tZSgoeCkgPT4geC5vcHRpb25hbCB8fCB4LnJlcXVpcmVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZU1vZGVsKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0ZXJyYWZvcm1OYW1lLFxuICAgICAgICAgICAgdGVycmFmb3JtRnVsbE5hbWU6IHBhcmVudC5mdWxsTmFtZSh0ZXJyYWZvcm1OYW1lKSxcbiAgICAgICAgICAgIHR5cGU6IG5ldyBTdHJ1Y3RBdHRyaWJ1dGVUeXBlTW9kZWwoc3RydWN0KSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHt0ZXJyYWZvcm1OYW1lfSBibG9ja2AsXG4gICAgICAgICAgICBzdG9yYWdlTmFtZTogYF8ke25hbWV9YCxcbiAgICAgICAgICAgIG9wdGlvbmFsLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvdmlkZXI6IGlzUHJvdmlkZXIsXG4gICAgICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVNb2RlbCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdGVycmFmb3JtTmFtZSxcbiAgICAgICAgICAgIHRlcnJhZm9ybUZ1bGxOYW1lOiBwYXJlbnQuZnVsbE5hbWUodGVycmFmb3JtTmFtZSksXG4gICAgICAgICAgICB0eXBlOiBuZXcgTWFwQXR0cmlidXRlVHlwZU1vZGVsKFxuICAgICAgICAgICAgICBuZXcgU3RydWN0QXR0cmlidXRlVHlwZU1vZGVsKHN0cnVjdClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7dGVycmFmb3JtTmFtZX0gYmxvY2tgLFxuICAgICAgICAgICAgc3RvcmFnZU5hbWU6IGBfJHtuYW1lfWAsXG4gICAgICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICBwcm92aWRlcjogaXNQcm92aWRlcixcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjYXNlIFwibGlzdFwiOlxuICAgICAgICBjYXNlIFwic2V0XCI6XG4gICAgICAgICAgb3B0aW9uYWwgPVxuICAgICAgICAgICAgYmxvY2tUeXBlLm1pbl9pdGVtcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGJsb2NrVHlwZS5taW5faXRlbXMgPCAxO1xuICAgICAgICAgIHJlcXVpcmVkID1cbiAgICAgICAgICAgIGJsb2NrVHlwZS5taW5faXRlbXMgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYmxvY2tUeXBlLm1pbl9pdGVtcyA+IDA7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVNb2RlbCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdGVycmFmb3JtTmFtZTogdGVycmFmb3JtTmFtZSxcbiAgICAgICAgICAgIHRlcnJhZm9ybUZ1bGxOYW1lOiBwYXJlbnQuZnVsbE5hbWUodGVycmFmb3JtTmFtZSksXG4gICAgICAgICAgICB0eXBlOlxuICAgICAgICAgICAgICBibG9ja1R5cGUubmVzdGluZ19tb2RlID09PSBcImxpc3RcIlxuICAgICAgICAgICAgICAgID8gbmV3IExpc3RBdHRyaWJ1dGVUeXBlTW9kZWwoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTdHJ1Y3RBdHRyaWJ1dGVUeXBlTW9kZWwoc3RydWN0KSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tUeXBlLm1heF9pdGVtcyA9PT0gMSxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogbmV3IFNldEF0dHJpYnV0ZVR5cGVNb2RlbChcbiAgICAgICAgICAgICAgICAgICAgbmV3IFN0cnVjdEF0dHJpYnV0ZVR5cGVNb2RlbChzdHJ1Y3QpLFxuICAgICAgICAgICAgICAgICAgICBibG9ja1R5cGUubWF4X2l0ZW1zID09PSAxLFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGAke3RlcnJhZm9ybU5hbWV9IGJsb2NrYCxcbiAgICAgICAgICAgIHN0b3JhZ2VOYW1lOiBgXyR7bmFtZX1gLFxuICAgICAgICAgICAgb3B0aW9uYWwsXG4gICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICBwcm92aWRlcjogaXNQcm92aWRlcixcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwcml2YXRlIGFkZEFub255bW91c1N0cnVjdChcbiAgICBzY29wZTogU2NvcGVbXSxcbiAgICBhdHRyczogeyBbbmFtZTogc3RyaW5nXTogQXR0cmlidXRlIH0gfCB1bmRlZmluZWQsXG4gICAgbmVzdGluZ19tb2RlOiBzdHJpbmdcbiAgKSB7XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBuZXcgQXJyYXk8QXR0cmlidXRlTW9kZWw+KCk7XG4gICAgY29uc3QgcGFyZW50ID0gc2NvcGVbc2NvcGUubGVuZ3RoIC0gMV07XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICBmb3IgKGNvbnN0IFt0ZXJyYWZvcm1OYW1lLCBhdHRdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJzIHx8IHt9KSkge1xuICAgICAgICAvLyBuZXN0ZWQgdHlwZXMgc3VwcG9ydCBjb21wdXRlZCwgb3B0aW9uYWwgYW5kIHJlcXVpcmVkIG9uIGF0dHJpYnV0ZSBsZXZlbFxuICAgICAgICAvLyBpZiBwYXJlbnQgaXMgY29tcHV0ZWQsIGNoaWxkIGFsd2F5cyBpcyBjb21wdXRlZCBhcyB3ZWxsXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID1cbiAgICAgICAgICAhIXBhcmVudC5pc0NvbXB1dGVkIHx8IChwYXJlbnQuaXNOZXN0ZWRUeXBlICYmICEhYXR0LmNvbXB1dGVkKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWwgPSBwYXJlbnQuaXNOZXN0ZWRUeXBlXG4gICAgICAgICAgPyAhIWF0dC5vcHRpb25hbFxuICAgICAgICAgIDogISFwYXJlbnQuaXNPcHRpb25hbDtcbiAgICAgICAgY29uc3QgcmVxdWlyZWQgPSBwYXJlbnQuaXNOZXN0ZWRUeXBlXG4gICAgICAgICAgPyAhIWF0dC5yZXF1aXJlZFxuICAgICAgICAgIDogISFwYXJlbnQuaXNSZXF1aXJlZDtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRvQ2FtZWxDYXNlKHRlcnJhZm9ybU5hbWUpO1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5yZW5kZXJBdHRyaWJ1dGVUeXBlKFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIC4uLnNjb3BlLFxuICAgICAgICAgICAgbmV3IFNjb3BlKHtcbiAgICAgICAgICAgICAgbmFtZTogdGVycmFmb3JtTmFtZSxcbiAgICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgICBpc1Byb3ZpZGVyOiBwYXJlbnQuaXNQcm92aWRlcixcbiAgICAgICAgICAgICAgaXNDb21wdXRlZDogY29tcHV0ZWQsXG4gICAgICAgICAgICAgIGlzT3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgICAgICAgICBpc1JlcXVpcmVkOiByZXF1aXJlZCxcbiAgICAgICAgICAgICAgaXNOZXN0ZWRUeXBlOiBwYXJlbnQuaXNOZXN0ZWRUeXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgXSxcbiAgICAgICAgICBhdHQudHlwZSB8fCBhdHQubmVzdGVkX3R5cGVcbiAgICAgICAgKTtcbiAgICAgICAgYXR0cmlidXRlcy5wdXNoKFxuICAgICAgICAgIG5ldyBBdHRyaWJ1dGVNb2RlbCh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgc3RvcmFnZU5hbWU6IGBfJHtuYW1lfWAsXG4gICAgICAgICAgICBjb21wdXRlZDogY29tcHV0ZWQsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYXR0LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgICAgICAgdGVycmFmb3JtTmFtZSxcbiAgICAgICAgICAgIHRlcnJhZm9ybUZ1bGxOYW1lOiBwYXJlbnQuZnVsbE5hbWUodGVycmFmb3JtTmFtZSksXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHBhcmVudC5pc1Byb3ZpZGVyLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cmlidXRlcyA9IGRlZHVwbGljYXRlQXR0cmlidXRlc1dpdGhTYW1lTmFtZShhdHRyaWJ1dGVzKTtcblxuICAgIHJldHVybiB0aGlzLmFkZFN0cnVjdChzY29wZSwgYXR0cmlidXRlcywgbmVzdGluZ19tb2RlKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkU3RydWN0KFxuICAgIHNjb3BlOiBTY29wZVtdLFxuICAgIGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZU1vZGVsW10sXG4gICAgbmVzdGluZ19tb2RlOiBzdHJpbmcsXG4gICAgaXNTaW5nbGVJdGVtID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3QgcG9zc2libGVOYW1lID0gdG9QYXNjYWxDYXNlKFxuICAgICAgc2NvcGUubWFwKCh4KSA9PiB0b1NuYWtlQ2FzZSh4Lm5hbWUpKS5qb2luKFwiX1wiKVxuICAgICk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMudW5pcXVlQ2xhc3NOYW1lKFxuICAgICAgaXNSZXNlcnZlZFN0cnVjdENsYXNzTmFtZShwb3NzaWJsZU5hbWUpXG4gICAgICAgID8gYCR7cG9zc2libGVOYW1lfVN0cnVjdGBcbiAgICAgICAgOiBwb3NzaWJsZU5hbWVcbiAgICApO1xuXG4gICAgY29uc3QgcGFyZW50ID0gc2NvcGVbc2NvcGUubGVuZ3RoIC0gMV07XG4gICAgLy8gYmxvY2tUeXBlLm5lc3RpbmdfbW9kZSA9PiBsaXN0L3NldCAmIGJsb2NrVHlwZS5tYXhfaXRlbXMgPT09IDEsXG4gICAgY29uc3QgaXNDbGFzcyA9IChwYXJlbnQuaXNDb21wdXRlZCAmJiAhcGFyZW50LmlzT3B0aW9uYWwpIHx8IGlzU2luZ2xlSXRlbTtcbiAgICBjb25zdCBpc0Fub255bW91cyA9IHRydWU7XG4gICAgY29uc3QgcyA9IG5ldyBTdHJ1Y3QoXG4gICAgICBuYW1lLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGlzQ2xhc3MsXG4gICAgICBpc0Fub255bW91cyxcbiAgICAgIGlzU2luZ2xlSXRlbSxcbiAgICAgIG5lc3RpbmdfbW9kZVxuICAgICk7XG4gICAgdGhpcy5zdHJ1Y3RzLnB1c2gocyk7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlc291cmNlUGFyc2VyIHtcbiAgcHJpdmF0ZSB1bmlxdWVDbGFzc25hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICBwcml2YXRlIHJlc291cmNlczogUmVjb3JkPHN0cmluZywgUmVzb3VyY2VNb2RlbD4gPSB7fTtcblxuICBwdWJsaWMgcGFyc2UoXG4gICAgZnFwbjogRlFQTixcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgc2NoZW1hOiBTY2hlbWEsXG4gICAgdGVycmFmb3JtVHlwZTogc3RyaW5nLFxuICAgIGNvbnN0cmFpbnQ/OiBDb25zdHJ1Y3RzTWFrZXJUYXJnZXRcbiAgKTogUmVzb3VyY2VNb2RlbCB7XG4gICAgaWYgKHRoaXMucmVzb3VyY2VzW3R5cGVdKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXNbdHlwZV07XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcih0aGlzLnVuaXF1ZUNsYXNzbmFtZXMpO1xuICAgIGNvbnN0IHJlc291cmNlID0gcGFyc2VyLnJlc291cmNlRnJvbShcbiAgICAgIGZxcG4sXG4gICAgICB0eXBlLFxuICAgICAgc2NoZW1hLFxuICAgICAgdGVycmFmb3JtVHlwZSxcbiAgICAgIGNvbnN0cmFpbnRcbiAgICApO1xuICAgIHRoaXMucmVzb3VyY2VzW3R5cGVdID0gcmVzb3VyY2U7XG4gICAgcmV0dXJuIHJlc291cmNlO1xuICB9XG5cbiAgLy8gVXNlZCBieSBjb252ZXJ0IHRvIGRldGVybWluZSB0aGUgcmlnaHQgbmFtZSBmb3IgYSBjbGFzc1xuICBwdWJsaWMgZ2V0Q2xhc3NOYW1lRm9yUmVzb3VyY2UodGVycmFmb3JtVHlwZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSB0aGlzLnJlc291cmNlc1t0ZXJyYWZvcm1UeXBlXTtcbiAgICByZXR1cm4gcmVzb3VyY2UgPyByZXNvdXJjZS5jbGFzc05hbWUgOiBcIlwiO1xuICB9XG5cbiAgLy8gVXNlZCBieSBjb252ZXJ0IHRvIGRldGVybWluZSB0aGUgcmlnaHQgbmFtZSBmb3IgYSBuYW1lc3BhY2VcbiAgcHVibGljIGdldE5hbWVzcGFjZU5hbWVGb3JSZXNvdXJjZSh0ZXJyYWZvcm1UeXBlOiBzdHJpbmcpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UgZXh0ZXJuYWwgcHJvdmlkZXIgc2luY2UgdGhlIG5hbWUgb2YgcmVzb3VyY2UgZG9lc24ndCBoYXZlIGEgcHJlZml4XG4gICAgaWYgKHRlcnJhZm9ybVR5cGUgPT09IFwiZGF0YV9leHRlcm5hbF9cIikge1xuICAgICAgdGVycmFmb3JtVHlwZSA9IFwiZGF0YV9leHRlcm5hbFwiO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5yZXNvdXJjZXNbdGVycmFmb3JtVHlwZV07XG4gICAgaWYgKCFyZXNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IGZvbGRlciA9IGBwcm92aWRlcnMvJHtyZXNvdXJjZS5wcm92aWRlcn1gO1xuICAgIHJldHVybiByZXNvdXJjZS5maWxlUGF0aC5yZXBsYWNlKGAke2ZvbGRlcn0vYCwgXCJcIikucmVwbGFjZShcIi9pbmRleC50c1wiLCBcIlwiKTtcbiAgfVxufVxuIl19