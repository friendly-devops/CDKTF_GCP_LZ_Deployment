"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const glob_1 = require("glob");
const commons_1 = require("@cdktf/commons");
const constructs_maker_1 = require("../get/constructs-maker");
const commons_2 = require("@cdktf/commons");
function directorySnapshot(root) {
    const output = {};
    const files = glob_1.glob.sync("**", {
        ignore: [".git/**", ".jsii"],
        cwd: root,
        nodir: true,
        dot: true,
    });
    for (const file of files) {
        const filePath = path.join(root, file);
        let content;
        if (path.extname(filePath) === ".json") {
            content = fs.readJsonSync(filePath);
            if (path.basename(filePath) === "constraints.json") {
                delete content.cdktf;
            }
        }
        else {
            content = fs.readFileSync(filePath, "utf-8");
        }
        output[file] = content;
    }
    return output;
}
function resourceTypesPresentInSnapshot(snapshot, providerNameInPath) {
    const resources = [];
    const files = Object.keys(snapshot);
    for (const file of files) {
        const match = file.match(`/providers\/${providerNameInPath}\/(.*?)\/index\.ts/`);
        // avoids any not resources from being pushed
        if (match &&
            !match[1].includes("/") &&
            !match[1].includes("data-") &&
            !match[1].includes("provider")) {
            resources.push(match[1]);
        }
    }
    return resources;
}
describe("Provider", () => {
    it("generates a provider", async () => {
        const constraint = new commons_2.TerraformProviderConstraint("DataDog/datadog@= 3.12.0");
        return await (0, commons_1.mkdtemp)(async (workdir) => {
            const jsiiPath = path.join(workdir, ".jsii");
            const maker = new constructs_maker_1.ConstructsMaker({
                codeMakerOutput: workdir,
                outputJsii: jsiiPath,
                targetLanguage: commons_2.Language.TYPESCRIPT,
            }, process.env.CDKTF_EXPERIMENTAL_PROVIDER_SCHEMA_CACHE_PATH);
            await maker.generate([constraint]);
            const snapshot = directorySnapshot(workdir);
            expect(snapshot).toMatchSnapshot();
        });
    }, 600000);
    it("has generated provider that includes static import functions", async () => {
        const constraint = new commons_2.TerraformProviderConstraint("DataDog/datadog@= 3.12.0");
        return await (0, commons_1.mkdtemp)(async (workdir) => {
            const jsiiPath = path.join(workdir, ".jsii");
            const maker = new constructs_maker_1.ConstructsMaker({
                codeMakerOutput: workdir,
                outputJsii: jsiiPath,
                targetLanguage: commons_2.Language.TYPESCRIPT,
            });
            await maker.generate([constraint]);
            const snapshot = directorySnapshot(workdir);
            const terraformResourceTypesPresent = resourceTypesPresentInSnapshot(snapshot, "datadog");
            terraformResourceTypesPresent.forEach((resource) => {
                let terraformResourceType = resource.replace(/-/g, "_");
                if (!terraformResourceType.includes("datadog")) {
                    terraformResourceType = `datadog_${terraformResourceType}`;
                }
                expect(snapshot[`providers/datadog/${resource}/index.ts`]).toContain(`public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {`);
                expect(snapshot[`providers/datadog/${resource}/index.ts`]).toContain(`return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "${terraformResourceType}", importId: importFromId, provider });`);
            });
        });
    }, 600000);
    it("has name in constraint that does not match resolved name in fqpn", async () => {
        const constraint = new commons_2.TerraformProviderConstraint({
            name: "dockerr",
            source: "registry.terraform.io/kreuzwerker/docker",
            version: "3.0.2",
        });
        return await (0, commons_1.mkdtemp)(async (workdir) => {
            const jsiiPath = path.join(workdir, ".jsii");
            const maker = new constructs_maker_1.ConstructsMaker({
                codeMakerOutput: workdir,
                outputJsii: jsiiPath,
                targetLanguage: commons_2.Language.TYPESCRIPT,
            }, process.env.CDKTF_EXPERIMENTAL_PROVIDER_SCHEMA_CACHE_PATH);
            await maker.generate([constraint]);
            const snapshot = directorySnapshot(workdir);
            const terraformResourceTypesPresent = resourceTypesPresentInSnapshot(snapshot, "dockerr");
            terraformResourceTypesPresent.forEach((resource) => {
                expect(snapshot[`providers/dockerr/${resource}/index.ts`]).toBeDefined();
            });
        });
    }, 600000);
    it("generates constructs for two providers with same name", async () => {
        const constraint = new commons_2.TerraformProviderConstraint({
            name: "bitbucket",
            namespace: "Runelab",
            version: "2.1.0",
            source: "Runelab/bitbucket",
        });
        const constraint2 = new commons_2.TerraformProviderConstraint({
            name: "abitbucket",
            namespace: "aeirola",
            version: "2.0.2",
            source: "aeirola/bitbucket",
        });
        return await (0, commons_1.mkdtemp)(async (workdir) => {
            const jsiiPath = path.join(workdir, ".jsii");
            const maker = new constructs_maker_1.ConstructsMaker({
                codeMakerOutput: workdir,
                outputJsii: jsiiPath,
                targetLanguage: commons_2.Language.TYPESCRIPT,
            }, process.env.CDKTF_EXPERIMENTAL_PROVIDER_SCHEMA_CACHE_PATH);
            await maker.generate([constraint, constraint2]);
            console.log("workdir", workdir);
            const snapshot = directorySnapshot(workdir);
            expect(snapshot).toMatchSnapshot();
        });
    }, 600000);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvdmlkZXIudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInByb3ZpZGVyLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMsMkNBQTZCO0FBQzdCLDZDQUErQjtBQUMvQiwrQkFBNEI7QUFDNUIsNENBQXlDO0FBQ3pDLDhEQUEwRDtBQUMxRCw0Q0FBdUU7QUFNdkUsU0FBUyxpQkFBaUIsQ0FBQyxJQUFZO0lBQ3JDLE1BQU0sTUFBTSxHQUFnQixFQUFFLENBQUM7SUFFL0IsTUFBTSxLQUFLLEdBQUcsV0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7UUFDNUIsTUFBTSxFQUFFLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQztRQUM1QixHQUFHLEVBQUUsSUFBSTtRQUNULEtBQUssRUFBRSxJQUFJO1FBQ1gsR0FBRyxFQUFFLElBQUk7S0FDVixDQUFDLENBQUM7SUFFSCxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRTtRQUN4QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUV2QyxJQUFJLE9BQU8sQ0FBQztRQUVaLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxPQUFPLEVBQUU7WUFDdEMsT0FBTyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLENBQUM7WUFFcEMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxLQUFLLGtCQUFrQixFQUFFO2dCQUNsRCxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUM7YUFDdEI7U0FDRjthQUFNO1lBQ0wsT0FBTyxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQzlDO1FBRUQsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8s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Q0YsTUFBTSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsVUFBVSxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFDaEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDaEMsTUFBTSxRQUFRLEdBQUcsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDNUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3JDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxFQUFFLE1BQU8sQ0FBQyxDQUFDO0FBQ2QsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzLWV4dHJhXCI7XG5pbXBvcnQgeyBnbG9iIH0gZnJvbSBcImdsb2JcIjtcbmltcG9ydCB7IG1rZHRlbXAgfSBmcm9tIFwiQGNka3RmL2NvbW1vbnNcIjtcbmltcG9ydCB7IENvbnN0cnVjdHNNYWtlciB9IGZyb20gXCIuLi9nZXQvY29uc3RydWN0cy1tYWtlclwiO1xuaW1wb3J0IHsgTGFuZ3VhZ2UsIFRlcnJhZm9ybVByb3ZpZGVyQ29uc3RyYWludCB9IGZyb20gXCJAY2RrdGYvY29tbW9uc1wiO1xuXG5pbnRlcmZhY2UgU3ludGhPdXRwdXQge1xuICBbZmlsZVBhdGg6IHN0cmluZ106IGFueTtcbn1cblxuZnVuY3Rpb24gZGlyZWN0b3J5U25hcHNob3Qocm9vdDogc3RyaW5nKSB7XG4gIGNvbnN0IG91dHB1dDogU3ludGhPdXRwdXQgPSB7fTtcblxuICBjb25zdCBmaWxlcyA9IGdsb2Iuc3luYyhcIioqXCIsIHtcbiAgICBpZ25vcmU6IFtcIi5naXQvKipcIiwgXCIuanNpaVwiXSxcbiAgICBjd2Q6IHJvb3QsXG4gICAgbm9kaXI6IHRydWUsXG4gICAgZG90OiB0cnVlLFxuICB9KTtcblxuICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbihyb290LCBmaWxlKTtcblxuICAgIGxldCBjb250ZW50O1xuXG4gICAgaWYgKHBhdGguZXh0bmFtZShmaWxlUGF0aCkgPT09IFwiLmpzb25cIikge1xuICAgICAgY29udGVudCA9IGZzLnJlYWRKc29uU3luYyhmaWxlUGF0aCk7XG5cbiAgICAgIGlmIChwYXRoLmJhc2VuYW1lKGZpbGVQYXRoKSA9PT0gXCJjb25zdHJhaW50cy5qc29uXCIpIHtcbiAgICAgICAgZGVsZXRlIGNvbnRlbnQuY2RrdGY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsIFwidXRmLThcIik7XG4gICAgfVxuXG4gICAgb3V0cHV0W2ZpbGVdID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHJlc291cmNlVHlwZXNQcmVzZW50SW5TbmFwc2hvdChcbiAgc25hcHNob3Q6IFN5bnRoT3V0cHV0LFxuICBwcm92aWRlck5hbWVJblBhdGg6IHN0cmluZ1xuKSB7XG4gIGNvbnN0IHJlc291cmNlczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgZmlsZXMgPSBPYmplY3Qua2V5cyhzbmFwc2hvdCk7XG4gIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgIGNvbnN0IG1hdGNoID0gZmlsZS5tYXRjaChcbiAgICAgIGAvcHJvdmlkZXJzXFwvJHtwcm92aWRlck5hbWVJblBhdGh9XFwvKC4qPylcXC9pbmRleFxcLnRzL2BcbiAgICApO1xuICAgIC8vIGF2b2lkcyBhbnkgbm90IHJlc291cmNlcyBmcm9tIGJlaW5nIHB1c2hlZFxuICAgIGlmIChcbiAgICAgIG1hdGNoICYmXG4gICAgICAhbWF0Y2hbMV0uaW5jbHVkZXMoXCIvXCIpICYmXG4gICAgICAhbWF0Y2hbMV0uaW5jbHVkZXMoXCJkYXRhLVwiKSAmJlxuICAgICAgIW1hdGNoWzFdLmluY2x1ZGVzKFwicHJvdmlkZXJcIilcbiAgICApIHtcbiAgICAgIHJlc291cmNlcy5wdXNoKG1hdGNoWzFdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc291cmNlcztcbn1cblxuZGVzY3JpYmUoXCJQcm92aWRlclwiLCAoKSA9PiB7XG4gIGl0KFwiZ2VuZXJhdGVzIGEgcHJvdmlkZXJcIiwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBuZXcgVGVycmFmb3JtUHJvdmlkZXJDb25zdHJhaW50KFxuICAgICAgXCJEYXRhRG9nL2RhdGFkb2dAPSAzLjEyLjBcIlxuICAgICk7XG4gICAgcmV0dXJuIGF3YWl0IG1rZHRlbXAoYXN5bmMgKHdvcmtkaXIpID0+IHtcbiAgICAgIGNvbnN0IGpzaWlQYXRoID0gcGF0aC5qb2luKHdvcmtkaXIsIFwiLmpzaWlcIik7XG4gICAgICBjb25zdCBtYWtlciA9IG5ldyBDb25zdHJ1Y3RzTWFrZXIoXG4gICAgICAgIHtcbiAgICAgICAgICBjb2RlTWFrZXJPdXRwdXQ6IHdvcmtkaXIsXG4gICAgICAgICAgb3V0cHV0SnNpaToganNpaVBhdGgsXG4gICAgICAgICAgdGFyZ2V0TGFuZ3VhZ2U6IExhbmd1YWdlLlRZUEVTQ1JJUFQsXG4gICAgICAgIH0sXG4gICAgICAgIHByb2Nlc3MuZW52LkNES1RGX0VYUEVSSU1FTlRBTF9QUk9WSURFUl9TQ0hFTUFfQ0FDSEVfUEFUSFxuICAgICAgKTtcbiAgICAgIGF3YWl0IG1ha2VyLmdlbmVyYXRlKFtjb25zdHJhaW50XSk7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IGRpcmVjdG9yeVNuYXBzaG90KHdvcmtkaXIpO1xuICAgICAgZXhwZWN0KHNuYXBzaG90KS50b01hdGNoU25hcHNob3QoKTtcbiAgICB9KTtcbiAgfSwgNjAwXzAwMCk7XG5cbiAgaXQoXCJoYXMgZ2VuZXJhdGVkIHByb3ZpZGVyIHRoYXQgaW5jbHVkZXMgc3RhdGljIGltcG9ydCBmdW5jdGlvbnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBuZXcgVGVycmFmb3JtUHJvdmlkZXJDb25zdHJhaW50KFxuICAgICAgXCJEYXRhRG9nL2RhdGFkb2dAPSAzLjEyLjBcIlxuICAgICk7XG4gICAgcmV0dXJuIGF3YWl0IG1rZHRlbXAoYXN5bmMgKHdvcmtkaXIpID0+IHtcbiAgICAgIGNvbnN0IGpzaWlQYXRoID0gcGF0aC5qb2luKHdvcmtkaXIsIFwiLmpzaWlcIik7XG4gICAgICBjb25zdCBtYWtlciA9IG5ldyBDb25zdHJ1Y3RzTWFrZXIoe1xuICAgICAgICBjb2RlTWFrZXJPdXRwdXQ6IHdvcmtkaXIsXG4gICAgICAgIG91dHB1dEpzaWk6IGpzaWlQYXRoLFxuICAgICAgICB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2UuVFlQRVNDUklQVCxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgbWFrZXIuZ2VuZXJhdGUoW2NvbnN0cmFpbnRdKTtcbiAgICAgIGNvbnN0IHNuYXBzaG90ID0gZGlyZWN0b3J5U25hcHNob3Qod29ya2Rpcik7XG5cbiAgICAgIGNvbnN0IHRlcnJhZm9ybVJlc291cmNlVHlwZXNQcmVzZW50OiBzdHJpbmdbXSA9XG4gICAgICAgIHJlc291cmNlVHlwZXNQcmVzZW50SW5TbmFwc2hvdChzbmFwc2hvdCwgXCJkYXRhZG9nXCIpO1xuXG4gICAgICB0ZXJyYWZvcm1SZXNvdXJjZVR5cGVzUHJlc2VudC5mb3JFYWNoKChyZXNvdXJjZSkgPT4ge1xuICAgICAgICBsZXQgdGVycmFmb3JtUmVzb3VyY2VUeXBlID0gcmVzb3VyY2UucmVwbGFjZSgvLS9nLCBcIl9cIik7XG4gICAgICAgIGlmICghdGVycmFmb3JtUmVzb3VyY2VUeXBlLmluY2x1ZGVzKFwiZGF0YWRvZ1wiKSkge1xuICAgICAgICAgIHRlcnJhZm9ybVJlc291cmNlVHlwZSA9IGBkYXRhZG9nXyR7dGVycmFmb3JtUmVzb3VyY2VUeXBlfWA7XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0KHNuYXBzaG90W2Bwcm92aWRlcnMvZGF0YWRvZy8ke3Jlc291cmNlfS9pbmRleC50c2BdKS50b0NvbnRhaW4oXG4gICAgICAgICAgYHB1YmxpYyBzdGF0aWMgZ2VuZXJhdGVDb25maWdGb3JJbXBvcnQoc2NvcGU6IENvbnN0cnVjdCwgaW1wb3J0VG9JZDogc3RyaW5nLCBpbXBvcnRGcm9tSWQ6IHN0cmluZywgcHJvdmlkZXI/OiBjZGt0Zi5UZXJyYWZvcm1Qcm92aWRlcikge2BcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KHNuYXBzaG90W2Bwcm92aWRlcnMvZGF0YWRvZy8ke3Jlc291cmNlfS9pbmRleC50c2BdKS50b0NvbnRhaW4oXG4gICAgICAgICAgYHJldHVybiBuZXcgY2RrdGYuSW1wb3J0YWJsZVJlc291cmNlKHNjb3BlLCBpbXBvcnRUb0lkLCB7IHRlcnJhZm9ybVJlc291cmNlVHlwZTogXCIke3RlcnJhZm9ybVJlc291cmNlVHlwZX1cIiwgaW1wb3J0SWQ6IGltcG9ydEZyb21JZCwgcHJvdmlkZXIgfSk7YFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIDYwMF8wMDApO1xuXG4gIGl0KFwiaGFzIG5hbWUgaW4gY29uc3RyYWludCB0aGF0IGRvZXMgbm90IG1hdGNoIHJlc29sdmVkIG5hbWUgaW4gZnFwblwiLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgY29uc3RyYWludCA9IG5ldyBUZXJyYWZvcm1Qcm92aWRlckNvbnN0cmFpbnQoe1xuICAgICAgbmFtZTogXCJkb2NrZXJyXCIsXG4gICAgICBzb3VyY2U6IFwicmVnaXN0cnkudGVycmFmb3JtLmlvL2tyZXV6d2Vya2VyL2RvY2tlclwiLFxuICAgICAgdmVyc2lvbjogXCIzLjAuMlwiLFxuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCBta2R0ZW1wKGFzeW5jICh3b3JrZGlyKSA9PiB7XG4gICAgICBjb25zdCBqc2lpUGF0aCA9IHBhdGguam9pbih3b3JrZGlyLCBcIi5qc2lpXCIpO1xuICAgICAgY29uc3QgbWFrZXIgPSBuZXcgQ29uc3RydWN0c01ha2VyKFxuICAgICAgICB7XG4gICAgICAgICAgY29kZU1ha2VyT3V0cHV0OiB3b3JrZGlyLFxuICAgICAgICAgIG91dHB1dEpzaWk6IGpzaWlQYXRoLFxuICAgICAgICAgIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZS5UWVBFU0NSSVBULFxuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzLmVudi5DREtURl9FWFBFUklNRU5UQUxfUFJPVklERVJfU0NIRU1BX0NBQ0hFX1BBVEhcbiAgICAgICk7XG4gICAgICBhd2FpdCBtYWtlci5nZW5lcmF0ZShbY29uc3RyYWludF0pO1xuICAgICAgY29uc3Qgc25hcHNob3QgPSBkaXJlY3RvcnlTbmFwc2hvdCh3b3JrZGlyKTtcblxuICAgICAgY29uc3QgdGVycmFmb3JtUmVzb3VyY2VUeXBlc1ByZXNlbnQ6IHN0cmluZ1tdID1cbiAgICAgICAgcmVzb3VyY2VUeXBlc1ByZXNlbnRJblNuYXBzaG90KHNuYXBzaG90LCBcImRvY2tlcnJcIik7XG5cbiAgICAgIHRlcnJhZm9ybVJlc291cmNlVHlwZXNQcmVzZW50LmZvckVhY2goKHJlc291cmNlKSA9PiB7XG4gICAgICAgIGV4cGVjdChcbiAgICAgICAgICBzbmFwc2hvdFtgcHJvdmlkZXJzL2RvY2tlcnIvJHtyZXNvdXJjZX0vaW5kZXgudHNgXVxuICAgICAgICApLnRvQmVEZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgNjAwXzAwMCk7XG5cbiAgaXQoXCJnZW5lcmF0ZXMgY29uc3RydWN0cyBmb3IgdHdvIHByb3ZpZGVycyB3aXRoIHNhbWUgbmFtZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgY29uc3RyYWludCA9IG5ldyBUZXJyYWZvcm1Qcm92aWRlckNvbnN0cmFpbnQoe1xuICAgICAgbmFtZTogXCJiaXRidWNrZXRcIixcbiAgICAgIG5hbWVzcGFjZTogXCJSdW5lbGFiXCIsXG4gICAgICB2ZXJzaW9uOiBcIjIuMS4wXCIsXG4gICAgICBzb3VyY2U6IFwiUnVuZWxhYi9iaXRidWNrZXRcIixcbiAgICB9KTtcbiAgICBjb25zdCBjb25zdHJhaW50MiA9IG5ldyBUZXJyYWZvcm1Qcm92aWRlckNvbnN0cmFpbnQoe1xuICAgICAgbmFtZTogXCJhYml0YnVja2V0XCIsXG4gICAgICBuYW1lc3BhY2U6IFwiYWVpcm9sYVwiLFxuICAgICAgdmVyc2lvbjogXCIyLjAuMlwiLFxuICAgICAgc291cmNlOiBcImFlaXJvbGEvYml0YnVja2V0XCIsXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IG1rZHRlbXAoYXN5bmMgKHdvcmtkaXIpID0+IHtcbiAgICAgIGNvbnN0IGpzaWlQYXRoID0gcGF0aC5qb2luKHdvcmtkaXIsIFwiLmpzaWlcIik7XG4gICAgICBjb25zdCBtYWtlciA9IG5ldyBDb25zdHJ1Y3RzTWFrZXIoXG4gICAgICAgIHtcbiAgICAgICAgICBjb2RlTWFrZXJPdXRwdXQ6IHdvcmtkaXIsXG4gICAgICAgICAgb3V0cHV0SnNpaToganNpaVBhdGgsXG4gICAgICAgICAgdGFyZ2V0TGFuZ3VhZ2U6IExhbmd1YWdlLlRZUEVTQ1JJUFQsXG4gICAgICAgIH0sXG4gICAgICAgIHByb2Nlc3MuZW52LkNES1RGX0VYUEVSSU1FTlRBTF9QUk9WSURFUl9TQ0hFTUFfQ0FDSEVfUEFUSFxuICAgICAgKTtcbiAgICAgIGF3YWl0IG1ha2VyLmdlbmVyYXRlKFtjb25zdHJhaW50LCBjb25zdHJhaW50Ml0pO1xuICAgICAgY29uc29sZS5sb2coXCJ3b3JrZGlyXCIsIHdvcmtkaXIpO1xuICAgICAgY29uc3Qgc25hcHNob3QgPSBkaXJlY3RvcnlTbmFwc2hvdCh3b3JrZGlyKTtcbiAgICAgIGV4cGVjdChzbmFwc2hvdCkudG9NYXRjaFNuYXBzaG90KCk7XG4gICAgfSk7XG4gIH0sIDYwMF8wMDApO1xufSk7XG4iXX0=