/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
import { Construct } from 'constructs';
import * as cdktf from 'cdktf';
export interface ManagedKafkaClusterConfig extends cdktf.TerraformMetaArguments {
    /**
    * The ID to use for the cluster, which will become the final component of the cluster's name. The ID must be 1-63 characters long, and match the regular expression '[a-z]([-a-z0-9]*[a-z0-9])?' to comply with RFC 1035. This value is structured like: 'my-cluster-id'.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#cluster_id ManagedKafkaCluster#cluster_id}
    */
    readonly clusterId: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#id ManagedKafkaCluster#id}
    *
    * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
    * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
    */
    readonly id?: string;
    /**
    * List of label KEY=VALUE pairs to add. Keys must start with a lowercase character and contain only hyphens (-), underscores ( ), lowercase characters, and numbers. Values must contain only hyphens (-), underscores ( ), lowercase characters, and numbers.
    *
    * **Note**: This field is non-authoritative, and will only manage the labels present in your configuration.
    * Please refer to the field 'effective_labels' for all of the labels present on the resource.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#labels ManagedKafkaCluster#labels}
    */
    readonly labels?: {
        [key: string]: string;
    };
    /**
    * ID of the location of the Kafka resource. See https://cloud.google.com/managed-kafka/docs/locations for a list of supported locations.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#location ManagedKafkaCluster#location}
    */
    readonly location: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#project ManagedKafkaCluster#project}
    */
    readonly project?: string;
    /**
    * capacity_config block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#capacity_config ManagedKafkaCluster#capacity_config}
    */
    readonly capacityConfig: ManagedKafkaClusterCapacityConfig;
    /**
    * gcp_config block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#gcp_config ManagedKafkaCluster#gcp_config}
    */
    readonly gcpConfig: ManagedKafkaClusterGcpConfig;
    /**
    * rebalance_config block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#rebalance_config ManagedKafkaCluster#rebalance_config}
    */
    readonly rebalanceConfig?: ManagedKafkaClusterRebalanceConfig;
    /**
    * timeouts block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#timeouts ManagedKafkaCluster#timeouts}
    */
    readonly timeouts?: ManagedKafkaClusterTimeouts;
}
export interface ManagedKafkaClusterCapacityConfig {
    /**
    * The memory to provision for the cluster in bytes. The value must be between 1 GiB and 8 GiB per vCPU. Ex. 1024Mi, 4Gi.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#memory_bytes ManagedKafkaCluster#memory_bytes}
    */
    readonly memoryBytes: string;
    /**
    * The number of vCPUs to provision for the cluster. The minimum is 3.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#vcpu_count ManagedKafkaCluster#vcpu_count}
    */
    readonly vcpuCount: string;
}
export declare function managedKafkaClusterCapacityConfigToTerraform(struct?: ManagedKafkaClusterCapacityConfigOutputReference | ManagedKafkaClusterCapacityConfig): any;
export declare function managedKafkaClusterCapacityConfigToHclTerraform(struct?: ManagedKafkaClusterCapacityConfigOutputReference | ManagedKafkaClusterCapacityConfig): any;
export declare class ManagedKafkaClusterCapacityConfigOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): ManagedKafkaClusterCapacityConfig | undefined;
    set internalValue(value: ManagedKafkaClusterCapacityConfig | undefined);
    private _memoryBytes?;
    get memoryBytes(): string;
    set memoryBytes(value: string);
    get memoryBytesInput(): string | undefined;
    private _vcpuCount?;
    get vcpuCount(): string;
    set vcpuCount(value: string);
    get vcpuCountInput(): string | undefined;
}
export interface ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigs {
    /**
    * Name of the VPC subnet from which the cluster is accessible. Both broker and bootstrap server IP addresses and DNS entries are automatically created in the subnet. The subnet must be located in the same region as the cluster. The project may differ. The name of the subnet must be in the format 'projects/PROJECT_ID/regions/REGION/subnetworks/SUBNET'.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#subnet ManagedKafkaCluster#subnet}
    */
    readonly subnet: string;
}
export declare function managedKafkaClusterGcpConfigAccessConfigNetworkConfigsToTerraform(struct?: ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigs | cdktf.IResolvable): any;
export declare function managedKafkaClusterGcpConfigAccessConfigNetworkConfigsToHclTerraform(struct?: ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigs | cdktf.IResolvable): any;
export declare class ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigsOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    private resolvableValue?;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    * @param complexObjectIndex the index of this item in the list
    * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean);
    get internalValue(): ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigs | cdktf.IResolvable | undefined;
    set internalValue(value: ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigs | cdktf.IResolvable | undefined);
    private _subnet?;
    get subnet(): string;
    set subnet(value: string);
    get subnetInput(): string | undefined;
}
export declare class ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigsList extends cdktf.ComplexList {
    protected terraformResource: cdktf.IInterpolatingParent;
    protected terraformAttribute: string;
    protected wrapsSet: boolean;
    internalValue?: ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigs[] | cdktf.IResolvable;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, wrapsSet: boolean);
    /**
    * @param index the index of the item to return
    */
    get(index: number): ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigsOutputReference;
}
export interface ManagedKafkaClusterGcpConfigAccessConfig {
    /**
    * network_configs block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#network_configs ManagedKafkaCluster#network_configs}
    */
    readonly networkConfigs: ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigs[] | cdktf.IResolvable;
}
export declare function managedKafkaClusterGcpConfigAccessConfigToTerraform(struct?: ManagedKafkaClusterGcpConfigAccessConfigOutputReference | ManagedKafkaClusterGcpConfigAccessConfig): any;
export declare function managedKafkaClusterGcpConfigAccessConfigToHclTerraform(struct?: ManagedKafkaClusterGcpConfigAccessConfigOutputReference | ManagedKafkaClusterGcpConfigAccessConfig): any;
export declare class ManagedKafkaClusterGcpConfigAccessConfigOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): ManagedKafkaClusterGcpConfigAccessConfig | undefined;
    set internalValue(value: ManagedKafkaClusterGcpConfigAccessConfig | undefined);
    private _networkConfigs;
    get networkConfigs(): ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigsList;
    putNetworkConfigs(value: ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigs[] | cdktf.IResolvable): void;
    get networkConfigsInput(): cdktf.IResolvable | ManagedKafkaClusterGcpConfigAccessConfigNetworkConfigs[] | undefined;
}
export interface ManagedKafkaClusterGcpConfig {
    /**
    * The Cloud KMS Key name to use for encryption. The key must be located in the same region as the cluster and cannot be changed. Must be in the format 'projects/PROJECT_ID/locations/LOCATION/keyRings/KEY_RING/cryptoKeys/KEY'.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#kms_key ManagedKafkaCluster#kms_key}
    */
    readonly kmsKey?: string;
    /**
    * access_config block
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#access_config ManagedKafkaCluster#access_config}
    */
    readonly accessConfig: ManagedKafkaClusterGcpConfigAccessConfig;
}
export declare function managedKafkaClusterGcpConfigToTerraform(struct?: ManagedKafkaClusterGcpConfigOutputReference | ManagedKafkaClusterGcpConfig): any;
export declare function managedKafkaClusterGcpConfigToHclTerraform(struct?: ManagedKafkaClusterGcpConfigOutputReference | ManagedKafkaClusterGcpConfig): any;
export declare class ManagedKafkaClusterGcpConfigOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): ManagedKafkaClusterGcpConfig | undefined;
    set internalValue(value: ManagedKafkaClusterGcpConfig | undefined);
    private _kmsKey?;
    get kmsKey(): string;
    set kmsKey(value: string);
    resetKmsKey(): void;
    get kmsKeyInput(): string | undefined;
    private _accessConfig;
    get accessConfig(): ManagedKafkaClusterGcpConfigAccessConfigOutputReference;
    putAccessConfig(value: ManagedKafkaClusterGcpConfigAccessConfig): void;
    get accessConfigInput(): ManagedKafkaClusterGcpConfigAccessConfig | undefined;
}
export interface ManagedKafkaClusterRebalanceConfig {
    /**
    * The rebalance behavior for the cluster. When not specified, defaults to 'NO_REBALANCE'. Possible values: 'MODE_UNSPECIFIED', 'NO_REBALANCE', 'AUTO_REBALANCE_ON_SCALE_UP'.
    *
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#mode ManagedKafkaCluster#mode}
    */
    readonly mode?: string;
}
export declare function managedKafkaClusterRebalanceConfigToTerraform(struct?: ManagedKafkaClusterRebalanceConfigOutputReference | ManagedKafkaClusterRebalanceConfig): any;
export declare function managedKafkaClusterRebalanceConfigToHclTerraform(struct?: ManagedKafkaClusterRebalanceConfigOutputReference | ManagedKafkaClusterRebalanceConfig): any;
export declare class ManagedKafkaClusterRebalanceConfigOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): ManagedKafkaClusterRebalanceConfig | undefined;
    set internalValue(value: ManagedKafkaClusterRebalanceConfig | undefined);
    private _mode?;
    get mode(): string;
    set mode(value: string);
    resetMode(): void;
    get modeInput(): string | undefined;
}
export interface ManagedKafkaClusterTimeouts {
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#create ManagedKafkaCluster#create}
    */
    readonly create?: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#delete ManagedKafkaCluster#delete}
    */
    readonly delete?: string;
    /**
    * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#update ManagedKafkaCluster#update}
    */
    readonly update?: string;
}
export declare function managedKafkaClusterTimeoutsToTerraform(struct?: ManagedKafkaClusterTimeouts | cdktf.IResolvable): any;
export declare function managedKafkaClusterTimeoutsToHclTerraform(struct?: ManagedKafkaClusterTimeouts | cdktf.IResolvable): any;
export declare class ManagedKafkaClusterTimeoutsOutputReference extends cdktf.ComplexObject {
    private isEmptyObject;
    private resolvableValue?;
    /**
    * @param terraformResource The parent resource
    * @param terraformAttribute The attribute on the parent resource this class is referencing
    */
    constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string);
    get internalValue(): ManagedKafkaClusterTimeouts | cdktf.IResolvable | undefined;
    set internalValue(value: ManagedKafkaClusterTimeouts | cdktf.IResolvable | undefined);
    private _create?;
    get create(): string;
    set create(value: string);
    resetCreate(): void;
    get createInput(): string | undefined;
    private _delete?;
    get delete(): string;
    set delete(value: string);
    resetDelete(): void;
    get deleteInput(): string | undefined;
    private _update?;
    get update(): string;
    set update(value: string);
    resetUpdate(): void;
    get updateInput(): string | undefined;
}
/**
* Represents a {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster google_managed_kafka_cluster}
*/
export declare class ManagedKafkaCluster extends cdktf.TerraformResource {
    static readonly tfResourceType = "google_managed_kafka_cluster";
    /**
    * Generates CDKTF code for importing a ManagedKafkaCluster resource upon running "cdktf plan <stack-name>"
    * @param scope The scope in which to define this construct
    * @param importToId The construct id used in the generated config for the ManagedKafkaCluster to import
    * @param importFromId The id of the existing ManagedKafkaCluster that should be imported. Refer to the {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster#import import section} in the documentation of this resource for the id to use
    * @param provider? Optional instance of the provider where the ManagedKafkaCluster to import is found
    */
    static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider): cdktf.ImportableResource;
    /**
    * Create a new {@link https://registry.terraform.io/providers/hashicorp/google/6.14.1/docs/resources/managed_kafka_cluster google_managed_kafka_cluster} Resource
    *
    * @param scope The scope in which to define this construct
    * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
    * @param options ManagedKafkaClusterConfig
    */
    constructor(scope: Construct, id: string, config: ManagedKafkaClusterConfig);
    private _clusterId?;
    get clusterId(): string;
    set clusterId(value: string);
    get clusterIdInput(): string | undefined;
    get createTime(): string;
    private _effectiveLabels;
    get effectiveLabels(): cdktf.StringMap;
    private _id?;
    get id(): string;
    set id(value: string);
    resetId(): void;
    get idInput(): string | undefined;
    private _labels?;
    get labels(): {
        [key: string]: string;
    };
    set labels(value: {
        [key: string]: string;
    });
    resetLabels(): void;
    get labelsInput(): {
        [key: string]: string;
    } | undefined;
    private _location?;
    get location(): string;
    set location(value: string);
    get locationInput(): string | undefined;
    get name(): string;
    private _project?;
    get project(): string;
    set project(value: string);
    resetProject(): void;
    get projectInput(): string | undefined;
    get state(): string;
    private _terraformLabels;
    get terraformLabels(): cdktf.StringMap;
    get updateTime(): string;
    private _capacityConfig;
    get capacityConfig(): ManagedKafkaClusterCapacityConfigOutputReference;
    putCapacityConfig(value: ManagedKafkaClusterCapacityConfig): void;
    get capacityConfigInput(): ManagedKafkaClusterCapacityConfig | undefined;
    private _gcpConfig;
    get gcpConfig(): ManagedKafkaClusterGcpConfigOutputReference;
    putGcpConfig(value: ManagedKafkaClusterGcpConfig): void;
    get gcpConfigInput(): ManagedKafkaClusterGcpConfig | undefined;
    private _rebalanceConfig;
    get rebalanceConfig(): ManagedKafkaClusterRebalanceConfigOutputReference;
    putRebalanceConfig(value: ManagedKafkaClusterRebalanceConfig): void;
    resetRebalanceConfig(): void;
    get rebalanceConfigInput(): ManagedKafkaClusterRebalanceConfig | undefined;
    private _timeouts;
    get timeouts(): ManagedKafkaClusterTimeoutsOutputReference;
    putTimeouts(value: ManagedKafkaClusterTimeouts): void;
    resetTimeouts(): void;
    get timeoutsInput(): cdktf.IResolvable | ManagedKafkaClusterTimeouts | undefined;
    protected synthesizeAttributes(): {
        [name: string]: any;
    };
    protected synthesizeHclAttributes(): {
        [name: string]: any;
    };
}
