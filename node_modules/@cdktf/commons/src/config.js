"use strict";
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.logTimespan = exports.shouldCheckCodeMakerOutput = exports.readConfigSync = exports.parseConfig = exports.TerraformProviderConstraint = exports.TerraformModuleConstraint = exports.isLocalModule = exports.CONFIG_DEFAULTS = exports.LANGUAGES = exports.Language = void 0;
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const logging_1 = require("./logging");
const terraform_module_1 = require("./terraform-module");
const process_1 = require("process");
const codemaker_1 = require("codemaker");
var Language;
(function (Language) {
    Language["TYPESCRIPT"] = "typescript";
    Language["PYTHON"] = "python";
    Language["CSHARP"] = "csharp";
    Language["JAVA"] = "java";
    Language["GO"] = "go";
})(Language || (exports.Language = Language = {}));
exports.LANGUAGES = [
    Language.TYPESCRIPT,
    Language.PYTHON,
    Language.JAVA,
    Language.CSHARP,
    Language.GO,
];
const CONTEXT_ENV = "CDKTF_CONTEXT_JSON";
const CONFIG_FILE = "cdktf.json";
exports.CONFIG_DEFAULTS = {
    output: "cdktf.out",
    codeMakerOutput: ".gen",
};
function isPresent(input) {
    return Array.isArray(input) && input.length > 0;
}
function getLocalMatch(source) {
    return source.match(/^(\.\/|\.\.\/|\.\\\\|\.\.\\\\)(.*)/);
}
function isLocalModule(source) {
    return getLocalMatch(source) !== null;
}
exports.isLocalModule = isLocalModule;
class TerraformModuleConstraint {
    constructor(item) {
        if (typeof item === "string") {
            const parsed = this.parseDependencyConstraint(item);
            this.name = parsed.name;
            this.source = parsed.source;
            this.fqn = parsed.fqn;
            this.version = parsed.version;
            this.namespace = parsed.namespace;
        }
        else {
            this.source = item.source;
            this.name = item.name;
            this.fqn = item.name;
            this.version = item.version;
            this.namespace = item.namespace;
        }
        const localMatch = getLocalMatch(this.source);
        if (localMatch) {
            this.localSourceAbsolutePath = path.join(process.cwd(), this.source);
        }
    }
    get className() {
        return (0, codemaker_1.toPascalCase)(this.name.replace(/[-/.]/g, "_"));
    }
    get fileName() {
        return this.namespace ? `${this.namespace}/${this.name}` : this.name;
    }
    parseDependencyConstraint(item) {
        var _a, _b, _c;
        const localMatch = getLocalMatch(item);
        if (localMatch) {
            const fqn = localMatch[2];
            const nameParts = fqn.split("/");
            const name = (_a = nameParts.pop()) !== null && _a !== void 0 ? _a : fqn;
            const namespace = nameParts.pop();
            return {
                name,
                fqn,
                source: item,
                namespace,
            };
        }
        const [source, version] = item.split("@");
        let moduleParts = source.split("//");
        if ((0, terraform_module_1.isRegistryModule)(moduleParts[0])) {
            const nameParts = moduleParts[0].split("/");
            const provider = nameParts.pop(); // last part is the provider
            let name = (_b = nameParts.pop()) !== null && _b !== void 0 ? _b : source;
            let namespace = `${nameParts.pop()}/${provider}`;
            if (moduleParts.length > 1) {
                const moduleNameParts = moduleParts[1].split("/");
                const moduleName = moduleNameParts.pop();
                namespace = `${namespace}/${name}/${moduleNameParts.join("/")}`;
                name = moduleName !== null && moduleName !== void 0 ? moduleName : name;
            }
            return {
                name,
                source,
                version,
                namespace,
                fqn: source.replace("//", "/").replace(/\./g, "-"),
            };
        }
        let toProcess = item; // process one part at a time
        // strip off any prefix
        const prefixMatch = toProcess.match(/^([a-zA-Z0-9]*)::(.*)/);
        if (prefixMatch) {
            toProcess = prefixMatch[2];
        }
        // strip off any protocol
        const protocolMatch = toProcess.match(/^([a-zA-Z]*):\/\/(.*)/);
        if (protocolMatch) {
            toProcess = protocolMatch[2];
        }
        // anything before last ':' won't contribute
        const colonParts = toProcess.split(":");
        toProcess = (_c = colonParts.pop()) !== null && _c !== void 0 ? _c : toProcess;
        // strip off any port
        const portMatch = toProcess.match(/^[\d]*(.*)/);
        if (portMatch) {
            toProcess = portMatch[1];
        }
        // strip off any hostname
        const hostMatch = toProcess.match(/[^/]*\.[^/]*\/(.*)/);
        if (hostMatch) {
            toProcess = hostMatch[1];
        }
        // strip off any arguments
        const argumentMatch = toProcess.match(/(.*)\?.*/);
        if (argumentMatch) {
            toProcess = argumentMatch[1];
        }
        // strip off any types
        toProcess = toProcess.replace(/\.git|\.hg|\.zip/, "");
        moduleParts = toProcess.split("//");
        const nameParts = moduleParts[0].split("/");
        let name = nameParts.pop();
        let namespace = nameParts.pop();
        if (!name) {
            throw new Error(`Module name should be properly set in ${item}`);
        }
        if (moduleParts.length > 1) {
            const moduleNameParts = moduleParts[1].split("/");
            const moduleName = moduleNameParts.pop();
            if (namespace) {
                namespace = `${namespace}/${name}/${moduleNameParts.join("/")}`;
            }
            else {
                namespace = `${name}/${moduleNameParts.join("/")}`;
            }
            name = moduleName !== null && moduleName !== void 0 ? moduleName : name;
        }
        return {
            name,
            source: item,
            fqn: toProcess.replace("//", "/"),
            namespace,
        };
    }
}
exports.TerraformModuleConstraint = TerraformModuleConstraint;
class TerraformProviderConstraint {
    constructor(item) {
        if (typeof item === "string") {
            const parsed = this.parseDependencyConstraint(item);
            this.name = parsed.name;
            this.fqn = parsed.fqn;
            this.source = parsed.fqn;
            this.version = parsed.version;
            this.namespace = parsed.namespace;
        }
        else {
            this.name = item.name;
            this.fqn = item.name;
            this.version = item.version;
            this.source = item.source;
            this.namespace = item.namespace;
        }
    }
    parseDependencyConstraint(item) {
        const [fqn, version] = item.split("@");
        const nameParts = fqn.split("/");
        const name = nameParts.pop();
        const namespace = nameParts.pop();
        if (!name) {
            throw new Error(`Provider name should be properly set in ${item}`);
        }
        return {
            name,
            source: fqn,
            // Terraform doesn't support *, instead no version is specified
            version: version === "*" ? undefined : version,
            fqn,
            namespace,
        };
    }
}
exports.TerraformProviderConstraint = TerraformProviderConstraint;
const parseConfig = (configJSON) => {
    var _a, _b;
    const config = {
        ...exports.CONFIG_DEFAULTS,
        ...JSON.parse(configJSON || "{}"),
    };
    if (isPresent(config.terraformModules)) {
        config.terraformModules = (_a = config.terraformModules) === null || _a === void 0 ? void 0 : _a.map((mod) => new TerraformModuleConstraint(mod));
    }
    if (isPresent(config.terraformProviders)) {
        config.terraformProviders = (_b = config.terraformProviders) === null || _b === void 0 ? void 0 : _b.map((provider) => new TerraformProviderConstraint(provider));
    }
    if (config.context) {
        process_1.env[CONTEXT_ENV] = JSON.stringify(config.context);
    }
    return config;
};
exports.parseConfig = parseConfig;
function readConfigSync(configFile = path.join(process.cwd(), CONFIG_FILE)) {
    let configFileContent;
    if (fs.existsSync(configFile)) {
        configFileContent = fs.readFileSync(configFile).toString();
    }
    return (0, exports.parseConfig)(configFileContent);
}
exports.readConfigSync = readConfigSync;
function shouldCheckCodeMakerOutput(config) {
    return (isPresent(config.terraformModules) || isPresent(config.terraformProviders));
}
exports.shouldCheckCodeMakerOutput = shouldCheckCodeMakerOutput;
function logTimespan(message) {
    logging_1.logger.debug(`Start timer for ${message}...`);
    const start = Date.now();
    return function logTimespanEnd() {
        const end = Date.now();
        const duration = end - start;
        logging_1.logger.debug(`${message} took ${duration}ms`);
    };
}
exports.logTimespan = logTimespan;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlnLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29uZmlnLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUgsNkNBQStCO0FBQy9CLDJDQUE2QjtBQUM3Qix1Q0FBbUM7QUFDbkMseURBQXNEO0FBQ3RELHFDQUE4QjtBQUM5Qix5Q0FBeUM7QUFFekMsSUFBWSxRQU1YO0FBTkQsV0FBWSxRQUFRO0lBQ2xCLHFDQUF5QixDQUFBO0lBQ3pCLDZCQUFpQixDQUFBO0lBQ2pCLDZCQUFpQixDQUFBO0lBQ2pCLHlCQUFhLENBQUE7SUFDYixxQkFBUyxDQUFBO0FBQ1gsQ0FBQyxFQU5XLFFBQVEsd0JBQVIsUUFBUSxRQU1uQjtBQUVZLFFBQUEsU0FBUyxHQUFHO0lBQ3ZCLFFBQVEsQ0FBQyxVQUFVO0lBQ25CLFFBQVEsQ0FBQyxNQUFNO0lBQ2YsUUFBUSxDQUFDLElBQUk7SUFDYixRQUFRLENBQUMsTUFBTTtJQUNmLFFBQVEsQ0FBQyxFQUFFO0NBQ1osQ0FBQztBQUVGLE1BQU0sV0FBVyxHQUFHLG9CQUFvQixDQUFDO0FBRXpDLE1BQU0sV0FBVyxHQUFHLFlBQVksQ0FBQztBQUNwQixRQUFBLGVBQWUsR0FBRztJQUM3QixNQUFNLEVBQUUsV0FBVztJQUNuQixlQUFlLEVBQUUsTUFBTTtDQUN4QixDQUFDO0FBRUYsU0FBUyxTQUFTLENBQUMsS0FBd0I7SUFDekMsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFTRCxTQUFTLGFBQWEsQ0FBQyxNQUFjO0lBQ25DLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO0FBQzVELENBQUM7QUFFRCxTQUFnQixhQUFhLENBQUMsTUFBYztJQUMxQyxPQUFPLGFBQWEsQ0FBQyxNQUFNLENBQUMsS0FBSyxJQUFJLENBQUM7QUFDeEMsQ0FBQztBQUZELHNDQUVDO0FBRUQsTUFBYSx5QkFBeUI7SUFVcEMsWUFBWSxJQUE0QztRQUN0RCxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUM1QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDcEQsSUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztZQUM1QixJQUFJLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUM7WUFDdEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1lBQzlCLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztTQUNuQzthQUFNO1lBQ0wsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQzFCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztZQUN0QixJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1lBQzVCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztTQUNqQztRQUVELE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDOUMsSUFBSSxVQUFVLEVBQUU7WUFDZCxJQUFJLENBQUMsdUJBQXVCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3RFO0lBQ0gsQ0FBQztJQUVELElBQVcsU0FBUztRQUNsQixPQUFPLElBQUEsd0JBQVksRUFBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQsSUFBVyxRQUFRO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztJQUN2RSxDQUFDO0lBRU8seUJBQXlCLENBQy9CLElBQVk7O1FBRVosTUFBTSxVQUFVLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZDLElBQUksVUFBVSxFQUFFO1lBQ2QsTUFBTSxHQUFHLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzFCLE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDakMsTUFBTSxJQUFJLEdBQUcsTUFBQSxTQUFTLENBQUMsR0FBRyxFQUFFLG1DQUFJLEdBQUcsQ0FBQztZQUNwQyxNQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7WUFFbEMsT0FBTztnQkFDTCxJQUFJO2dCQUNKLEdBQUc7Z0JBQ0gsTUFBTSxFQUFFLElBQUk7Z0JBQ1osU0FBUzthQUNWLENBQUM7U0FDSDtRQUVELE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMxQyxJQUFJLFdBQVcsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JDLElBQUksSUFBQSxtQ0FBZ0IsRUFBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNwQyxNQUFNLFNBQVMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzVDLE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLDRCQUE0QjtZQUM5RCxJQUFJLElBQUksR0FBRyxNQUFBLFNBQVMsQ0FBQyxHQUFHLEVBQUUsbUNBQUksTUFBTSxDQUFDO1lBQ3JDLElBQUksU0FBUyxHQUFHLEdBQUcsU0FBUyxDQUFDLEdBQUcsRUFBRSxJQUFJLFFBQVEsRUFBRSxDQUFDO1lBRWpELElBQUksV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQzFCLE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ2xELE1BQU0sVUFBVSxHQUFHLGVBQWUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDekMsU0FBUyxHQUFHLEdBQUcsU0FBUyxJQUFJLElBQUksSUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7Z0JBQ2hFLElBQUksR0FBRyxVQUFVLGFBQVYsVUFBVSxjQUFWLFVBQVUsR0FBSSxJQUFJLENBQUM7YUFDM0I7WUFFRCxPQUFPO2dCQUNMLElBQUk7Z0JBQ0osTUFBTTtnQkFDTixPQUFPO2dCQUNQLFNBQVM7Z0JBQ1QsR0FBRyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDO2FBQ25ELENBQUM7U0FDSDtRQUVELElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxDQUFDLDZCQUE2QjtRQUVuRCx1QkFBdUI7UUFDdkIsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQzdELElBQUksV0FBVyxFQUFFO1lBQ2YsU0FBUyxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM1QjtRQUVELHlCQUF5QjtRQUN6QixNQUFNLGFBQWEsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDL0QsSUFBSSxhQUFhLEVBQUU7WUFDakIsU0FBUyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM5QjtRQUVELDRDQUE0QztRQUM1QyxNQUFNLFVBQVUsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hDLFNBQVMsR0FBRyxNQUFBLFVBQVUsQ0FBQyxHQUFHLEVBQUUsbUNBQUksU0FBUyxDQUFDO1FBRTFDLHFCQUFxQjtRQUNyQixNQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ2hELElBQUksU0FBUyxFQUFFO1lBQ2IsU0FBUyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMxQjtRQUVELHlCQUF5QjtRQUN6QixNQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDeEQsSUFBSSxTQUFTLEVBQUU7WUFDYixTQUFTLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzFCO1FBRUQsMEJBQTBCO1FBQzFCLE1BQU0sYUFBYSxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDbEQsSUFBSSxhQUFhLEVBQUU7WUFDakIsU0FBUyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM5QjtRQUVELHNCQUFzQjtRQUN0QixTQUFTLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUV0RCxXQUFXLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwQyxNQUFNLFNBQVMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzVDLElBQUksSUFBSSxHQUFHLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUMzQixJQUFJLFNBQVMsR0FBRyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDaEMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNULE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDbEU7UUFFRCxJQUFJLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzFCLE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDbEQsTUFBTSxVQUFVLEdBQUcsZUFBZSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ3pDLElBQUksU0FBUyxFQUFFO2dCQUNiLFNBQVMsR0FBRyxHQUFHLFNBQVMsSUFBSSxJQUFJLElBQUksZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO2FBQ2pFO2lCQUFNO2dCQUNMLFNBQVMsR0FBRyxHQUFHLElBQUksSUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUM7YUFDcEQ7WUFDRCxJQUFJLEdBQUcsVUFBVSxhQUFWLFVBQVUsY0FBVixVQUFVLEdBQUksSUFBSSxDQUFDO1NBQzNCO1FBRUQsT0FBTztZQUNMLElBQUk7WUFDSixNQUFNLEVBQUUsSUFBSTtZQUNaLEdBQUcsRUFBRSxTQUFTLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUM7WUFDakMsU0FBUztTQUNWLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFuSkQsOERBbUpDO0FBRUQsTUFBYSwyQkFBMkI7SUFTdEMsWUFBWSxJQUF5RDtRQUNuRSxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUM1QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDcEQsSUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQztZQUN0QixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUM7WUFDekIsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1lBQzlCLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztTQUNuQzthQUFNO1lBQ0wsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQ3RCLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztZQUNyQixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7WUFDNUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQzFCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztTQUNqQztJQUNILENBQUM7SUFFTyx5QkFBeUIsQ0FDL0IsSUFBWTtRQUVaLE1BQU0sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QyxNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDLE1BQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUM3QixNQUFNLFNBQVMsR0FBRyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDbEMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUNULE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDcEU7UUFFRCxPQUFPO1lBQ0wsSUFBSTtZQUNKLE1BQU0sRUFBRSxHQUFHO1lBQ1gsK0RBQStEO1lBQy9ELE9BQU8sRUFBRSxPQUFPLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLE9BQU87WUFDOUMsR0FBRztZQUNILFNBQVM7U0FDVixDQUFDO0lBQ0osQ0FBQztDQUNGO0FBOUNELGtFQThDQztBQVlNLE1BQU0sV0FBVyxHQUFHLENBQUMsVUFBbUIsRUFBRSxFQUFFOztJQUNqRCxNQUFNLE1BQU0sR0FBVztRQUNyQixHQUFHLHVCQUFlO1FBQ2xCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDO0tBQ2xDLENBQUM7SUFFRixJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtRQUN0QyxNQUFNLENBQUMsZ0JBQWdCLEdBQUcsTUFBQSxNQUFNLENBQUMsZ0JBQWdCLDBDQUFFLEdBQUcsQ0FDcEQsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLElBQUkseUJBQXlCLENBQUMsR0FBRyxDQUFDLENBQzVDLENBQUM7S0FDSDtJQUVELElBQUksU0FBUyxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO1FBQ3hDLE1BQU0sQ0FBQyxrQkFBa0IsR0FBRyxNQUFBLE1BQU0sQ0FBQyxrQkFBa0IsMENBQUUsR0FBRyxDQUN4RCxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsSUFBSSwyQkFBMkIsQ0FBQyxRQUFRLENBQUMsQ0FDeEQsQ0FBQztLQUNIO0lBRUQsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1FBQ2xCLGFBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUNuRDtJQUVELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMsQ0FBQztBQXZCVyxRQUFBLFdBQVcsZUF1QnRCO0FBRUYsU0FBZ0IsY0FBYyxDQUM1QixVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsV0FBVyxDQUFDO0lBRWxELElBQUksaUJBQXFDLENBQUM7SUFFMUMsSUFBSSxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQzdCLGlCQUFpQixHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDNUQ7SUFFRCxPQUFPLElBQUEsbUJBQVcsRUFBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBQ3hDLENBQUM7QUFWRCx3Q0FVQztBQUVELFNBQWdCLDBCQUEwQixDQUFDLE1BQWM7SUFDdkQsT0FBTyxDQUNMLFNBQVMsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQzNFLENBQUM7QUFDSixDQUFDO0FBSkQsZ0VBSUM7QUFFRCxTQUFnQixXQUFXLENBQUMsT0FBZTtJQUN6QyxnQkFBTSxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsT0FBTyxLQUFLLENBQUMsQ0FBQztJQUM5QyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFFekIsT0FBTyxTQUFTLGNBQWM7UUFDNUIsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3ZCLE1BQU0sUUFBUSxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUM7UUFDN0IsZ0JBQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxPQUFPLFNBQVMsUUFBUSxJQUFJLENBQUMsQ0FBQztJQUNoRCxDQUFDLENBQUM7QUFDSixDQUFDO0FBVEQsa0NBU0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgSGFzaGlDb3JwLCBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuICovXG5cbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmcy1leHRyYVwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4vbG9nZ2luZ1wiO1xuaW1wb3J0IHsgaXNSZWdpc3RyeU1vZHVsZSB9IGZyb20gXCIuL3RlcnJhZm9ybS1tb2R1bGVcIjtcbmltcG9ydCB7IGVudiB9IGZyb20gXCJwcm9jZXNzXCI7XG5pbXBvcnQgeyB0b1Bhc2NhbENhc2UgfSBmcm9tIFwiY29kZW1ha2VyXCI7XG5cbmV4cG9ydCBlbnVtIExhbmd1YWdlIHtcbiAgVFlQRVNDUklQVCA9IFwidHlwZXNjcmlwdFwiLFxuICBQWVRIT04gPSBcInB5dGhvblwiLFxuICBDU0hBUlAgPSBcImNzaGFycFwiLFxuICBKQVZBID0gXCJqYXZhXCIsXG4gIEdPID0gXCJnb1wiLFxufVxuXG5leHBvcnQgY29uc3QgTEFOR1VBR0VTID0gW1xuICBMYW5ndWFnZS5UWVBFU0NSSVBULFxuICBMYW5ndWFnZS5QWVRIT04sXG4gIExhbmd1YWdlLkpBVkEsXG4gIExhbmd1YWdlLkNTSEFSUCxcbiAgTGFuZ3VhZ2UuR08sXG5dO1xuXG5jb25zdCBDT05URVhUX0VOViA9IFwiQ0RLVEZfQ09OVEVYVF9KU09OXCI7XG5cbmNvbnN0IENPTkZJR19GSUxFID0gXCJjZGt0Zi5qc29uXCI7XG5leHBvcnQgY29uc3QgQ09ORklHX0RFRkFVTFRTID0ge1xuICBvdXRwdXQ6IFwiY2RrdGYub3V0XCIsXG4gIGNvZGVNYWtlck91dHB1dDogXCIuZ2VuXCIsXG59O1xuXG5mdW5jdGlvbiBpc1ByZXNlbnQoaW5wdXQ6IGFueVtdIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPiAwO1xufVxuZXhwb3J0IGludGVyZmFjZSBUZXJyYWZvcm1EZXBlbmRlbmN5Q29uc3RyYWludCB7XG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgc291cmNlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHZlcnNpb24/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGZxbjogc3RyaW5nO1xuICByZWFkb25seSBuYW1lc3BhY2U/OiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGdldExvY2FsTWF0Y2goc291cmNlOiBzdHJpbmcpOiBSZWdFeHBNYXRjaEFycmF5IHwgbnVsbCB7XG4gIHJldHVybiBzb3VyY2UubWF0Y2goL14oXFwuXFwvfFxcLlxcLlxcL3xcXC5cXFxcXFxcXHxcXC5cXC5cXFxcXFxcXCkoLiopLyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2FsTW9kdWxlKHNvdXJjZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBnZXRMb2NhbE1hdGNoKHNvdXJjZSkgIT09IG51bGw7XG59XG5cbmV4cG9ydCBjbGFzcyBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50XG4gIGltcGxlbWVudHMgVGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnRcbntcbiAgcHVibGljIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IHNvdXJjZTogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxTb3VyY2VBYnNvbHV0ZVBhdGg/OiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBmcW46IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IHZlcnNpb24/OiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBuYW1lc3BhY2U/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoaXRlbTogVGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnQgfCBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VEZXBlbmRlbmN5Q29uc3RyYWludChpdGVtKTtcbiAgICAgIHRoaXMubmFtZSA9IHBhcnNlZC5uYW1lO1xuICAgICAgdGhpcy5zb3VyY2UgPSBwYXJzZWQuc291cmNlO1xuICAgICAgdGhpcy5mcW4gPSBwYXJzZWQuZnFuO1xuICAgICAgdGhpcy52ZXJzaW9uID0gcGFyc2VkLnZlcnNpb247XG4gICAgICB0aGlzLm5hbWVzcGFjZSA9IHBhcnNlZC5uYW1lc3BhY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc291cmNlID0gaXRlbS5zb3VyY2U7XG4gICAgICB0aGlzLm5hbWUgPSBpdGVtLm5hbWU7XG4gICAgICB0aGlzLmZxbiA9IGl0ZW0ubmFtZTtcbiAgICAgIHRoaXMudmVyc2lvbiA9IGl0ZW0udmVyc2lvbjtcbiAgICAgIHRoaXMubmFtZXNwYWNlID0gaXRlbS5uYW1lc3BhY2U7XG4gICAgfVxuXG4gICAgY29uc3QgbG9jYWxNYXRjaCA9IGdldExvY2FsTWF0Y2godGhpcy5zb3VyY2UpO1xuICAgIGlmIChsb2NhbE1hdGNoKSB7XG4gICAgICB0aGlzLmxvY2FsU291cmNlQWJzb2x1dGVQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIHRoaXMuc291cmNlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IGNsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gdG9QYXNjYWxDYXNlKHRoaXMubmFtZS5yZXBsYWNlKC9bLS8uXS9nLCBcIl9cIikpO1xuICB9XG5cbiAgcHVibGljIGdldCBmaWxlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2UgPyBgJHt0aGlzLm5hbWVzcGFjZX0vJHt0aGlzLm5hbWV9YCA6IHRoaXMubmFtZTtcbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VEZXBlbmRlbmN5Q29uc3RyYWludChcbiAgICBpdGVtOiBzdHJpbmdcbiAgKTogVGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnQge1xuICAgIGNvbnN0IGxvY2FsTWF0Y2ggPSBnZXRMb2NhbE1hdGNoKGl0ZW0pO1xuICAgIGlmIChsb2NhbE1hdGNoKSB7XG4gICAgICBjb25zdCBmcW4gPSBsb2NhbE1hdGNoWzJdO1xuICAgICAgY29uc3QgbmFtZVBhcnRzID0gZnFuLnNwbGl0KFwiL1wiKTtcbiAgICAgIGNvbnN0IG5hbWUgPSBuYW1lUGFydHMucG9wKCkgPz8gZnFuO1xuICAgICAgY29uc3QgbmFtZXNwYWNlID0gbmFtZVBhcnRzLnBvcCgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBmcW4sXG4gICAgICAgIHNvdXJjZTogaXRlbSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBbc291cmNlLCB2ZXJzaW9uXSA9IGl0ZW0uc3BsaXQoXCJAXCIpO1xuICAgIGxldCBtb2R1bGVQYXJ0cyA9IHNvdXJjZS5zcGxpdChcIi8vXCIpO1xuICAgIGlmIChpc1JlZ2lzdHJ5TW9kdWxlKG1vZHVsZVBhcnRzWzBdKSkge1xuICAgICAgY29uc3QgbmFtZVBhcnRzID0gbW9kdWxlUGFydHNbMF0uc3BsaXQoXCIvXCIpO1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBuYW1lUGFydHMucG9wKCk7IC8vIGxhc3QgcGFydCBpcyB0aGUgcHJvdmlkZXJcbiAgICAgIGxldCBuYW1lID0gbmFtZVBhcnRzLnBvcCgpID8/IHNvdXJjZTtcbiAgICAgIGxldCBuYW1lc3BhY2UgPSBgJHtuYW1lUGFydHMucG9wKCl9LyR7cHJvdmlkZXJ9YDtcblxuICAgICAgaWYgKG1vZHVsZVBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlTmFtZVBhcnRzID0gbW9kdWxlUGFydHNbMV0uc3BsaXQoXCIvXCIpO1xuICAgICAgICBjb25zdCBtb2R1bGVOYW1lID0gbW9kdWxlTmFtZVBhcnRzLnBvcCgpO1xuICAgICAgICBuYW1lc3BhY2UgPSBgJHtuYW1lc3BhY2V9LyR7bmFtZX0vJHttb2R1bGVOYW1lUGFydHMuam9pbihcIi9cIil9YDtcbiAgICAgICAgbmFtZSA9IG1vZHVsZU5hbWUgPz8gbmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIGZxbjogc291cmNlLnJlcGxhY2UoXCIvL1wiLCBcIi9cIikucmVwbGFjZSgvXFwuL2csIFwiLVwiKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IHRvUHJvY2VzcyA9IGl0ZW07IC8vIHByb2Nlc3Mgb25lIHBhcnQgYXQgYSB0aW1lXG5cbiAgICAvLyBzdHJpcCBvZmYgYW55IHByZWZpeFxuICAgIGNvbnN0IHByZWZpeE1hdGNoID0gdG9Qcm9jZXNzLm1hdGNoKC9eKFthLXpBLVowLTldKik6OiguKikvKTtcbiAgICBpZiAocHJlZml4TWF0Y2gpIHtcbiAgICAgIHRvUHJvY2VzcyA9IHByZWZpeE1hdGNoWzJdO1xuICAgIH1cblxuICAgIC8vIHN0cmlwIG9mZiBhbnkgcHJvdG9jb2xcbiAgICBjb25zdCBwcm90b2NvbE1hdGNoID0gdG9Qcm9jZXNzLm1hdGNoKC9eKFthLXpBLVpdKik6XFwvXFwvKC4qKS8pO1xuICAgIGlmIChwcm90b2NvbE1hdGNoKSB7XG4gICAgICB0b1Byb2Nlc3MgPSBwcm90b2NvbE1hdGNoWzJdO1xuICAgIH1cblxuICAgIC8vIGFueXRoaW5nIGJlZm9yZSBsYXN0ICc6JyB3b24ndCBjb250cmlidXRlXG4gICAgY29uc3QgY29sb25QYXJ0cyA9IHRvUHJvY2Vzcy5zcGxpdChcIjpcIik7XG4gICAgdG9Qcm9jZXNzID0gY29sb25QYXJ0cy5wb3AoKSA/PyB0b1Byb2Nlc3M7XG5cbiAgICAvLyBzdHJpcCBvZmYgYW55IHBvcnRcbiAgICBjb25zdCBwb3J0TWF0Y2ggPSB0b1Byb2Nlc3MubWF0Y2goL15bXFxkXSooLiopLyk7XG4gICAgaWYgKHBvcnRNYXRjaCkge1xuICAgICAgdG9Qcm9jZXNzID0gcG9ydE1hdGNoWzFdO1xuICAgIH1cblxuICAgIC8vIHN0cmlwIG9mZiBhbnkgaG9zdG5hbWVcbiAgICBjb25zdCBob3N0TWF0Y2ggPSB0b1Byb2Nlc3MubWF0Y2goL1teL10qXFwuW14vXSpcXC8oLiopLyk7XG4gICAgaWYgKGhvc3RNYXRjaCkge1xuICAgICAgdG9Qcm9jZXNzID0gaG9zdE1hdGNoWzFdO1xuICAgIH1cblxuICAgIC8vIHN0cmlwIG9mZiBhbnkgYXJndW1lbnRzXG4gICAgY29uc3QgYXJndW1lbnRNYXRjaCA9IHRvUHJvY2Vzcy5tYXRjaCgvKC4qKVxcPy4qLyk7XG4gICAgaWYgKGFyZ3VtZW50TWF0Y2gpIHtcbiAgICAgIHRvUHJvY2VzcyA9IGFyZ3VtZW50TWF0Y2hbMV07XG4gICAgfVxuXG4gICAgLy8gc3RyaXAgb2ZmIGFueSB0eXBlc1xuICAgIHRvUHJvY2VzcyA9IHRvUHJvY2Vzcy5yZXBsYWNlKC9cXC5naXR8XFwuaGd8XFwuemlwLywgXCJcIik7XG5cbiAgICBtb2R1bGVQYXJ0cyA9IHRvUHJvY2Vzcy5zcGxpdChcIi8vXCIpO1xuICAgIGNvbnN0IG5hbWVQYXJ0cyA9IG1vZHVsZVBhcnRzWzBdLnNwbGl0KFwiL1wiKTtcbiAgICBsZXQgbmFtZSA9IG5hbWVQYXJ0cy5wb3AoKTtcbiAgICBsZXQgbmFtZXNwYWNlID0gbmFtZVBhcnRzLnBvcCgpO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNb2R1bGUgbmFtZSBzaG91bGQgYmUgcHJvcGVybHkgc2V0IGluICR7aXRlbX1gKTtcbiAgICB9XG5cbiAgICBpZiAobW9kdWxlUGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgbW9kdWxlTmFtZVBhcnRzID0gbW9kdWxlUGFydHNbMV0uc3BsaXQoXCIvXCIpO1xuICAgICAgY29uc3QgbW9kdWxlTmFtZSA9IG1vZHVsZU5hbWVQYXJ0cy5wb3AoKTtcbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgbmFtZXNwYWNlID0gYCR7bmFtZXNwYWNlfS8ke25hbWV9LyR7bW9kdWxlTmFtZVBhcnRzLmpvaW4oXCIvXCIpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lc3BhY2UgPSBgJHtuYW1lfS8ke21vZHVsZU5hbWVQYXJ0cy5qb2luKFwiL1wiKX1gO1xuICAgICAgfVxuICAgICAgbmFtZSA9IG1vZHVsZU5hbWUgPz8gbmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZSxcbiAgICAgIHNvdXJjZTogaXRlbSxcbiAgICAgIGZxbjogdG9Qcm9jZXNzLnJlcGxhY2UoXCIvL1wiLCBcIi9cIiksXG4gICAgICBuYW1lc3BhY2UsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGVycmFmb3JtUHJvdmlkZXJDb25zdHJhaW50XG4gIGltcGxlbWVudHMgVGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnRcbntcbiAgcHVibGljIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IHNvdXJjZTogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgdmVyc2lvbj86IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGZxbjogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgbmFtZXNwYWNlPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGl0ZW06IE9taXQ8VGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnQsIFwiZnFuXCI+IHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlRGVwZW5kZW5jeUNvbnN0cmFpbnQoaXRlbSk7XG4gICAgICB0aGlzLm5hbWUgPSBwYXJzZWQubmFtZTtcbiAgICAgIHRoaXMuZnFuID0gcGFyc2VkLmZxbjtcbiAgICAgIHRoaXMuc291cmNlID0gcGFyc2VkLmZxbjtcbiAgICAgIHRoaXMudmVyc2lvbiA9IHBhcnNlZC52ZXJzaW9uO1xuICAgICAgdGhpcy5uYW1lc3BhY2UgPSBwYXJzZWQubmFtZXNwYWNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5hbWUgPSBpdGVtLm5hbWU7XG4gICAgICB0aGlzLmZxbiA9IGl0ZW0ubmFtZTtcbiAgICAgIHRoaXMudmVyc2lvbiA9IGl0ZW0udmVyc2lvbjtcbiAgICAgIHRoaXMuc291cmNlID0gaXRlbS5zb3VyY2U7XG4gICAgICB0aGlzLm5hbWVzcGFjZSA9IGl0ZW0ubmFtZXNwYWNlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGFyc2VEZXBlbmRlbmN5Q29uc3RyYWludChcbiAgICBpdGVtOiBzdHJpbmdcbiAgKTogVGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnQge1xuICAgIGNvbnN0IFtmcW4sIHZlcnNpb25dID0gaXRlbS5zcGxpdChcIkBcIik7XG4gICAgY29uc3QgbmFtZVBhcnRzID0gZnFuLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCBuYW1lID0gbmFtZVBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IG5hbWVQYXJ0cy5wb3AoKTtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvdmlkZXIgbmFtZSBzaG91bGQgYmUgcHJvcGVybHkgc2V0IGluICR7aXRlbX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZSxcbiAgICAgIHNvdXJjZTogZnFuLFxuICAgICAgLy8gVGVycmFmb3JtIGRvZXNuJ3Qgc3VwcG9ydCAqLCBpbnN0ZWFkIG5vIHZlcnNpb24gaXMgc3BlY2lmaWVkXG4gICAgICB2ZXJzaW9uOiB2ZXJzaW9uID09PSBcIipcIiA/IHVuZGVmaW5lZCA6IHZlcnNpb24sXG4gICAgICBmcW4sXG4gICAgICBuYW1lc3BhY2UsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbmZpZyB7XG4gIHJlYWRvbmx5IGFwcD86IHN0cmluZztcbiAgcmVhZG9ubHkgbGFuZ3VhZ2U/OiBMYW5ndWFnZTtcbiAgcmVhZG9ubHkgb3V0cHV0OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNvZGVNYWtlck91dHB1dDogc3RyaW5nO1xuICB0ZXJyYWZvcm1Qcm92aWRlcnM/OiBUZXJyYWZvcm1Qcm92aWRlckNvbnN0cmFpbnRbXTtcbiAgdGVycmFmb3JtTW9kdWxlcz86IFRlcnJhZm9ybU1vZHVsZUNvbnN0cmFpbnRbXTtcbiAgcmVhZG9ubHkgY29udGV4dD86IHsgW2tleTogc3RyaW5nXTogYW55IH07XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbmZpZyA9IChjb25maWdKU09OPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGNvbmZpZzogQ29uZmlnID0ge1xuICAgIC4uLkNPTkZJR19ERUZBVUxUUyxcbiAgICAuLi5KU09OLnBhcnNlKGNvbmZpZ0pTT04gfHwgXCJ7fVwiKSxcbiAgfTtcblxuICBpZiAoaXNQcmVzZW50KGNvbmZpZy50ZXJyYWZvcm1Nb2R1bGVzKSkge1xuICAgIGNvbmZpZy50ZXJyYWZvcm1Nb2R1bGVzID0gY29uZmlnLnRlcnJhZm9ybU1vZHVsZXM/Lm1hcChcbiAgICAgIChtb2QpID0+IG5ldyBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50KG1vZClcbiAgICApO1xuICB9XG5cbiAgaWYgKGlzUHJlc2VudChjb25maWcudGVycmFmb3JtUHJvdmlkZXJzKSkge1xuICAgIGNvbmZpZy50ZXJyYWZvcm1Qcm92aWRlcnMgPSBjb25maWcudGVycmFmb3JtUHJvdmlkZXJzPy5tYXAoXG4gICAgICAocHJvdmlkZXIpID0+IG5ldyBUZXJyYWZvcm1Qcm92aWRlckNvbnN0cmFpbnQocHJvdmlkZXIpXG4gICAgKTtcbiAgfVxuXG4gIGlmIChjb25maWcuY29udGV4dCkge1xuICAgIGVudltDT05URVhUX0VOVl0gPSBKU09OLnN0cmluZ2lmeShjb25maWcuY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gY29uZmlnO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRDb25maWdTeW5jKFxuICBjb25maWdGaWxlID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIENPTkZJR19GSUxFKVxuKTogQ29uZmlnIHtcbiAgbGV0IGNvbmZpZ0ZpbGVDb250ZW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgaWYgKGZzLmV4aXN0c1N5bmMoY29uZmlnRmlsZSkpIHtcbiAgICBjb25maWdGaWxlQ29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhjb25maWdGaWxlKS50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlQ29uZmlnKGNvbmZpZ0ZpbGVDb250ZW50KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZENoZWNrQ29kZU1ha2VyT3V0cHV0KGNvbmZpZzogQ29uZmlnKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgaXNQcmVzZW50KGNvbmZpZy50ZXJyYWZvcm1Nb2R1bGVzKSB8fCBpc1ByZXNlbnQoY29uZmlnLnRlcnJhZm9ybVByb3ZpZGVycylcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZ1RpbWVzcGFuKG1lc3NhZ2U6IHN0cmluZykge1xuICBsb2dnZXIuZGVidWcoYFN0YXJ0IHRpbWVyIGZvciAke21lc3NhZ2V9Li4uYCk7XG4gIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcblxuICByZXR1cm4gZnVuY3Rpb24gbG9nVGltZXNwYW5FbmQoKSB7XG4gICAgY29uc3QgZW5kID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGVuZCAtIHN0YXJ0O1xuICAgIGxvZ2dlci5kZWJ1ZyhgJHttZXNzYWdlfSB0b29rICR7ZHVyYXRpb259bXNgKTtcbiAgfTtcbn1cbiJdfQ==