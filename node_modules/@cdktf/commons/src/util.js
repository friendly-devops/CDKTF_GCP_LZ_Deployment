"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasNoColorFlagOrEnv = exports.ensureAllSettledBeforeThrowing = exports.downloadFile = exports.HttpError = exports.downcaseFirst = exports.readCDKTFManifest = exports.readCDKTFVersion = exports.exec = exports.mkdtemp = exports.withTempDir = exports.shell = void 0;
const cross_spawn_1 = require("cross-spawn");
const fs = __importStar(require("fs-extra"));
const follow_redirects_1 = require("follow-redirects");
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const logging_1 = require("./logging");
const cdktf_1 = require("cdktf");
const config = __importStar(require("./config"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
async function shell(program, args = [], options = {}) {
    const stderr = new Array();
    const stdout = new Array();
    try {
        return await (0, exports.exec)(program, args, options, (chunk) => {
            const sanitizedChunk = options.noColor
                ? (0, strip_ansi_1.default)(chunk.toLocaleString())
                : chunk.toLocaleString();
            stdout.push(sanitizedChunk);
            console.log(sanitizedChunk);
        }, (chunk) => {
            const sanitizedChunk = options.noColor
                ? (0, strip_ansi_1.default)(chunk.toLocaleString())
                : chunk.toLocaleString();
            stderr.push(sanitizedChunk);
        });
    }
    catch (e) {
        if (stderr.length > 0) {
            e.stderr = stderr.map((chunk) => chunk.toString()).join("");
            if (options.noColor) {
                e.stderr = (0, strip_ansi_1.default)(e.stderr);
            }
        }
        if (stdout.length > 0) {
            e.stdout = stdout.join("");
            if (options.noColor) {
                e.stdout = (0, strip_ansi_1.default)(e.stdout);
            }
        }
        throw e;
    }
}
exports.shell = shell;
async function withTempDir(dirname, closure) {
    const prevdir = process.cwd();
    const parent = await fs.mkdtemp(path.join(os.tmpdir(), "cdktf."));
    const workdir = path.join(parent, dirname);
    await fs.mkdirp(workdir);
    try {
        process.chdir(workdir);
        await closure();
    }
    finally {
        process.chdir(prevdir);
        await fs.remove(parent);
    }
}
exports.withTempDir = withTempDir;
async function mkdtemp(closure) {
    const workdir = await fs.mkdtemp(path.join(os.tmpdir(), "cdktf."));
    try {
        await closure(workdir);
    }
    finally {
        await fs.remove(workdir);
    }
}
exports.mkdtemp = mkdtemp;
const exec = async (command, args, options, stdout, stderr, sendToStderr = true) => {
    // if options.noColor is not set, checking the flags & environment if it should be set
    // This is required for collectDebugInformation() which does not have knowledge about flags
    if (typeof options.noColor !== "boolean" && hasNoColorFlagOrEnv()) {
        options.noColor = true;
    }
    return new Promise((ok, ko) => {
        var _a, _b, _c, _d;
        const child = (0, cross_spawn_1.spawn)(command, args, options);
        const out = new Array();
        const err = new Array();
        if (stdout !== undefined) {
            (_a = child.stdout) === null || _a === void 0 ? void 0 : _a.on("data", (chunk) => {
                const sanitizedChunk = options.noColor
                    ? (0, strip_ansi_1.default)(chunk.toLocaleString())
                    : chunk.toLocaleString();
                (0, logging_1.processLoggerDebug)(sanitizedChunk);
                out.push(sanitizedChunk);
                stdout(sanitizedChunk);
            });
        }
        else {
            (_b = child.stdout) === null || _b === void 0 ? void 0 : _b.on("data", (chunk) => {
                const sanitizedChunk = options.noColor
                    ? (0, strip_ansi_1.default)(chunk.toLocaleString())
                    : chunk.toLocaleString();
                (0, logging_1.processLoggerDebug)(sanitizedChunk);
                out.push(sanitizedChunk);
            });
        }
        if (stderr !== undefined) {
            (_c = child.stderr) === null || _c === void 0 ? void 0 : _c.on("data", (chunk) => {
                const sanitizedChunk = options.noColor
                    ? (0, strip_ansi_1.default)(chunk.toLocaleString())
                    : chunk.toLocaleString();
                (0, logging_1.processLoggerError)(sanitizedChunk);
                if (sendToStderr) {
                    stderr(sanitizedChunk);
                }
                err.push(sanitizedChunk);
            });
        }
        else {
            (_d = child.stderr) === null || _d === void 0 ? void 0 : _d.on("data", (chunk) => {
                const sanitizedChunk = options.noColor
                    ? (0, strip_ansi_1.default)(chunk.toLocaleString())
                    : chunk.toLocaleString();
                (0, logging_1.processLoggerError)(sanitizedChunk);
                if (sendToStderr) {
                    process.stderr.write(sanitizedChunk);
                }
                err.push(sanitizedChunk);
            });
        }
        child.once("error", (err) => ko(err));
        child.once("close", (code) => {
            if (code !== 0) {
                const error = new Error(`non-zero exit code ${code}`);
                error.stderr = err.map((chunk) => chunk.toString()).join("");
                return ko(error);
            }
            return ok(out.join(""));
        });
    });
};
exports.exec = exec;
async function readCDKTFVersion(outputDir) {
    const outputFile = path.join(outputDir, "cdk.tf.json");
    if (fs.existsSync(outputFile)) {
        const outputJSON = fs.readFileSync(outputFile, "utf8");
        const data = JSON.parse(outputJSON);
        return data["//"].metadata.version;
    }
    return "";
}
exports.readCDKTFVersion = readCDKTFVersion;
async function readCDKTFManifest() {
    const { output } = config.readConfigSync();
    const json = await fs.readFile(path.join(output, cdktf_1.Manifest.fileName));
    return JSON.parse(json.toString());
}
exports.readCDKTFManifest = readCDKTFManifest;
/**
 * Downcase the first character in a string.
 *
 * @param str the string to be processed.
 */
function downcaseFirst(str) {
    if (str === "") {
        return str;
    }
    return `${str[0].toLocaleLowerCase()}${str.slice(1)}`;
}
exports.downcaseFirst = downcaseFirst;
class HttpError extends Error {
    constructor(message, statusCode) {
        super(message); // 'Error' breaks prototype chain here
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
        // see: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#support-for-newtarget
    }
}
exports.HttpError = HttpError;
async function downloadFile(url, targetFilename) {
    // if the type is inferred to be "http|https" calling .get() is not possible
    // because the options parameter (which we don't use anyway) for get is
    // not compatible between http and https -> so we treat it as http
    const client = (url.startsWith("http://") ? follow_redirects_1.http : follow_redirects_1.https);
    const file = fs.createWriteStream(targetFilename);
    return new Promise((ok, ko) => {
        const request = client.get(url, (response) => {
            if (response.statusCode !== 200) {
                ko(new HttpError(`Failed to get '${url}' (${response.statusCode})`, response.statusCode));
                return;
            }
            response.pipe(file);
        });
        file.on("finish", () => ok());
        request.on("error", (err) => {
            fs.unlink(targetFilename, () => ko(err));
        });
        file.on("error", (err) => {
            fs.unlink(targetFilename, () => ko(err));
        });
        request.end();
    });
}
exports.downloadFile = downloadFile;
/**
 * Awaits a promise and makes sure it's error (if any) is only thrown after all other promises are settled
 * if the promise does not throw an error, the other promises won't be awaited
 * @param p promise to await
 * @param promises promises to await to be all settled if p failed before throwing error that p failed with
 */
async function ensureAllSettledBeforeThrowing(p, promises) {
    try {
        await p;
    }
    catch (e) {
        // if an error happened, we still need to wait for all other promises that
        // are currently in progress to complete to allow them to properly wrap up
        await Promise.allSettled(promises);
        throw e;
    }
}
exports.ensureAllSettledBeforeThrowing = ensureAllSettledBeforeThrowing;
/**
 * returns true if --no-color is passed as CLI flag or the env var FORCE_COLOR is set to "0"
 * Used for cases where we can't pass down the noColor flag (e.g. when collecting debug information from the environment)
 * This is the same behavior as the `chalk` lib we use for coloring output
 */
function hasNoColorFlagOrEnv() {
    return hasFlag("no-color") || process.env.FORCE_COLOR === "0";
}
exports.hasNoColorFlagOrEnv = hasNoColorFlagOrEnv;
// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
// as used in https://github.com/chalk/chalk
function hasFlag(flag) {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = process.argv.indexOf(prefix + flag);
    const terminatorPosition = process.argv.indexOf("--");
    return (position !== -1 &&
        (terminatorPosition === -1 || position < terminatorPosition));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQSw2Q0FBb0M7QUFDcEMsNkNBQStCO0FBQy9CLHVEQUErQztBQUMvQyx1Q0FBeUI7QUFDekIsMkNBQTZCO0FBQzdCLHVDQUFtRTtBQUNuRSxpQ0FBNEM7QUFDNUMsaURBQW1DO0FBQ25DLDREQUFtQztBQUU1QixLQUFLLFVBQVUsS0FBSyxDQUN6QixPQUFlLEVBQ2YsT0FBaUIsRUFBRSxFQUNuQixVQUFnRCxFQUFFO0lBRWxELE1BQU0sTUFBTSxHQUFHLElBQUksS0FBSyxFQUF1QixDQUFDO0lBQ2hELE1BQU0sTUFBTSxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7SUFDbkMsSUFBSTtRQUNGLE9BQU8sTUFBTSxJQUFBLFlBQUksRUFDZixPQUFPLEVBQ1AsSUFBSSxFQUNKLE9BQU8sRUFDUCxDQUFDLEtBQWEsRUFBRSxFQUFFO1lBQ2hCLE1BQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxPQUFPO2dCQUNwQyxDQUFDLENBQUMsSUFBQSxvQkFBUyxFQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDbkMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUMzQixNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQzVCLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDOUIsQ0FBQyxFQUNELENBQUMsS0FBMEIsRUFBRSxFQUFFO1lBQzdCLE1BQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxPQUFPO2dCQUNwQyxDQUFDLENBQUMsSUFBQSxvQkFBUyxFQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDbkMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUMzQixNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FB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akMsT0FBTyxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEtBQUssR0FBRyxDQUFDO0FBQ2hFLENBQUM7QUFGRCxrREFFQztBQUVELG9FQUFvRTtBQUNwRSw0Q0FBNEM7QUFDNUMsU0FBUyxPQUFPLENBQUMsSUFBWTtJQUMzQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUMxRSxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUM7SUFDckQsTUFBTSxrQkFBa0IsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN0RCxPQUFPLENBQ0wsUUFBUSxLQUFLLENBQUMsQ0FBQztRQUNmLENBQUMsa0JBQWtCLEtBQUssQ0FBQyxDQUFDLElBQUksUUFBUSxHQUFHLGtCQUFrQixDQUFDLENBQzdELENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluY1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcbmltcG9ydCB7IFNwYXduT3B0aW9ucyB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5pbXBvcnQgeyBzcGF3biB9IGZyb20gXCJjcm9zcy1zcGF3blwiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzLWV4dHJhXCI7XG5pbXBvcnQgeyBodHRwcywgaHR0cCB9IGZyb20gXCJmb2xsb3ctcmVkaXJlY3RzXCI7XG5pbXBvcnQgKiBhcyBvcyBmcm9tIFwib3NcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IHByb2Nlc3NMb2dnZXJFcnJvciwgcHJvY2Vzc0xvZ2dlckRlYnVnIH0gZnJvbSBcIi4vbG9nZ2luZ1wiO1xuaW1wb3J0IHsgSU1hbmlmZXN0LCBNYW5pZmVzdCB9IGZyb20gXCJjZGt0ZlwiO1xuaW1wb3J0ICogYXMgY29uZmlnIGZyb20gXCIuL2NvbmZpZ1wiO1xuaW1wb3J0IHN0cmlwQW5zaSBmcm9tIFwic3RyaXAtYW5zaVwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2hlbGwoXG4gIHByb2dyYW06IHN0cmluZyxcbiAgYXJnczogc3RyaW5nW10gPSBbXSxcbiAgb3B0aW9uczogU3Bhd25PcHRpb25zICYgeyBub0NvbG9yPzogYm9vbGVhbiB9ID0ge31cbikge1xuICBjb25zdCBzdGRlcnIgPSBuZXcgQXJyYXk8c3RyaW5nIHwgVWludDhBcnJheT4oKTtcbiAgY29uc3Qgc3Rkb3V0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZXhlYyhcbiAgICAgIHByb2dyYW0sXG4gICAgICBhcmdzLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIChjaHVuazogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHNhbml0aXplZENodW5rID0gb3B0aW9ucy5ub0NvbG9yXG4gICAgICAgICAgPyBzdHJpcEFuc2koY2h1bmsudG9Mb2NhbGVTdHJpbmcoKSlcbiAgICAgICAgICA6IGNodW5rLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgIHN0ZG91dC5wdXNoKHNhbml0aXplZENodW5rKTtcbiAgICAgICAgY29uc29sZS5sb2coc2FuaXRpemVkQ2h1bmspO1xuICAgICAgfSxcbiAgICAgIChjaHVuazogc3RyaW5nIHwgVWludDhBcnJheSkgPT4ge1xuICAgICAgICBjb25zdCBzYW5pdGl6ZWRDaHVuayA9IG9wdGlvbnMubm9Db2xvclxuICAgICAgICAgID8gc3RyaXBBbnNpKGNodW5rLnRvTG9jYWxlU3RyaW5nKCkpXG4gICAgICAgICAgOiBjaHVuay50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICBzdGRlcnIucHVzaChzYW5pdGl6ZWRDaHVuayk7XG4gICAgICB9XG4gICAgKTtcbiAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgaWYgKHN0ZGVyci5sZW5ndGggPiAwKSB7XG4gICAgICBlLnN0ZGVyciA9IHN0ZGVyci5tYXAoKGNodW5rKSA9PiBjaHVuay50b1N0cmluZygpKS5qb2luKFwiXCIpO1xuICAgICAgaWYgKG9wdGlvbnMubm9Db2xvcikge1xuICAgICAgICBlLnN0ZGVyciA9IHN0cmlwQW5zaShlLnN0ZGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGRvdXQubGVuZ3RoID4gMCkge1xuICAgICAgZS5zdGRvdXQgPSBzdGRvdXQuam9pbihcIlwiKTtcbiAgICAgIGlmIChvcHRpb25zLm5vQ29sb3IpIHtcbiAgICAgICAgZS5zdGRvdXQgPSBzdHJpcEFuc2koZS5zdGRvdXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aXRoVGVtcERpcihcbiAgZGlybmFtZTogc3RyaW5nLFxuICBjbG9zdXJlOiAoKSA9PiBQcm9taXNlPHZvaWQ+XG4pIHtcbiAgY29uc3QgcHJldmRpciA9IHByb2Nlc3MuY3dkKCk7XG4gIGNvbnN0IHBhcmVudCA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCBcImNka3RmLlwiKSk7XG4gIGNvbnN0IHdvcmtkaXIgPSBwYXRoLmpvaW4ocGFyZW50LCBkaXJuYW1lKTtcbiAgYXdhaXQgZnMubWtkaXJwKHdvcmtkaXIpO1xuICB0cnkge1xuICAgIHByb2Nlc3MuY2hkaXIod29ya2Rpcik7XG4gICAgYXdhaXQgY2xvc3VyZSgpO1xuICB9IGZpbmFsbHkge1xuICAgIHByb2Nlc3MuY2hkaXIocHJldmRpcik7XG4gICAgYXdhaXQgZnMucmVtb3ZlKHBhcmVudCk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1rZHRlbXAoY2xvc3VyZTogKGRpcjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+KSB7XG4gIGNvbnN0IHdvcmtkaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgXCJjZGt0Zi5cIikpO1xuICB0cnkge1xuICAgIGF3YWl0IGNsb3N1cmUod29ya2Rpcik7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmVtb3ZlKHdvcmtkaXIpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBleGVjID0gYXN5bmMgKFxuICBjb21tYW5kOiBzdHJpbmcsXG4gIGFyZ3M6IHN0cmluZ1tdLFxuICBvcHRpb25zOiBTcGF3bk9wdGlvbnMgJiB7IG5vQ29sb3I/OiBib29sZWFuIH0sXG4gIHN0ZG91dD86IChjaHVuazogc3RyaW5nKSA9PiBhbnksXG4gIHN0ZGVycj86IChjaHVuazogc3RyaW5nIHwgVWludDhBcnJheSkgPT4gYW55LFxuICBzZW5kVG9TdGRlcnIgPSB0cnVlXG4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAvLyBpZiBvcHRpb25zLm5vQ29sb3IgaXMgbm90IHNldCwgY2hlY2tpbmcgdGhlIGZsYWdzICYgZW52aXJvbm1lbnQgaWYgaXQgc2hvdWxkIGJlIHNldFxuICAvLyBUaGlzIGlzIHJlcXVpcmVkIGZvciBjb2xsZWN0RGVidWdJbmZvcm1hdGlvbigpIHdoaWNoIGRvZXMgbm90IGhhdmUga25vd2xlZGdlIGFib3V0IGZsYWdzXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5ub0NvbG9yICE9PSBcImJvb2xlYW5cIiAmJiBoYXNOb0NvbG9yRmxhZ09yRW52KCkpIHtcbiAgICBvcHRpb25zLm5vQ29sb3IgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChvaywga28pID0+IHtcbiAgICBjb25zdCBjaGlsZCA9IHNwYXduKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpO1xuICAgIGNvbnN0IG91dCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gICAgY29uc3QgZXJyID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICBpZiAoc3Rkb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoaWxkLnN0ZG91dD8ub24oXCJkYXRhXCIsIChjaHVuazogQnVmZmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHNhbml0aXplZENodW5rID0gb3B0aW9ucy5ub0NvbG9yXG4gICAgICAgICAgPyBzdHJpcEFuc2koY2h1bmsudG9Mb2NhbGVTdHJpbmcoKSlcbiAgICAgICAgICA6IGNodW5rLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgIHByb2Nlc3NMb2dnZXJEZWJ1ZyhzYW5pdGl6ZWRDaHVuayk7XG4gICAgICAgIG91dC5wdXNoKHNhbml0aXplZENodW5rKTtcbiAgICAgICAgc3Rkb3V0KHNhbml0aXplZENodW5rKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZC5zdGRvdXQ/Lm9uKFwiZGF0YVwiLCAoY2h1bms6IEJ1ZmZlcikgPT4ge1xuICAgICAgICBjb25zdCBzYW5pdGl6ZWRDaHVuayA9IG9wdGlvbnMubm9Db2xvclxuICAgICAgICAgID8gc3RyaXBBbnNpKGNodW5rLnRvTG9jYWxlU3RyaW5nKCkpXG4gICAgICAgICAgOiBjaHVuay50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICBwcm9jZXNzTG9nZ2VyRGVidWcoc2FuaXRpemVkQ2h1bmspO1xuICAgICAgICBvdXQucHVzaChzYW5pdGl6ZWRDaHVuayk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0ZGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjaGlsZC5zdGRlcnI/Lm9uKFwiZGF0YVwiLCAoY2h1bms6IHN0cmluZyB8IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgY29uc3Qgc2FuaXRpemVkQ2h1bmsgPSBvcHRpb25zLm5vQ29sb3JcbiAgICAgICAgICA/IHN0cmlwQW5zaShjaHVuay50b0xvY2FsZVN0cmluZygpKVxuICAgICAgICAgIDogY2h1bmsudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgcHJvY2Vzc0xvZ2dlckVycm9yKHNhbml0aXplZENodW5rKTtcbiAgICAgICAgaWYgKHNlbmRUb1N0ZGVycikge1xuICAgICAgICAgIHN0ZGVycihzYW5pdGl6ZWRDaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyLnB1c2goc2FuaXRpemVkQ2h1bmspO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkLnN0ZGVycj8ub24oXCJkYXRhXCIsIChjaHVuazogc3RyaW5nIHwgVWludDhBcnJheSkgPT4ge1xuICAgICAgICBjb25zdCBzYW5pdGl6ZWRDaHVuayA9IG9wdGlvbnMubm9Db2xvclxuICAgICAgICAgID8gc3RyaXBBbnNpKGNodW5rLnRvTG9jYWxlU3RyaW5nKCkpXG4gICAgICAgICAgOiBjaHVuay50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICBwcm9jZXNzTG9nZ2VyRXJyb3Ioc2FuaXRpemVkQ2h1bmspO1xuICAgICAgICBpZiAoc2VuZFRvU3RkZXJyKSB7XG4gICAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoc2FuaXRpemVkQ2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGVyci5wdXNoKHNhbml0aXplZENodW5rKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjaGlsZC5vbmNlKFwiZXJyb3JcIiwgKGVycjogYW55KSA9PiBrbyhlcnIpKTtcbiAgICBjaGlsZC5vbmNlKFwiY2xvc2VcIiwgKGNvZGU6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYG5vbi16ZXJvIGV4aXQgY29kZSAke2NvZGV9YCk7XG4gICAgICAgIChlcnJvciBhcyBhbnkpLnN0ZGVyciA9IGVyci5tYXAoKGNodW5rKSA9PiBjaHVuay50b1N0cmluZygpKS5qb2luKFwiXCIpO1xuICAgICAgICByZXR1cm4ga28oZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9rKG91dC5qb2luKFwiXCIpKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZENES1RGVmVyc2lvbihvdXRwdXREaXI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IG91dHB1dEZpbGUgPSBwYXRoLmpvaW4ob3V0cHV0RGlyLCBcImNkay50Zi5qc29uXCIpO1xuICBpZiAoZnMuZXhpc3RzU3luYyhvdXRwdXRGaWxlKSkge1xuICAgIGNvbnN0IG91dHB1dEpTT04gPSBmcy5yZWFkRmlsZVN5bmMob3V0cHV0RmlsZSwgXCJ1dGY4XCIpO1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKG91dHB1dEpTT04pO1xuICAgIHJldHVybiBkYXRhW1wiLy9cIl0ubWV0YWRhdGEudmVyc2lvbjtcbiAgfVxuXG4gIHJldHVybiBcIlwiO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZENES1RGTWFuaWZlc3QoKTogUHJvbWlzZTxJTWFuaWZlc3Q+IHtcbiAgY29uc3QgeyBvdXRwdXQgfSA9IGNvbmZpZy5yZWFkQ29uZmlnU3luYygpO1xuICBjb25zdCBqc29uID0gYXdhaXQgZnMucmVhZEZpbGUocGF0aC5qb2luKG91dHB1dCwgTWFuaWZlc3QuZmlsZU5hbWUpKTtcbiAgcmV0dXJuIEpTT04ucGFyc2UoanNvbi50b1N0cmluZygpKSBhcyBJTWFuaWZlc3Q7XG59XG5cbi8qKlxuICogRG93bmNhc2UgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gYmUgcHJvY2Vzc2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG93bmNhc2VGaXJzdChzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmIChzdHIgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHJldHVybiBgJHtzdHJbMF0udG9Mb2NhbGVMb3dlckNhc2UoKX0ke3N0ci5zbGljZSgxKX1gO1xufVxuXG5leHBvcnQgY2xhc3MgSHR0cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nLCBwdWJsaWMgc3RhdHVzQ29kZT86IG51bWJlcikge1xuICAgIHN1cGVyKG1lc3NhZ2UpOyAvLyAnRXJyb3InIGJyZWFrcyBwcm90b3R5cGUgY2hhaW4gaGVyZVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7IC8vIHJlc3RvcmUgcHJvdG90eXBlIGNoYWluXG4gICAgLy8gc2VlOiBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9yZWxlYXNlLW5vdGVzL3R5cGVzY3JpcHQtMi0yLmh0bWwjc3VwcG9ydC1mb3ItbmV3dGFyZ2V0XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkRmlsZShcbiAgdXJsOiBzdHJpbmcsXG4gIHRhcmdldEZpbGVuYW1lOiBzdHJpbmdcbik6IFByb21pc2U8dm9pZD4ge1xuICAvLyBpZiB0aGUgdHlwZSBpcyBpbmZlcnJlZCB0byBiZSBcImh0dHB8aHR0cHNcIiBjYWxsaW5nIC5nZXQoKSBpcyBub3QgcG9zc2libGVcbiAgLy8gYmVjYXVzZSB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgKHdoaWNoIHdlIGRvbid0IHVzZSBhbnl3YXkpIGZvciBnZXQgaXNcbiAgLy8gbm90IGNvbXBhdGlibGUgYmV0d2VlbiBodHRwIGFuZCBodHRwcyAtPiBzbyB3ZSB0cmVhdCBpdCBhcyBodHRwXG4gIGNvbnN0IGNsaWVudCA9ICh1cmwuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgPyBodHRwIDogaHR0cHMpIGFzIHR5cGVvZiBodHRwO1xuICBjb25zdCBmaWxlID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0odGFyZ2V0RmlsZW5hbWUpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKG9rLCBrbykgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnQuZ2V0KHVybCwgKHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgIGtvKFxuICAgICAgICAgIG5ldyBIdHRwRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGdldCAnJHt1cmx9JyAoJHtyZXNwb25zZS5zdGF0dXNDb2RlfSlgLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzQ29kZVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2UucGlwZShmaWxlKTtcbiAgICB9KTtcblxuICAgIGZpbGUub24oXCJmaW5pc2hcIiwgKCkgPT4gb2soKSk7XG5cbiAgICByZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgKGVycjogRXJyb3IpID0+IHtcbiAgICAgIGZzLnVubGluayh0YXJnZXRGaWxlbmFtZSwgKCkgPT4ga28oZXJyKSk7XG4gICAgfSk7XG5cbiAgICBmaWxlLm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgZnMudW5saW5rKHRhcmdldEZpbGVuYW1lLCAoKSA9PiBrbyhlcnIpKTtcbiAgICB9KTtcblxuICAgIHJlcXVlc3QuZW5kKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEF3YWl0cyBhIHByb21pc2UgYW5kIG1ha2VzIHN1cmUgaXQncyBlcnJvciAoaWYgYW55KSBpcyBvbmx5IHRocm93biBhZnRlciBhbGwgb3RoZXIgcHJvbWlzZXMgYXJlIHNldHRsZWRcbiAqIGlmIHRoZSBwcm9taXNlIGRvZXMgbm90IHRocm93IGFuIGVycm9yLCB0aGUgb3RoZXIgcHJvbWlzZXMgd29uJ3QgYmUgYXdhaXRlZFxuICogQHBhcmFtIHAgcHJvbWlzZSB0byBhd2FpdFxuICogQHBhcmFtIHByb21pc2VzIHByb21pc2VzIHRvIGF3YWl0IHRvIGJlIGFsbCBzZXR0bGVkIGlmIHAgZmFpbGVkIGJlZm9yZSB0aHJvd2luZyBlcnJvciB0aGF0IHAgZmFpbGVkIHdpdGhcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuc3VyZUFsbFNldHRsZWRCZWZvcmVUaHJvd2luZyhcbiAgcDogUHJvbWlzZTxhbnk+LFxuICBwcm9taXNlczogKFByb21pc2U8YW55PiB8IHVuZGVmaW5lZClbXVxuKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgcDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlmIGFuIGVycm9yIGhhcHBlbmVkLCB3ZSBzdGlsbCBuZWVkIHRvIHdhaXQgZm9yIGFsbCBvdGhlciBwcm9taXNlcyB0aGF0XG4gICAgLy8gYXJlIGN1cnJlbnRseSBpbiBwcm9ncmVzcyB0byBjb21wbGV0ZSB0byBhbGxvdyB0aGVtIHRvIHByb3Blcmx5IHdyYXAgdXBcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpO1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxuLyoqXG4gKiByZXR1cm5zIHRydWUgaWYgLS1uby1jb2xvciBpcyBwYXNzZWQgYXMgQ0xJIGZsYWcgb3IgdGhlIGVudiB2YXIgRk9SQ0VfQ09MT1IgaXMgc2V0IHRvIFwiMFwiXG4gKiBVc2VkIGZvciBjYXNlcyB3aGVyZSB3ZSBjYW4ndCBwYXNzIGRvd24gdGhlIG5vQ29sb3IgZmxhZyAoZS5nLiB3aGVuIGNvbGxlY3RpbmcgZGVidWcgaW5mb3JtYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQpXG4gKiBUaGlzIGlzIHRoZSBzYW1lIGJlaGF2aW9yIGFzIHRoZSBgY2hhbGtgIGxpYiB3ZSB1c2UgZm9yIGNvbG9yaW5nIG91dHB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzTm9Db2xvckZsYWdPckVudigpOiBib29sZWFuIHtcbiAgcmV0dXJuIGhhc0ZsYWcoXCJuby1jb2xvclwiKSB8fCBwcm9jZXNzLmVudi5GT1JDRV9DT0xPUiA9PT0gXCIwXCI7XG59XG5cbi8vIEZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvaGFzLWZsYWcvYmxvYi9tYWluL2luZGV4LmpzXG4vLyBhcyB1c2VkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFsay9jaGFsa1xuZnVuY3Rpb24gaGFzRmxhZyhmbGFnOiBzdHJpbmcpIHtcbiAgY29uc3QgcHJlZml4ID0gZmxhZy5zdGFydHNXaXRoKFwiLVwiKSA/IFwiXCIgOiBmbGFnLmxlbmd0aCA9PT0gMSA/IFwiLVwiIDogXCItLVwiO1xuICBjb25zdCBwb3NpdGlvbiA9IHByb2Nlc3MuYXJndi5pbmRleE9mKHByZWZpeCArIGZsYWcpO1xuICBjb25zdCB0ZXJtaW5hdG9yUG9zaXRpb24gPSBwcm9jZXNzLmFyZ3YuaW5kZXhPZihcIi0tXCIpO1xuICByZXR1cm4gKFxuICAgIHBvc2l0aW9uICE9PSAtMSAmJlxuICAgICh0ZXJtaW5hdG9yUG9zaXRpb24gPT09IC0xIHx8IHBvc2l0aW9uIDwgdGVybWluYXRvclBvc2l0aW9uKVxuICApO1xufVxuIl19