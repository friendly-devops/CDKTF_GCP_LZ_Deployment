"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageManager = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const commons_1 = require("@cdktf/commons");
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
const xml_js_1 = require("xml-js");
const fs = __importStar(require("fs-extra"));
const semver = __importStar(require("semver"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const z = __importStar(require("zod"));
// Can't use CDKTF_ as prefix because yargs .env("CDKTF") in strict mode does not allow us to
// Refer to: https://github.com/yargs/yargs/issues/873
const { GITHUB_API_TOKEN_CDKTF } = process.env;
// {
//   "version": "1.0.0",
//   "name": "testUSHasF",
//   "problems": [
//     "extraneous: archiver-utils@2.1.0 /private/var/folders/z_/v03l33d55fb57nrr3b1q03ch0000gq/T/testUSHasF/node_modules/archiver-utils",
//   ],
//   "dependencies": {
//     "@cdktf/provider-random": {
//       "version": "3.0.11",
//       "resolved": "https://registry.npmjs.org/@cdktf/provider-random/-/provider-random-3.0.11.tgz"
//     },
const npmListSchema = z
    .object({
    dependencies: z.record(z
        .object({
        version: z.string(),
    })
        .nonstrict()),
})
    .deepPartial()
    .nonstrict();
// {
//   "type": "tree",
//   "data": {
//     "type": "list",
//     "trees": [
//       {
//         "name": "@cdktf/provider-random@3.0.11",
//         "children": [],
//         "hint": null,
//         "color": "bold",
//         "depth": 0
//       }
//     ]
//   }
// }
const yarnListSchema = z
    .object({
    data: z
        .object({
        trees: z.array(z
            .object({
            name: z.string(),
        })
            .nonstrict()),
    })
        .nonstrict(),
})
    .deepPartial()
    .nonstrict();
// [
//   {
//     "name": "appdirs",
//     "version": "1.4.4"
//   },
//   {
const pipPackageSchema = z.array(z.object({ name: z.string(), version: z.string() }).nonstrict());
/**
 * manages installing, updating, and removing dependencies
 * in the package system used by the target language of a CDKTF
 * project
 */
class PackageManager {
    constructor(workingDirectory) {
        this.workingDirectory = workingDirectory;
    }
    static forLanguage(language, workingDirectory) {
        switch (language) {
            case commons_1.Language.GO:
                return new GoPackageManager(workingDirectory);
            case commons_1.Language.TYPESCRIPT:
                return new NodePackageManager(workingDirectory);
            case commons_1.Language.PYTHON:
                return new PythonPackageManager(workingDirectory);
            case commons_1.Language.CSHARP:
                return new NugetPackageManager(workingDirectory);
            case commons_1.Language.JAVA:
                if (GradlePackageManager.isGradleProject(workingDirectory)) {
                    return new GradlePackageManager(workingDirectory);
                }
                return new MavenPackageManager(workingDirectory);
            default:
                throw new Error(`Unknown language: ${language}`);
        }
    }
}
exports.PackageManager = PackageManager;
class NodePackageManager extends PackageManager {
    hasYarnLockfile() {
        return (0, fs_extra_1.existsSync)(path_1.default.join(this.workingDirectory, "yarn.lock"));
    }
    async addPackage(packageName, packageVersion, silent) {
        console.log(`Adding package ${packageName} @ ${packageVersion}`);
        // probe for package-lock.json or yarn.lock
        let command = "npm";
        let args = ["install"];
        if (this.hasYarnLockfile()) {
            command = "yarn";
            args = ["add"];
        }
        args.push(packageVersion ? packageName + "@" + packageVersion : packageName);
        if (silent) {
            args.push("--silent");
            args.push("--no-progress");
        }
        // Install exact version
        // Yarn: https://classic.yarnpkg.com/lang/en/docs/cli/add/#toc-yarn-add-exact-e
        // Npm: https://docs.npmjs.com/cli/v8/commands/npm-install#save-exact
        args.push("-E");
        commons_1.logger.info(`Installing package ${packageName} @ ${packageVersion} using ${command}.`);
        await (0, commons_1.exec)(command, args, { cwd: this.workingDirectory });
        commons_1.logger.info("Package installed.");
    }
    async isNpmVersionAvailable(_packageName, _packageVersion) {
        // We get the list of available versions from npm, no need to check here
        return true;
    }
    async listYarnPackages() {
        var _a;
        try {
            const stdout = await (0, commons_1.exec)("yarn", ["list", "--json"], {
                cwd: this.workingDirectory,
            });
            commons_1.logger.debug(`Listing yarn packages using "yarn list --json": ${stdout}`);
            const json = yarnListSchema.parse(JSON.parse(stdout));
            return (((_a = json === null || json === void 0 ? void 0 : json.data) === null || _a === void 0 ? void 0 : _a.trees) || [])
                .filter((dep) => dep.name.startsWith("@cdktf/provider-"))
                .map((dep) => ({
                name: `@${dep.name.split("@")[1]}`,
                version: dep.name.split("@")[2],
            }));
        }
        catch (e) {
            throw new Error(`Could not determine installed packages using 'yarn list --json': ${e.message}`);
        }
    }
    async listNpmPackages() {
        try {
            const stdout = await (0, commons_1.exec)("npm", ["list", "--json"], {
                cwd: this.workingDirectory,
            });
            commons_1.logger.debug(`Listing npm packages using "npm list --json": ${stdout}`);
            const json = npmListSchema.parse(JSON.parse(stdout));
            return Object.entries((json === null || json === void 0 ? void 0 : json.dependencies) || {})
                .filter(([depName]) => depName.startsWith("@cdktf/provider-"))
                .map(([name, dep]) => ({ name, version: dep.version }));
        }
        catch (e) {
            throw new Error(`Could not determine installed packages using 'npm list --json': ${e.message}`);
        }
    }
    async listProviderPackages() {
        return this.hasYarnLockfile()
            ? this.listYarnPackages()
            : this.listNpmPackages();
    }
}
class PythonPackageManager extends PackageManager {
    get appCommand() {
        try {
            return JSON.parse(fs.readFileSync(path_1.default.resolve(this.workingDirectory, "cdktf.json"), "utf8"))["app"];
        }
        catch (e) {
            throw commons_1.Errors.Usage(`Could not find find and parse cdktf.json in ${this.workingDirectory}`, e);
        }
    }
    async addPackage(packageName, packageVersion) {
        const usePipenv = this.appCommand.includes("pipenv");
        if (usePipenv) {
            console.log(`Installing package ${packageName} @ ${packageVersion} using pipenv.`);
            await (0, commons_1.exec)("pipenv", ["install", `${packageName}~=${packageVersion}`], {
                cwd: this.workingDirectory,
                env: {
                    ...process.env,
                    PIPENV_QUIET: "1",
                },
                stdio: ["inherit", 1, 1],
            });
            console.log("Package installed.");
        }
        else {
            console.log(`Installing package ${packageName} @ ${packageVersion} using pip.`);
            const requirementsFilePath = path_1.default.join(this.workingDirectory, "requirements.txt");
            if (!fs.existsSync(requirementsFilePath)) {
                throw commons_1.Errors.Usage(`Could not find requirements.txt in ${this.workingDirectory}`);
            }
            const requirements = await fs.readFile(requirementsFilePath, "utf8");
            const requirementLine = requirements
                .split("\n")
                .find((line) => line.includes(packageName));
            commons_1.logger.debug(`Read requirements.txt file and found line including ${packageName}: ${requirementLine}`);
            if (requirementLine) {
                if (packageVersion ? requirementLine.includes(packageVersion) : true) {
                    commons_1.logger.info(`Package ${packageName} already installed. Skipping installation.`);
                    return;
                }
                else {
                    commons_1.logger.debug(`Found the package but with a different version, continuing`);
                }
            }
            const newRequirements = requirements
                .split("\n")
                .filter((line) => !line.startsWith(packageName))
                .join("\n") +
                `\n${packageName}${packageVersion ? `~=${packageVersion}` : ""}`;
            await fs.writeFile(requirementsFilePath, newRequirements, "utf8");
            await (0, commons_1.exec)("pip", ["install", "-r", "requirements.txt"], {
                cwd: this.workingDirectory,
                stdio: ["inherit", 1, 1],
            });
            console.log("Package installed.");
        }
    }
    async isNpmVersionAvailable(packageName, packageVersion) {
        commons_1.logger.debug(`Checking if ${packageName}@${packageVersion} is available for Python`);
        const url = `https://pypi.org/pypi/${packageName}/${packageVersion}/json`;
        commons_1.logger.debug(`Fetching package information for ${packageName} from ${url}`);
        const response = await (0, node_fetch_1.default)(url);
        const json = (await response.json());
        commons_1.logger.debug(`Got response from PyPI for ${packageName}@${packageVersion}: ${JSON.stringify(json)}`);
        if (json.info) {
            // We found the version, so it exists
            return true;
        }
        else {
            commons_1.logger.debug(`Could not get PyPI package info, got: ${JSON.stringify(json)}`);
            return false;
        }
    }
    async listPipenvPackages() {
        try {
            const stdout = await (0, commons_1.exec)("pipenv", ["run", "pip", "list", "--format=json"], {
                cwd: this.workingDirectory,
            });
            commons_1.logger.debug(`Listing pipenv packages using "pipenv run pip list --format=json": ${stdout}`);
            const list = pipPackageSchema.parse(JSON.parse(stdout));
            return list.filter((item) => item.name.startsWith("cdktf-cdktf-provider"));
        }
        catch (e) {
            throw new Error(`Could not determine installed packages using 'pipenv run pip list --format=json': ${e.message}`);
        }
    }
    async listPipPackages() {
        try {
            const stdout = await (0, commons_1.exec)("pip", ["list", "--format=json"], {
                cwd: this.workingDirectory,
            });
            commons_1.logger.debug(`Listing pipenv packages using "pip list --format=json": ${stdout}`);
            const list = pipPackageSchema.parse(JSON.parse(stdout));
            return list.filter((item) => item.name.startsWith("cdktf-cdktf-provider"));
        }
        catch (e) {
            throw new Error(`Could not determine installed packages using 'pip list --format=json': ${e.message}`);
        }
    }
    async listProviderPackages() {
        return this.appCommand.includes("pipenv")
            ? this.listPipenvPackages()
            : this.listPipPackages();
    }
}
class NugetPackageManager extends PackageManager {
    async addPackage(packageName, packageVersion) {
        const command = "dotnet";
        const args = ["add", "package", packageName];
        if (packageVersion) {
            args.push("--version", packageVersion);
        }
        console.log(`Installing package ${packageName} @ ${packageVersion} using "${command} ${args.join(" ")}".`);
        await (0, commons_1.exec)(command, args, { cwd: this.workingDirectory });
        console.log("Package installed.");
    }
    async isNpmVersionAvailable(packageName, packageVersion) {
        var _a, _b, _c;
        commons_1.logger.debug(`Checking if ${packageName}@${packageVersion} is available`);
        const [owner, ...rest] = packageName.split(".");
        const id = rest[rest.length - 1];
        const url = `https://azuresearch-usnc.nuget.org/query?q=owner:${owner}%20id:${id}&prerelease=false&semVerLevel=2.0.0`;
        commons_1.logger.debug(`Fetching package metadata from Nuget: '${url}'`);
        const response = await (0, node_fetch_1.default)(url);
        const json = (await response.json());
        commons_1.logger.debug(`Got response from NuGet for ${packageName} : ${JSON.stringify(json)}`);
        if (!((_a = json === null || json === void 0 ? void 0 : json.data) === null || _a === void 0 ? void 0 : _a.length)) {
            return false; // No package found
        }
        const packageVersions = (_c = (_b = json.data.find((p) => p.id === packageName)) === null || _b === void 0 ? void 0 : _b.versions) !== null && _c !== void 0 ? _c : [];
        if (!packageVersions.length) {
            return false; // No package release matching the id found
        }
        return packageVersions.some((v) => v.version === packageVersion);
    }
    async listProviderPackages() {
        try {
            const stdout = await (0, commons_1.exec)("dotnet", ["list", "package"], {
                cwd: this.workingDirectory,
            });
            commons_1.logger.debug(`Listing pipenv packages using "dotnet list package": ${stdout}`);
            const regex = /^\s*>\s(HashiCorp\.Cdktf\.Providers\.[\w.]+)\s+((?:\d+\.){2}\d+(?:-\S+)?)\s+((?:\d+\.){2}\d+(?:-\S+)?)\s*$/;
            return stdout
                .split("\n")
                .map((line) => {
                // Example output:
                // Project 'MyTerraformStack' has the following package references
                //  [net6.0]:
                //  Top-level Package      Requested   Resolved
                //  > HashiCorp.Cdktf      0.0.0       0.0.0
                // match[0] = full match
                // match[1] = package name
                // match[2] = requested version
                // match[3] = resolved version
                return regex.exec(line);
            })
                .filter((match) => !!match)
                .map((match) => ({ name: match[1], version: match[3] }));
        }
        catch (e) {
            throw new Error(`Could not determine installed packages using 'dotnet list package': ${e.message}`);
        }
    }
}
class JavaPackageManager extends PackageManager {
    async isNpmVersionAvailable(packageName, packageVersion) {
        var _a, _b;
        commons_1.logger.debug(`Checking if ${packageName}@${packageVersion} is available`);
        const parts = packageName.split(".");
        if (parts.length !== 3) {
            throw commons_1.Errors.Internal(`Expected package name to be in format "group.artifact", e.g. "com.hashicorp.cdktf-provider-google", got: ${packageName}`);
        }
        const packageIdentifier = parts.pop();
        const groupId = parts.join(".");
        const url = `https://search.maven.org/solrsearch/select?q=g:${groupId}+AND+a:${packageIdentifier}+AND+v:${packageVersion}&rows=5&wt=json`;
        commons_1.logger.debug(`Trying to find package version by querying Maven Central under '${url}'`);
        const response = await (0, node_fetch_1.default)(url);
        const json = (await response.json());
        commons_1.logger.debug(`Got response from the Maven package search for ${packageName}: ${JSON.stringify(json)}`);
        return ((_b = (_a = json === null || json === void 0 ? void 0 : json.response) === null || _a === void 0 ? void 0 : _a.numFound) !== null && _b !== void 0 ? _b : 0) > 0;
    }
}
class MavenPackageManager extends JavaPackageManager {
    async addPackage(packageName, packageVersion = "LATEST" // the latest option is deprecated in maven 3.5
    ) {
        var _a, _b, _c, _d;
        console.log(`Adding ${packageName} @ ${packageVersion} to pom.xml`);
        // Assert pom.xml exists
        const pomPath = path_1.default.join(this.workingDirectory, "pom.xml");
        if (!(0, fs_extra_1.existsSync)(pomPath)) {
            throw commons_1.Errors.Usage("No pom.xml found in current working directory. Please run the command from the root of your project.");
        }
        const pom = await fs.readFile(pomPath, "utf8");
        const pomXml = (await (0, xml_js_1.xml2js)(pom, {}));
        // Mutate dependencies
        const nameParts = packageName.split(".");
        const groupId = nameParts.slice(0, nameParts.length - 1).join(".");
        const artifactId = nameParts[nameParts.length - 1];
        const newDependency = (await (0, xml_js_1.xml2js)(`<dependency>
    <groupId>${groupId}</groupId>
    <artifactId>${artifactId}</artifactId>
    <version>${packageVersion}</version>
</dependency>`));
        const dependencies = (_c = (_b = (_a = pomXml.elements) === null || _a === void 0 ? void 0 : _a.find((el) => el.name === "project")) === null || _b === void 0 ? void 0 : _b.elements) === null || _c === void 0 ? void 0 : _c.find((el) => el.name === "dependencies");
        if (!dependencies) {
            throw commons_1.Errors.Usage(`Could not find dependencies section in the pom.xml`);
        }
        dependencies.elements = ((dependencies === null || dependencies === void 0 ? void 0 : dependencies.elements) || []).filter((el) => {
            var _a, _b;
            return ((_a = el.elements) === null || _a === void 0 ? void 0 : _a.some((group) => { var _a; return group.name === "groupId" && ((_a = group.elements) === null || _a === void 0 ? void 0 : _a[0].text) !== groupId; })) ||
                ((_b = el.elements) === null || _b === void 0 ? void 0 : _b.some((artifact) => {
                    var _a;
                    return artifact.name === "artifactId" &&
                        ((_a = artifact.elements) === null || _a === void 0 ? void 0 : _a[0].text) !== artifactId;
                }));
        });
        (_d = dependencies === null || dependencies === void 0 ? void 0 : dependencies.elements) === null || _d === void 0 ? void 0 : _d.push(newDependency.elements[0]);
        // Write new pom.xml
        await fs.writeFile(pomPath, (0, xml_js_1.js2xml)(pomXml, { spaces: 2 }));
        // Install
        await (0, commons_1.exec)("mvn", ["install"], { cwd: this.workingDirectory });
        console.log("Package installed.");
    }
    async listProviderPackages() {
        var _a, _b, _c, _d, _e;
        try {
            const pomPath = path_1.default.join(this.workingDirectory, "pom.xml");
            if (!(0, fs_extra_1.existsSync)(pomPath)) {
                throw commons_1.Errors.Usage("No pom.xml found in current working directory. Please run the command from the root of your project.");
            }
            const pom = await fs.readFile(pomPath, "utf8");
            const pomXml = (await (0, xml_js_1.xml2js)(pom, {}));
            const dependencies = (_e = (_d = (_c = (_b = (_a = pomXml.elements) === null || _a === void 0 ? void 0 : _a.find((el) => el.name === "project")) === null || _b === void 0 ? void 0 : _b.elements) === null || _c === void 0 ? void 0 : _c.find((el) => el.name === "dependencies")) === null || _d === void 0 ? void 0 : _d.elements) !== null && _e !== void 0 ? _e : [];
            return dependencies
                .map((dep) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j;
                return ({
                    name: `${(_c = (_b = (_a = dep.elements) === null || _a === void 0 ? void 0 : _a.find((el) => el.name === "groupId")) === null || _b === void 0 ? void 0 : _b.elements) === null || _c === void 0 ? void 0 : _c[0].text}.${(_f = (_e = (_d = dep.elements) === null || _d === void 0 ? void 0 : _d.find((el) => el.name === "artifactId")) === null || _e === void 0 ? void 0 : _e.elements) === null || _f === void 0 ? void 0 : _f[0].text}`,
                    version: (_j = (_h = (_g = dep.elements) === null || _g === void 0 ? void 0 : _g.find((el) => el.name === "version")) === null || _h === void 0 ? void 0 : _h.elements) === null || _j === void 0 ? void 0 : _j[0].text,
                });
            })
                .filter((dep) => dep.name.startsWith("com.hashicorp.cdktf-provider-"));
        }
        catch (e) {
            throw new Error(`Could not determine installed packages reading the pom.xml: ${e.message}`);
        }
    }
}
class GradlePackageManager extends JavaPackageManager {
    static isGradleProject(workingDirectory) {
        return (0, commons_1.isGradleProject)(workingDirectory);
    }
    async addPackage(packageFQN, packageVersion = "latest.release") {
        const buildGradlePath = path_1.default.join(this.workingDirectory, "build.gradle");
        const buildGradle = await fs.readFile(buildGradlePath, "utf8");
        const buildGradleLines = buildGradle.split(/\r?\n/);
        const dependenciesRegex = /dependencies\s+\{/i;
        const dependencyBlockStart = buildGradleLines.findIndex((line) => dependenciesRegex.test(line));
        if (dependencyBlockStart === -1) {
            throw commons_1.Errors.Usage("Could not find dependencies section in the build.gradle");
        }
        const packageSegments = packageFQN.split(".");
        const packageName = packageSegments.pop();
        const groupName = packageSegments.join(".");
        const dependencySpecifier = `${groupName}:${packageName}`;
        const dependencyAndVersionSpecifier = `${dependencySpecifier}:${packageVersion}`;
        const existingDependency = buildGradleLines.findIndex((line) => line.includes(dependencySpecifier));
        if (existingDependency !== -1) {
            buildGradleLines.splice(existingDependency, 1);
        }
        const newPackageDependency = `\timplementation '${dependencyAndVersionSpecifier}'`;
        buildGradleLines.splice(dependencyBlockStart + 1, 0, newPackageDependency);
        await fs.writeFile(buildGradlePath, buildGradleLines.join("\n"));
    }
    async listProviderPackages() {
        const dependencies = await (0, commons_1.getGradleDependencies)();
        if (!dependencies) {
            throw commons_1.Errors.Usage("Could not find any dependencies");
        }
        const dependencyList = dependencies
            .map((line) => (0, commons_1.getDependencyInformationFromLine)(line))
            .filter((dep) => {
            if (!dep) {
                return false;
            }
            return dep.name.includes("cdktf-provider-");
        })
            .map((dep) => ({
            name: `com.hashicorp.${dep.name}`,
            version: dep.version,
        }));
        return dependencyList;
    }
}
class GoPackageManager extends PackageManager {
    async addPackage(packageName, packageVersion) {
        console.log(`Adding package ${packageName} @ ${packageVersion}`);
        const majorVersion = packageVersion
            ? semver.major(packageVersion)
            : undefined;
        let versionPackageSuffix = "";
        if (typeof majorVersion === "number" && majorVersion > 1) {
            versionPackageSuffix = `/v${majorVersion}`;
        }
        commons_1.logger.debug(`Running 'go get ${packageName}${versionPackageSuffix}@v${packageVersion}'`);
        // Install
        await (0, commons_1.exec)("go", ["get", `${packageName}${versionPackageSuffix}@v${packageVersion}`], {
            cwd: this.workingDirectory,
        });
        console.log("Package installed.");
    }
    async isNpmVersionAvailable(packageName, packageVersion) {
        commons_1.logger.debug(`Checking if ${packageName}@${packageVersion} is available`);
        // e.g. github.com/cdktf/cdktf-provider-google-go/google
        const parts = packageName.split("/");
        if (parts.length !== 4) {
            throw commons_1.Errors.Internal(`Expecting Go package name to be in the format of github.com/<org>/<repo>/<package>, got ${packageName}`);
        }
        const org = parts[1];
        const repo = parts[2];
        const packagePath = parts[3];
        const url = `https://api.github.com/repos/${org}/${repo}/git/ref/tags/${packagePath}/v${packageVersion}`;
        commons_1.logger.debug(`Fetching tags for ${org}/${repo} from '${url}'`);
        const response = await (0, node_fetch_1.default)(url, {
            headers: {
                Accept: "application/vnd.github+json",
                "User-Agent": "HashiCorp/cdktf-cli",
                ...(GITHUB_API_TOKEN_CDKTF
                    ? { Authorization: `Bearer ${GITHUB_API_TOKEN_CDKTF}` }
                    : {}),
            },
        });
        const json = (await response.json());
        commons_1.logger.debug(`Got response from GitHubs repository tag endpoint for ${packageName}: ${JSON.stringify(json)}`);
        if (json && json.ref) {
            return true;
        }
        commons_1.logger.info(`Could not find the tag ${packagePath}/v${packageVersion} in the repository ${org}/${repo}: ${JSON.stringify(json)}}`);
        return false;
    }
    async listProviderPackages() {
        try {
            const goSumPath = path_1.default.join(this.workingDirectory, "go.sum");
            if (!(0, fs_extra_1.existsSync)(goSumPath)) {
                throw commons_1.Errors.Usage("No go.sum found in current working directory. Please run the command from the root of your project.");
            }
            const goSum = await fs.readFile(goSumPath, "utf8");
            const dedupedProviderNames = new Set();
            return goSum
                .split("\n")
                .filter((line) => line.startsWith("github.com/hashicorp/cdktf-provider") ||
                line.startsWith("github.com/cdktf/cdktf-provider"))
                .map((line) => {
                const parts = line.split(" ");
                if (parts.length !== 3) {
                    throw commons_1.Errors.Internal(`Expected line in go.sum to be in the format of '<package> <version> <checksum>', got: ${line}`);
                }
                // part[0] could be github.com/aws/constructs-go/constructs/v10
                const name = parts[0].split("/").slice(0, 4).join("/");
                const version = parts[1].split("/")[0];
                if (dedupedProviderNames.has(name)) {
                    return { name: "", version: "" };
                }
                dedupedProviderNames.add(name);
                return {
                    name,
                    version,
                };
            })
                .filter((providerInfo) => !!providerInfo.name && !!providerInfo.version);
        }
        catch (e) {
            throw new Error(`Could not determine installed packages reading the go.sum: ${e.message}`);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZS1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFja2FnZS1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyw0Q0FRd0I7QUFDeEIsdUNBQXNDO0FBQ3RDLGdEQUF3QjtBQUN4QixtQ0FBaUQ7QUFDakQsNkNBQStCO0FBQy9CLCtDQUFpQztBQUNqQyw0REFBK0I7QUFDL0IsdUNBQXlCO0FBRXpCLDZGQUE2RjtBQUM3RixzREFBc0Q7QUFDdEQsTUFBTSxFQUFFLHNCQUFzQixFQUFFLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQztBQUUvQyxJQUFJO0FBQ0osd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQixrQkFBa0I7QUFDbEIsMElBQTBJO0FBQzFJLE9BQU87QUFDUCxzQkFBc0I7QUFDdEIsa0NBQWtDO0FBQ2xDLDZCQUE2QjtBQUM3QixxR0FBcUc7QUFDckcsU0FBUztBQUNULE1BQU0sYUFBYSxHQUFHLENBQUM7S0FDcEIsTUFBTSxDQUFDO0lBQ04sWUFBWSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQ3BCLENBQUM7U0FDRSxNQUFNLENBQUM7UUFDTixPQUFPLEVBQUUsQ0FBQyxDQUFDLE1BQU0sRUFBRTtLQUNwQixDQUFDO1NBQ0QsU0FBUyxFQUFFLENBQ2Y7Q0FDRixDQUFDO0tBQ0QsV0FBVyxFQUFFO0tBQ2IsU0FBUyxFQUFFLENBQUM7QUFFZixJQUFJO0FBQ0osb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZCxzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCLFVBQVU7QUFDVixtREFBbUQ7QUFDbkQsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCLFVBQVU7QUFDVixRQUFRO0FBQ1IsTUFBTTtBQUNOLElBQUk7QUFDSixNQUFNLGNBQWMsR0FBRyxDQUFDO0tBQ3JCLE1B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LEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFFdkQsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFFdkMsSUFBSSxvQkFBb0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7b0JBQ2xDLE9BQU8sRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsQ0FBQztpQkFDbEM7Z0JBRUQsb0JBQW9CLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUUvQixPQUFPO29CQUNMLElBQUk7b0JBQ0osT0FBTztpQkFDUixDQUFDO1lBQ0osQ0FBQyxDQUFDO2lCQUNELE1BQU0sQ0FDTCxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQ2hFLENBQUM7U0FDTDtRQUFDLE9BQU8sQ0FBTSxFQUFFO1lBQ2YsTUFBTSxJQUFJLEtBQUssQ0FDYiw4REFBOEQsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUMxRSxDQUFDO1NBQ0g7SUFDSCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuaW1wb3J0IHtcbiAgTGFuZ3VhZ2UsXG4gIGV4ZWMsXG4gIEVycm9ycyxcbiAgbG9nZ2VyLFxuICBpc0dyYWRsZVByb2plY3QsXG4gIGdldEdyYWRsZURlcGVuZGVuY2llcyxcbiAgZ2V0RGVwZW5kZW5jeUluZm9ybWF0aW9uRnJvbUxpbmUsXG59IGZyb20gXCJAY2RrdGYvY29tbW9uc1wiO1xuaW1wb3J0IHsgZXhpc3RzU3luYyB9IGZyb20gXCJmcy1leHRyYVwiO1xuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IHhtbDJqcywganMyeG1sLCBFbGVtZW50IH0gZnJvbSBcInhtbC1qc1wiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzLWV4dHJhXCI7XG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSBcInNlbXZlclwiO1xuaW1wb3J0IGZldGNoIGZyb20gXCJub2RlLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB6IGZyb20gXCJ6b2RcIjtcblxuLy8gQ2FuJ3QgdXNlIENES1RGXyBhcyBwcmVmaXggYmVjYXVzZSB5YXJncyAuZW52KFwiQ0RLVEZcIikgaW4gc3RyaWN0IG1vZGUgZG9lcyBub3QgYWxsb3cgdXMgdG9cbi8vIFJlZmVyIHRvOiBodHRwczovL2dpdGh1Yi5jb20veWFyZ3MveWFyZ3MvaXNzdWVzLzg3M1xuY29uc3QgeyBHSVRIVUJfQVBJX1RPS0VOX0NES1RGIH0gPSBwcm9jZXNzLmVudjtcblxuLy8ge1xuLy8gICBcInZlcnNpb25cIjogXCIxLjAuMFwiLFxuLy8gICBcIm5hbWVcIjogXCJ0ZXN0VVNIYXNGXCIsXG4vLyAgIFwicHJvYmxlbXNcIjogW1xuLy8gICAgIFwiZXh0cmFuZW91czogYXJjaGl2ZXItdXRpbHNAMi4xLjAgL3ByaXZhdGUvdmFyL2ZvbGRlcnMvel8vdjAzbDMzZDU1ZmI1N25ycjNiMXEwM2NoMDAwMGdxL1QvdGVzdFVTSGFzRi9ub2RlX21vZHVsZXMvYXJjaGl2ZXItdXRpbHNcIixcbi8vICAgXSxcbi8vICAgXCJkZXBlbmRlbmNpZXNcIjoge1xuLy8gICAgIFwiQGNka3RmL3Byb3ZpZGVyLXJhbmRvbVwiOiB7XG4vLyAgICAgICBcInZlcnNpb25cIjogXCIzLjAuMTFcIixcbi8vICAgICAgIFwicmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9AY2RrdGYvcHJvdmlkZXItcmFuZG9tLy0vcHJvdmlkZXItcmFuZG9tLTMuMC4xMS50Z3pcIlxuLy8gICAgIH0sXG5jb25zdCBucG1MaXN0U2NoZW1hID0gelxuICAub2JqZWN0KHtcbiAgICBkZXBlbmRlbmNpZXM6IHoucmVjb3JkKFxuICAgICAgelxuICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICB2ZXJzaW9uOiB6LnN0cmluZygpLFxuICAgICAgICB9KVxuICAgICAgICAubm9uc3RyaWN0KClcbiAgICApLFxuICB9KVxuICAuZGVlcFBhcnRpYWwoKVxuICAubm9uc3RyaWN0KCk7XG5cbi8vIHtcbi8vICAgXCJ0eXBlXCI6IFwidHJlZVwiLFxuLy8gICBcImRhdGFcIjoge1xuLy8gICAgIFwidHlwZVwiOiBcImxpc3RcIixcbi8vICAgICBcInRyZWVzXCI6IFtcbi8vICAgICAgIHtcbi8vICAgICAgICAgXCJuYW1lXCI6IFwiQGNka3RmL3Byb3ZpZGVyLXJhbmRvbUAzLjAuMTFcIixcbi8vICAgICAgICAgXCJjaGlsZHJlblwiOiBbXSxcbi8vICAgICAgICAgXCJoaW50XCI6IG51bGwsXG4vLyAgICAgICAgIFwiY29sb3JcIjogXCJib2xkXCIsXG4vLyAgICAgICAgIFwiZGVwdGhcIjogMFxuLy8gICAgICAgfVxuLy8gICAgIF1cbi8vICAgfVxuLy8gfVxuY29uc3QgeWFybkxpc3RTY2hlbWEgPSB6XG4gIC5vYmplY3Qoe1xuICAgIGRhdGE6IHpcbiAgICAgIC5vYmplY3Qoe1xuICAgICAgICB0cmVlczogei5hcnJheShcbiAgICAgICAgICB6XG4gICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgbmFtZTogei5zdHJpbmcoKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAubm9uc3RyaWN0KClcbiAgICAgICAgKSxcbiAgICAgIH0pXG4gICAgICAubm9uc3RyaWN0KCksXG4gIH0pXG4gIC5kZWVwUGFydGlhbCgpXG4gIC5ub25zdHJpY3QoKTtcblxuLy8gW1xuLy8gICB7XG4vLyAgICAgXCJuYW1lXCI6IFwiYXBwZGlyc1wiLFxuLy8gICAgIFwidmVyc2lvblwiOiBcIjEuNC40XCJcbi8vICAgfSxcbi8vICAge1xuY29uc3QgcGlwUGFja2FnZVNjaGVtYSA9IHouYXJyYXkoXG4gIHoub2JqZWN0KHsgbmFtZTogei5zdHJpbmcoKSwgdmVyc2lvbjogei5zdHJpbmcoKSB9KS5ub25zdHJpY3QoKVxuKTtcblxuLyoqXG4gKiBtYW5hZ2VzIGluc3RhbGxpbmcsIHVwZGF0aW5nLCBhbmQgcmVtb3ZpbmcgZGVwZW5kZW5jaWVzXG4gKiBpbiB0aGUgcGFja2FnZSBzeXN0ZW0gdXNlZCBieSB0aGUgdGFyZ2V0IGxhbmd1YWdlIG9mIGEgQ0RLVEZcbiAqIHByb2plY3RcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBhY2thZ2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IHdvcmtpbmdEaXJlY3Rvcnk6IHN0cmluZykge31cblxuICBwdWJsaWMgc3RhdGljIGZvckxhbmd1YWdlKFxuICAgIGxhbmd1YWdlOiBMYW5ndWFnZSxcbiAgICB3b3JraW5nRGlyZWN0b3J5OiBzdHJpbmdcbiAgKTogUGFja2FnZU1hbmFnZXIge1xuICAgIHN3aXRjaCAobGFuZ3VhZ2UpIHtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuR086XG4gICAgICAgIHJldHVybiBuZXcgR29QYWNrYWdlTWFuYWdlcih3b3JraW5nRGlyZWN0b3J5KTtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuVFlQRVNDUklQVDpcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlUGFja2FnZU1hbmFnZXIod29ya2luZ0RpcmVjdG9yeSk7XG4gICAgICBjYXNlIExhbmd1YWdlLlBZVEhPTjpcbiAgICAgICAgcmV0dXJuIG5ldyBQeXRob25QYWNrYWdlTWFuYWdlcih3b3JraW5nRGlyZWN0b3J5KTtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuQ1NIQVJQOlxuICAgICAgICByZXR1cm4gbmV3IE51Z2V0UGFja2FnZU1hbmFnZXIod29ya2luZ0RpcmVjdG9yeSk7XG4gICAgICBjYXNlIExhbmd1YWdlLkpBVkE6XG4gICAgICAgIGlmIChHcmFkbGVQYWNrYWdlTWFuYWdlci5pc0dyYWRsZVByb2plY3Qod29ya2luZ0RpcmVjdG9yeSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEdyYWRsZVBhY2thZ2VNYW5hZ2VyKHdvcmtpbmdEaXJlY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWF2ZW5QYWNrYWdlTWFuYWdlcih3b3JraW5nRGlyZWN0b3J5KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsYW5ndWFnZTogJHtsYW5ndWFnZX1gKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYWJzdHJhY3QgYWRkUGFja2FnZShcbiAgICBwYWNrYWdlTmFtZTogc3RyaW5nLFxuICAgIHBhY2thZ2VWZXJzaW9uPzogc3RyaW5nLFxuICAgIHNpbGVudD86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTx2b2lkPjtcbiAgLy8gYWRkIGNoZWNrIGlmIHBhY2thZ2UgZXhpc3RzIGFscmVhZHkuIG1pZ2h0IHF1ZXJ5IHZlcnNpb24gaW4gdGhlIGZ1dHVyZSBhbmQgb2ZmZXIgdG8gdXBncmFkZT9cblxuICBwdWJsaWMgYWJzdHJhY3QgaXNOcG1WZXJzaW9uQXZhaWxhYmxlKFxuICAgIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gICAgcGFja2FnZVZlcnNpb246IHN0cmluZ1xuICApOiBQcm9taXNlPGJvb2xlYW4+O1xuXG4gIHB1YmxpYyBhYnN0cmFjdCBsaXN0UHJvdmlkZXJQYWNrYWdlcygpOiBQcm9taXNlPFxuICAgIHsgbmFtZTogc3RyaW5nOyB2ZXJzaW9uOiBzdHJpbmcgfVtdXG4gID47XG59XG5cbmNsYXNzIE5vZGVQYWNrYWdlTWFuYWdlciBleHRlbmRzIFBhY2thZ2VNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBoYXNZYXJuTG9ja2ZpbGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGV4aXN0c1N5bmMocGF0aC5qb2luKHRoaXMud29ya2luZ0RpcmVjdG9yeSwgXCJ5YXJuLmxvY2tcIikpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFkZFBhY2thZ2UoXG4gICAgcGFja2FnZU5hbWU6IHN0cmluZyxcbiAgICBwYWNrYWdlVmVyc2lvbj86IHN0cmluZyxcbiAgICBzaWxlbnQ/OiBib29sZWFuXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgcGFja2FnZSAke3BhY2thZ2VOYW1lfSBAICR7cGFja2FnZVZlcnNpb259YCk7XG5cbiAgICAvLyBwcm9iZSBmb3IgcGFja2FnZS1sb2NrLmpzb24gb3IgeWFybi5sb2NrXG4gICAgbGV0IGNvbW1hbmQgPSBcIm5wbVwiO1xuICAgIGxldCBhcmdzID0gW1wiaW5zdGFsbFwiXTtcblxuICAgIGlmICh0aGlzLmhhc1lhcm5Mb2NrZmlsZSgpKSB7XG4gICAgICBjb21tYW5kID0gXCJ5YXJuXCI7XG4gICAgICBhcmdzID0gW1wiYWRkXCJdO1xuICAgIH1cbiAgICBhcmdzLnB1c2goXG4gICAgICBwYWNrYWdlVmVyc2lvbiA/IHBhY2thZ2VOYW1lICsgXCJAXCIgKyBwYWNrYWdlVmVyc2lvbiA6IHBhY2thZ2VOYW1lXG4gICAgKTtcblxuICAgIGlmIChzaWxlbnQpIHtcbiAgICAgIGFyZ3MucHVzaChcIi0tc2lsZW50XCIpO1xuICAgICAgYXJncy5wdXNoKFwiLS1uby1wcm9ncmVzc1wiKTtcbiAgICB9XG5cbiAgICAvLyBJbnN0YWxsIGV4YWN0IHZlcnNpb25cbiAgICAvLyBZYXJuOiBodHRwczovL2NsYXNzaWMueWFybnBrZy5jb20vbGFuZy9lbi9kb2NzL2NsaS9hZGQvI3RvYy15YXJuLWFkZC1leGFjdC1lXG4gICAgLy8gTnBtOiBodHRwczovL2RvY3MubnBtanMuY29tL2NsaS92OC9jb21tYW5kcy9ucG0taW5zdGFsbCNzYXZlLWV4YWN0XG4gICAgYXJncy5wdXNoKFwiLUVcIik7XG5cbiAgICBsb2dnZXIuaW5mbyhcbiAgICAgIGBJbnN0YWxsaW5nIHBhY2thZ2UgJHtwYWNrYWdlTmFtZX0gQCAke3BhY2thZ2VWZXJzaW9ufSB1c2luZyAke2NvbW1hbmR9LmBcbiAgICApO1xuXG4gICAgYXdhaXQgZXhlYyhjb21tYW5kLCBhcmdzLCB7IGN3ZDogdGhpcy53b3JraW5nRGlyZWN0b3J5IH0pO1xuXG4gICAgbG9nZ2VyLmluZm8oXCJQYWNrYWdlIGluc3RhbGxlZC5cIik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaXNOcG1WZXJzaW9uQXZhaWxhYmxlKFxuICAgIF9wYWNrYWdlTmFtZTogc3RyaW5nLFxuICAgIF9wYWNrYWdlVmVyc2lvbjogc3RyaW5nXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIC8vIFdlIGdldCB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdmVyc2lvbnMgZnJvbSBucG0sIG5vIG5lZWQgdG8gY2hlY2sgaGVyZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsaXN0WWFyblBhY2thZ2VzKCk6IFByb21pc2U8XG4gICAgeyBuYW1lOiBzdHJpbmc7IHZlcnNpb246IHN0cmluZyB9W11cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0ZG91dCA9IGF3YWl0IGV4ZWMoXCJ5YXJuXCIsIFtcImxpc3RcIiwgXCItLWpzb25cIl0sIHtcbiAgICAgICAgY3dkOiB0aGlzLndvcmtpbmdEaXJlY3RvcnksXG4gICAgICB9KTtcblxuICAgICAgbG9nZ2VyLmRlYnVnKGBMaXN0aW5nIHlhcm4gcGFja2FnZXMgdXNpbmcgXCJ5YXJuIGxpc3QgLS1qc29uXCI6ICR7c3Rkb3V0fWApO1xuXG4gICAgICBjb25zdCBqc29uID0geWFybkxpc3RTY2hlbWEucGFyc2UoSlNPTi5wYXJzZShzdGRvdXQpKTtcblxuICAgICAgcmV0dXJuIChqc29uPy5kYXRhPy50cmVlcyB8fCBbXSlcbiAgICAgICAgLmZpbHRlcigoZGVwOiBhbnkpID0+IGRlcC5uYW1lLnN0YXJ0c1dpdGgoXCJAY2RrdGYvcHJvdmlkZXItXCIpKVxuICAgICAgICAubWFwKChkZXA6IGFueSkgPT4gKHtcbiAgICAgICAgICBuYW1lOiBgQCR7ZGVwLm5hbWUuc3BsaXQoXCJAXCIpWzFdfWAsXG4gICAgICAgICAgdmVyc2lvbjogZGVwLm5hbWUuc3BsaXQoXCJAXCIpWzJdLFxuICAgICAgICB9KSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDb3VsZCBub3QgZGV0ZXJtaW5lIGluc3RhbGxlZCBwYWNrYWdlcyB1c2luZyAneWFybiBsaXN0IC0tanNvbic6ICR7ZS5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsaXN0TnBtUGFja2FnZXMoKTogUHJvbWlzZTxcbiAgICB7IG5hbWU6IHN0cmluZzsgdmVyc2lvbjogc3RyaW5nIH1bXVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3Rkb3V0ID0gYXdhaXQgZXhlYyhcIm5wbVwiLCBbXCJsaXN0XCIsIFwiLS1qc29uXCJdLCB7XG4gICAgICAgIGN3ZDogdGhpcy53b3JraW5nRGlyZWN0b3J5LFxuICAgICAgfSk7XG5cbiAgICAgIGxvZ2dlci5kZWJ1ZyhgTGlzdGluZyBucG0gcGFja2FnZXMgdXNpbmcgXCJucG0gbGlzdCAtLWpzb25cIjogJHtzdGRvdXR9YCk7XG4gICAgICBjb25zdCBqc29uID0gbnBtTGlzdFNjaGVtYS5wYXJzZShKU09OLnBhcnNlKHN0ZG91dCkpO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoanNvbj8uZGVwZW5kZW5jaWVzIHx8IHt9KVxuICAgICAgICAuZmlsdGVyKChbZGVwTmFtZV0pID0+IGRlcE5hbWUuc3RhcnRzV2l0aChcIkBjZGt0Zi9wcm92aWRlci1cIikpXG4gICAgICAgIC5tYXAoKFtuYW1lLCBkZXBdKSA9PiAoeyBuYW1lLCB2ZXJzaW9uOiBkZXAudmVyc2lvbiB9KSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDb3VsZCBub3QgZGV0ZXJtaW5lIGluc3RhbGxlZCBwYWNrYWdlcyB1c2luZyAnbnBtIGxpc3QgLS1qc29uJzogJHtlLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgbGlzdFByb3ZpZGVyUGFja2FnZXMoKTogUHJvbWlzZTxcbiAgICB7IG5hbWU6IHN0cmluZzsgdmVyc2lvbjogc3RyaW5nIH1bXVxuICA+IHtcbiAgICByZXR1cm4gdGhpcy5oYXNZYXJuTG9ja2ZpbGUoKVxuICAgICAgPyB0aGlzLmxpc3RZYXJuUGFja2FnZXMoKVxuICAgICAgOiB0aGlzLmxpc3ROcG1QYWNrYWdlcygpO1xuICB9XG59XG5cbmNsYXNzIFB5dGhvblBhY2thZ2VNYW5hZ2VyIGV4dGVuZHMgUGFja2FnZU1hbmFnZXIge1xuICBwcml2YXRlIGdldCBhcHBDb21tYW5kKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShcbiAgICAgICAgZnMucmVhZEZpbGVTeW5jKFxuICAgICAgICAgIHBhdGgucmVzb2x2ZSh0aGlzLndvcmtpbmdEaXJlY3RvcnksIFwiY2RrdGYuanNvblwiKSxcbiAgICAgICAgICBcInV0ZjhcIlxuICAgICAgICApXG4gICAgICApW1wiYXBwXCJdO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgdGhyb3cgRXJyb3JzLlVzYWdlKFxuICAgICAgICBgQ291bGQgbm90IGZpbmQgZmluZCBhbmQgcGFyc2UgY2RrdGYuanNvbiBpbiAke3RoaXMud29ya2luZ0RpcmVjdG9yeX1gLFxuICAgICAgICBlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBhZGRQYWNrYWdlKFxuICAgIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gICAgcGFja2FnZVZlcnNpb24/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgdXNlUGlwZW52ID0gdGhpcy5hcHBDb21tYW5kLmluY2x1ZGVzKFwicGlwZW52XCIpO1xuXG4gICAgaWYgKHVzZVBpcGVudikge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBJbnN0YWxsaW5nIHBhY2thZ2UgJHtwYWNrYWdlTmFtZX0gQCAke3BhY2thZ2VWZXJzaW9ufSB1c2luZyBwaXBlbnYuYFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgZXhlYyhcInBpcGVudlwiLCBbXCJpbnN0YWxsXCIsIGAke3BhY2thZ2VOYW1lfX49JHtwYWNrYWdlVmVyc2lvbn1gXSwge1xuICAgICAgICBjd2Q6IHRoaXMud29ya2luZ0RpcmVjdG9yeSxcbiAgICAgICAgZW52OiB7XG4gICAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICAgICAgUElQRU5WX1FVSUVUOiBcIjFcIixcbiAgICAgICAgfSxcbiAgICAgICAgc3RkaW86IFtcImluaGVyaXRcIiwgMSwgMV0sXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coXCJQYWNrYWdlIGluc3RhbGxlZC5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgSW5zdGFsbGluZyBwYWNrYWdlICR7cGFja2FnZU5hbWV9IEAgJHtwYWNrYWdlVmVyc2lvbn0gdXNpbmcgcGlwLmBcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlcXVpcmVtZW50c0ZpbGVQYXRoID0gcGF0aC5qb2luKFxuICAgICAgICB0aGlzLndvcmtpbmdEaXJlY3RvcnksXG4gICAgICAgIFwicmVxdWlyZW1lbnRzLnR4dFwiXG4gICAgICApO1xuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHJlcXVpcmVtZW50c0ZpbGVQYXRoKSkge1xuICAgICAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoXG4gICAgICAgICAgYENvdWxkIG5vdCBmaW5kIHJlcXVpcmVtZW50cy50eHQgaW4gJHt0aGlzLndvcmtpbmdEaXJlY3Rvcnl9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXF1aXJlbWVudHMgPSBhd2FpdCBmcy5yZWFkRmlsZShyZXF1aXJlbWVudHNGaWxlUGF0aCwgXCJ1dGY4XCIpO1xuICAgICAgY29uc3QgcmVxdWlyZW1lbnRMaW5lID0gcmVxdWlyZW1lbnRzXG4gICAgICAgIC5zcGxpdChcIlxcblwiKVxuICAgICAgICAuZmluZCgobGluZSkgPT4gbGluZS5pbmNsdWRlcyhwYWNrYWdlTmFtZSkpO1xuXG4gICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgIGBSZWFkIHJlcXVpcmVtZW50cy50eHQgZmlsZSBhbmQgZm91bmQgbGluZSBpbmNsdWRpbmcgJHtwYWNrYWdlTmFtZX06ICR7cmVxdWlyZW1lbnRMaW5lfWBcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXF1aXJlbWVudExpbmUpIHtcbiAgICAgICAgaWYgKHBhY2thZ2VWZXJzaW9uID8gcmVxdWlyZW1lbnRMaW5lLmluY2x1ZGVzKHBhY2thZ2VWZXJzaW9uKSA6IHRydWUpIHtcbiAgICAgICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgICAgIGBQYWNrYWdlICR7cGFja2FnZU5hbWV9IGFscmVhZHkgaW5zdGFsbGVkLiBTa2lwcGluZyBpbnN0YWxsYXRpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICAgIGBGb3VuZCB0aGUgcGFja2FnZSBidXQgd2l0aCBhIGRpZmZlcmVudCB2ZXJzaW9uLCBjb250aW51aW5nYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UmVxdWlyZW1lbnRzID1cbiAgICAgICAgcmVxdWlyZW1lbnRzXG4gICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgLmZpbHRlcigobGluZSkgPT4gIWxpbmUuc3RhcnRzV2l0aChwYWNrYWdlTmFtZSkpXG4gICAgICAgICAgLmpvaW4oXCJcXG5cIikgK1xuICAgICAgICBgXFxuJHtwYWNrYWdlTmFtZX0ke3BhY2thZ2VWZXJzaW9uID8gYH49JHtwYWNrYWdlVmVyc2lvbn1gIDogXCJcIn1gO1xuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKHJlcXVpcmVtZW50c0ZpbGVQYXRoLCBuZXdSZXF1aXJlbWVudHMsIFwidXRmOFwiKTtcblxuICAgICAgYXdhaXQgZXhlYyhcInBpcFwiLCBbXCJpbnN0YWxsXCIsIFwiLXJcIiwgXCJyZXF1aXJlbWVudHMudHh0XCJdLCB7XG4gICAgICAgIGN3ZDogdGhpcy53b3JraW5nRGlyZWN0b3J5LFxuICAgICAgICBzdGRpbzogW1wiaW5oZXJpdFwiLCAxLCAxXSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIlBhY2thZ2UgaW5zdGFsbGVkLlwiKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaXNOcG1WZXJzaW9uQXZhaWxhYmxlKFxuICAgIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gICAgcGFja2FnZVZlcnNpb246IHN0cmluZ1xuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgQ2hlY2tpbmcgaWYgJHtwYWNrYWdlTmFtZX1AJHtwYWNrYWdlVmVyc2lvbn0gaXMgYXZhaWxhYmxlIGZvciBQeXRob25gXG4gICAgKTtcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9weXBpLm9yZy9weXBpLyR7cGFja2FnZU5hbWV9LyR7cGFja2FnZVZlcnNpb259L2pzb25gO1xuICAgIGxvZ2dlci5kZWJ1ZyhgRmV0Y2hpbmcgcGFja2FnZSBpbmZvcm1hdGlvbiBmb3IgJHtwYWNrYWdlTmFtZX0gZnJvbSAke3VybH1gKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBjb25zdCBqc29uID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSkgYXMgYW55O1xuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBHb3QgcmVzcG9uc2UgZnJvbSBQeVBJIGZvciAke3BhY2thZ2VOYW1lfUAke3BhY2thZ2VWZXJzaW9ufTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAganNvblxuICAgICAgKX1gXG4gICAgKTtcblxuICAgIGlmIChqc29uLmluZm8pIHtcbiAgICAgIC8vIFdlIGZvdW5kIHRoZSB2ZXJzaW9uLCBzbyBpdCBleGlzdHNcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgIGBDb3VsZCBub3QgZ2V0IFB5UEkgcGFja2FnZSBpbmZvLCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoanNvbil9YFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgbGlzdFBpcGVudlBhY2thZ2VzKCk6IFByb21pc2U8XG4gICAgeyBuYW1lOiBzdHJpbmc7IHZlcnNpb246IHN0cmluZyB9W11cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0ZG91dCA9IGF3YWl0IGV4ZWMoXG4gICAgICAgIFwicGlwZW52XCIsXG4gICAgICAgIFtcInJ1blwiLCBcInBpcFwiLCBcImxpc3RcIiwgXCItLWZvcm1hdD1qc29uXCJdLFxuICAgICAgICB7XG4gICAgICAgICAgY3dkOiB0aGlzLndvcmtpbmdEaXJlY3RvcnksXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgIGBMaXN0aW5nIHBpcGVudiBwYWNrYWdlcyB1c2luZyBcInBpcGVudiBydW4gcGlwIGxpc3QgLS1mb3JtYXQ9anNvblwiOiAke3N0ZG91dH1gXG4gICAgICApO1xuXG4gICAgICBjb25zdCBsaXN0ID0gcGlwUGFja2FnZVNjaGVtYS5wYXJzZShKU09OLnBhcnNlKHN0ZG91dCkpO1xuICAgICAgcmV0dXJuIGxpc3QuZmlsdGVyKChpdGVtKSA9PlxuICAgICAgICBpdGVtLm5hbWUuc3RhcnRzV2l0aChcImNka3RmLWNka3RmLXByb3ZpZGVyXCIpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGRldGVybWluZSBpbnN0YWxsZWQgcGFja2FnZXMgdXNpbmcgJ3BpcGVudiBydW4gcGlwIGxpc3QgLS1mb3JtYXQ9anNvbic6ICR7ZS5tZXNzYWdlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGxpc3RQaXBQYWNrYWdlcygpOiBQcm9taXNlPHsgbmFtZTogc3RyaW5nOyB2ZXJzaW9uOiBzdHJpbmcgfVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0ZG91dCA9IGF3YWl0IGV4ZWMoXCJwaXBcIiwgW1wibGlzdFwiLCBcIi0tZm9ybWF0PWpzb25cIl0sIHtcbiAgICAgICAgY3dkOiB0aGlzLndvcmtpbmdEaXJlY3RvcnksXG4gICAgICB9KTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYExpc3RpbmcgcGlwZW52IHBhY2thZ2VzIHVzaW5nIFwicGlwIGxpc3QgLS1mb3JtYXQ9anNvblwiOiAke3N0ZG91dH1gXG4gICAgICApO1xuXG4gICAgICBjb25zdCBsaXN0ID0gcGlwUGFja2FnZVNjaGVtYS5wYXJzZShKU09OLnBhcnNlKHN0ZG91dCkpO1xuICAgICAgcmV0dXJuIGxpc3QuZmlsdGVyKChpdGVtKSA9PlxuICAgICAgICBpdGVtLm5hbWUuc3RhcnRzV2l0aChcImNka3RmLWNka3RmLXByb3ZpZGVyXCIpXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGRldGVybWluZSBpbnN0YWxsZWQgcGFja2FnZXMgdXNpbmcgJ3BpcCBsaXN0IC0tZm9ybWF0PWpzb24nOiAke2UubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBsaXN0UHJvdmlkZXJQYWNrYWdlcygpOiBQcm9taXNlPFxuICAgIHsgbmFtZTogc3RyaW5nOyB2ZXJzaW9uOiBzdHJpbmcgfVtdXG4gID4ge1xuICAgIHJldHVybiB0aGlzLmFwcENvbW1hbmQuaW5jbHVkZXMoXCJwaXBlbnZcIilcbiAgICAgID8gdGhpcy5saXN0UGlwZW52UGFja2FnZXMoKVxuICAgICAgOiB0aGlzLmxpc3RQaXBQYWNrYWdlcygpO1xuICB9XG59XG5cbmNsYXNzIE51Z2V0UGFja2FnZU1hbmFnZXIgZXh0ZW5kcyBQYWNrYWdlTWFuYWdlciB7XG4gIHB1YmxpYyBhc3luYyBhZGRQYWNrYWdlKFxuICAgIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gICAgcGFja2FnZVZlcnNpb24/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY29tbWFuZCA9IFwiZG90bmV0XCI7XG4gICAgY29uc3QgYXJncyA9IFtcImFkZFwiLCBcInBhY2thZ2VcIiwgcGFja2FnZU5hbWVdO1xuICAgIGlmIChwYWNrYWdlVmVyc2lvbikge1xuICAgICAgYXJncy5wdXNoKFwiLS12ZXJzaW9uXCIsIHBhY2thZ2VWZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc29sZS5sb2coXG4gICAgICBgSW5zdGFsbGluZyBwYWNrYWdlICR7cGFja2FnZU5hbWV9IEAgJHtwYWNrYWdlVmVyc2lvbn0gdXNpbmcgXCIke2NvbW1hbmR9ICR7YXJncy5qb2luKFxuICAgICAgICBcIiBcIlxuICAgICAgKX1cIi5gXG4gICAgKTtcblxuICAgIGF3YWl0IGV4ZWMoY29tbWFuZCwgYXJncywgeyBjd2Q6IHRoaXMud29ya2luZ0RpcmVjdG9yeSB9KTtcblxuICAgIGNvbnNvbGUubG9nKFwiUGFja2FnZSBpbnN0YWxsZWQuXCIpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGlzTnBtVmVyc2lvbkF2YWlsYWJsZShcbiAgICBwYWNrYWdlTmFtZTogc3RyaW5nLFxuICAgIHBhY2thZ2VWZXJzaW9uOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgbG9nZ2VyLmRlYnVnKGBDaGVja2luZyBpZiAke3BhY2thZ2VOYW1lfUAke3BhY2thZ2VWZXJzaW9ufSBpcyBhdmFpbGFibGVgKTtcblxuICAgIGNvbnN0IFtvd25lciwgLi4ucmVzdF0gPSBwYWNrYWdlTmFtZS5zcGxpdChcIi5cIik7XG4gICAgY29uc3QgaWQgPSByZXN0W3Jlc3QubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vYXp1cmVzZWFyY2gtdXNuYy5udWdldC5vcmcvcXVlcnk/cT1vd25lcjoke293bmVyfSUyMGlkOiR7aWR9JnByZXJlbGVhc2U9ZmFsc2Umc2VtVmVyTGV2ZWw9Mi4wLjBgO1xuICAgIGxvZ2dlci5kZWJ1ZyhgRmV0Y2hpbmcgcGFja2FnZSBtZXRhZGF0YSBmcm9tIE51Z2V0OiAnJHt1cmx9J2ApO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIGNvbnN0IGpzb24gPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKSBhcyB7XG4gICAgICBkYXRhOiB7IGlkOiBzdHJpbmc7IHZlcnNpb25zOiB7IHZlcnNpb246IHN0cmluZyB9W10gfVtdO1xuICAgIH07XG4gICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgYEdvdCByZXNwb25zZSBmcm9tIE51R2V0IGZvciAke3BhY2thZ2VOYW1lfSA6ICR7SlNPTi5zdHJpbmdpZnkoanNvbil9YFxuICAgICk7XG5cbiAgICBpZiAoIWpzb24/LmRhdGE/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBwYWNrYWdlIGZvdW5kXG4gICAgfVxuXG4gICAgY29uc3QgcGFja2FnZVZlcnNpb25zID1cbiAgICAgIGpzb24uZGF0YS5maW5kKChwKSA9PiBwLmlkID09PSBwYWNrYWdlTmFtZSk/LnZlcnNpb25zID8/IFtdO1xuXG4gICAgaWYgKCFwYWNrYWdlVmVyc2lvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIHBhY2thZ2UgcmVsZWFzZSBtYXRjaGluZyB0aGUgaWQgZm91bmRcbiAgICB9XG5cbiAgICByZXR1cm4gcGFja2FnZVZlcnNpb25zLnNvbWUoKHYpID0+IHYudmVyc2lvbiA9PT0gcGFja2FnZVZlcnNpb24pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGxpc3RQcm92aWRlclBhY2thZ2VzKCk6IFByb21pc2U8XG4gICAgeyBuYW1lOiBzdHJpbmc7IHZlcnNpb246IHN0cmluZyB9W11cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0ZG91dCA9IGF3YWl0IGV4ZWMoXCJkb3RuZXRcIiwgW1wibGlzdFwiLCBcInBhY2thZ2VcIl0sIHtcbiAgICAgICAgY3dkOiB0aGlzLndvcmtpbmdEaXJlY3RvcnksXG4gICAgICB9KTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYExpc3RpbmcgcGlwZW52IHBhY2thZ2VzIHVzaW5nIFwiZG90bmV0IGxpc3QgcGFja2FnZVwiOiAke3N0ZG91dH1gXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZWdleCA9XG4gICAgICAgIC9eXFxzKj5cXHMoSGFzaGlDb3JwXFwuQ2RrdGZcXC5Qcm92aWRlcnNcXC5bXFx3Ll0rKVxccysoKD86XFxkK1xcLil7Mn1cXGQrKD86LVxcUyspPylcXHMrKCg/OlxcZCtcXC4pezJ9XFxkKyg/Oi1cXFMrKT8pXFxzKiQvO1xuXG4gICAgICByZXR1cm4gc3Rkb3V0XG4gICAgICAgIC5zcGxpdChcIlxcblwiKVxuICAgICAgICAubWFwKChsaW5lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAvLyBFeGFtcGxlIG91dHB1dDpcbiAgICAgICAgICAvLyBQcm9qZWN0ICdNeVRlcnJhZm9ybVN0YWNrJyBoYXMgdGhlIGZvbGxvd2luZyBwYWNrYWdlIHJlZmVyZW5jZXNcbiAgICAgICAgICAvLyAgW25ldDYuMF06XG4gICAgICAgICAgLy8gIFRvcC1sZXZlbCBQYWNrYWdlICAgICAgUmVxdWVzdGVkICAgUmVzb2x2ZWRcbiAgICAgICAgICAvLyAgPiBIYXNoaUNvcnAuQ2RrdGYgICAgICAwLjAuMCAgICAgICAwLjAuMFxuICAgICAgICAgIC8vIG1hdGNoWzBdID0gZnVsbCBtYXRjaFxuICAgICAgICAgIC8vIG1hdGNoWzFdID0gcGFja2FnZSBuYW1lXG4gICAgICAgICAgLy8gbWF0Y2hbMl0gPSByZXF1ZXN0ZWQgdmVyc2lvblxuICAgICAgICAgIC8vIG1hdGNoWzNdID0gcmVzb2x2ZWQgdmVyc2lvblxuICAgICAgICAgIHJldHVybiByZWdleC5leGVjKGxpbmUpO1xuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKChtYXRjaCkgPT4gISFtYXRjaClcbiAgICAgICAgLm1hcCgobWF0Y2gpID0+ICh7IG5hbWU6IG1hdGNoIVsxXSwgdmVyc2lvbjogbWF0Y2ghWzNdIH0pKTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvdWxkIG5vdCBkZXRlcm1pbmUgaW5zdGFsbGVkIHBhY2thZ2VzIHVzaW5nICdkb3RuZXQgbGlzdCBwYWNrYWdlJzogJHtlLm1lc3NhZ2V9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuYWJzdHJhY3QgY2xhc3MgSmF2YVBhY2thZ2VNYW5hZ2VyIGV4dGVuZHMgUGFja2FnZU1hbmFnZXIge1xuICBwdWJsaWMgYXN5bmMgaXNOcG1WZXJzaW9uQXZhaWxhYmxlKFxuICAgIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gICAgcGFja2FnZVZlcnNpb246IHN0cmluZ1xuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsb2dnZXIuZGVidWcoYENoZWNraW5nIGlmICR7cGFja2FnZU5hbWV9QCR7cGFja2FnZVZlcnNpb259IGlzIGF2YWlsYWJsZWApO1xuXG4gICAgY29uc3QgcGFydHMgPSBwYWNrYWdlTmFtZS5zcGxpdChcIi5cIik7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgRXJyb3JzLkludGVybmFsKFxuICAgICAgICBgRXhwZWN0ZWQgcGFja2FnZSBuYW1lIHRvIGJlIGluIGZvcm1hdCBcImdyb3VwLmFydGlmYWN0XCIsIGUuZy4gXCJjb20uaGFzaGljb3JwLmNka3RmLXByb3ZpZGVyLWdvb2dsZVwiLCBnb3Q6ICR7cGFja2FnZU5hbWV9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWNrYWdlSWRlbnRpZmllciA9IHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IGdyb3VwSWQgPSBwYXJ0cy5qb2luKFwiLlwiKTtcblxuICAgIGNvbnN0IHVybCA9IGBodHRwczovL3NlYXJjaC5tYXZlbi5vcmcvc29scnNlYXJjaC9zZWxlY3Q/cT1nOiR7Z3JvdXBJZH0rQU5EK2E6JHtwYWNrYWdlSWRlbnRpZmllcn0rQU5EK3Y6JHtwYWNrYWdlVmVyc2lvbn0mcm93cz01Jnd0PWpzb25gO1xuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBUcnlpbmcgdG8gZmluZCBwYWNrYWdlIHZlcnNpb24gYnkgcXVlcnlpbmcgTWF2ZW4gQ2VudHJhbCB1bmRlciAnJHt1cmx9J2BcbiAgICApO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcblxuICAgIGNvbnN0IGpzb24gPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKSBhcyBhbnk7XG4gICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgYEdvdCByZXNwb25zZSBmcm9tIHRoZSBNYXZlbiBwYWNrYWdlIHNlYXJjaCBmb3IgJHtwYWNrYWdlTmFtZX06ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIGpzb25cbiAgICAgICl9YFxuICAgICk7XG5cbiAgICByZXR1cm4gKGpzb24/LnJlc3BvbnNlPy5udW1Gb3VuZCA/PyAwKSA+IDA7XG4gIH1cbn1cblxuY2xhc3MgTWF2ZW5QYWNrYWdlTWFuYWdlciBleHRlbmRzIEphdmFQYWNrYWdlTWFuYWdlciB7XG4gIHB1YmxpYyBhc3luYyBhZGRQYWNrYWdlKFxuICAgIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gICAgcGFja2FnZVZlcnNpb24gPSBcIkxBVEVTVFwiIC8vIHRoZSBsYXRlc3Qgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgaW4gbWF2ZW4gMy41XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgJHtwYWNrYWdlTmFtZX0gQCAke3BhY2thZ2VWZXJzaW9ufSB0byBwb20ueG1sYCk7XG4gICAgLy8gQXNzZXJ0IHBvbS54bWwgZXhpc3RzXG4gICAgY29uc3QgcG9tUGF0aCA9IHBhdGguam9pbih0aGlzLndvcmtpbmdEaXJlY3RvcnksIFwicG9tLnhtbFwiKTtcbiAgICBpZiAoIWV4aXN0c1N5bmMocG9tUGF0aCkpIHtcbiAgICAgIHRocm93IEVycm9ycy5Vc2FnZShcbiAgICAgICAgXCJObyBwb20ueG1sIGZvdW5kIGluIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuIFBsZWFzZSBydW4gdGhlIGNvbW1hbmQgZnJvbSB0aGUgcm9vdCBvZiB5b3VyIHByb2plY3QuXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9tID0gYXdhaXQgZnMucmVhZEZpbGUocG9tUGF0aCwgXCJ1dGY4XCIpO1xuICAgIGNvbnN0IHBvbVhtbCA9IChhd2FpdCB4bWwyanMocG9tLCB7fSkpIGFzIEVsZW1lbnQ7XG5cbiAgICAvLyBNdXRhdGUgZGVwZW5kZW5jaWVzXG4gICAgY29uc3QgbmFtZVBhcnRzID0gcGFja2FnZU5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIGNvbnN0IGdyb3VwSWQgPSBuYW1lUGFydHMuc2xpY2UoMCwgbmFtZVBhcnRzLmxlbmd0aCAtIDEpLmpvaW4oXCIuXCIpO1xuICAgIGNvbnN0IGFydGlmYWN0SWQgPSBuYW1lUGFydHNbbmFtZVBhcnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgY29uc3QgbmV3RGVwZW5kZW5jeSA9IChhd2FpdCB4bWwyanMoXG4gICAgICBgPGRlcGVuZGVuY3k+XG4gICAgPGdyb3VwSWQ+JHtncm91cElkfTwvZ3JvdXBJZD5cbiAgICA8YXJ0aWZhY3RJZD4ke2FydGlmYWN0SWR9PC9hcnRpZmFjdElkPlxuICAgIDx2ZXJzaW9uPiR7cGFja2FnZVZlcnNpb259PC92ZXJzaW9uPlxuPC9kZXBlbmRlbmN5PmBcbiAgICApKSBhcyBFbGVtZW50O1xuXG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gcG9tWG1sLmVsZW1lbnRzXG4gICAgICA/LmZpbmQoKGVsKSA9PiBlbC5uYW1lID09PSBcInByb2plY3RcIilcbiAgICAgID8uZWxlbWVudHM/LmZpbmQoKGVsKSA9PiBlbC5uYW1lID09PSBcImRlcGVuZGVuY2llc1wiKTtcblxuICAgIGlmICghZGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoYENvdWxkIG5vdCBmaW5kIGRlcGVuZGVuY2llcyBzZWN0aW9uIGluIHRoZSBwb20ueG1sYCk7XG4gICAgfVxuICAgIGRlcGVuZGVuY2llcy5lbGVtZW50cyA9IChkZXBlbmRlbmNpZXM/LmVsZW1lbnRzIHx8IFtdKS5maWx0ZXIoXG4gICAgICAoZWwpID0+XG4gICAgICAgIGVsLmVsZW1lbnRzPy5zb21lKFxuICAgICAgICAgIChncm91cCkgPT5cbiAgICAgICAgICAgIGdyb3VwLm5hbWUgPT09IFwiZ3JvdXBJZFwiICYmIGdyb3VwLmVsZW1lbnRzPy5bMF0udGV4dCAhPT0gZ3JvdXBJZFxuICAgICAgICApIHx8XG4gICAgICAgIGVsLmVsZW1lbnRzPy5zb21lKFxuICAgICAgICAgIChhcnRpZmFjdCkgPT5cbiAgICAgICAgICAgIGFydGlmYWN0Lm5hbWUgPT09IFwiYXJ0aWZhY3RJZFwiICYmXG4gICAgICAgICAgICBhcnRpZmFjdC5lbGVtZW50cz8uWzBdLnRleHQgIT09IGFydGlmYWN0SWRcbiAgICAgICAgKVxuICAgICk7XG4gICAgZGVwZW5kZW5jaWVzPy5lbGVtZW50cz8ucHVzaChuZXdEZXBlbmRlbmN5LmVsZW1lbnRzIVswXSk7XG5cbiAgICAvLyBXcml0ZSBuZXcgcG9tLnhtbFxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShwb21QYXRoLCBqczJ4bWwocG9tWG1sLCB7IHNwYWNlczogMiB9KSk7XG5cbiAgICAvLyBJbnN0YWxsXG4gICAgYXdhaXQgZXhlYyhcIm12blwiLCBbXCJpbnN0YWxsXCJdLCB7IGN3ZDogdGhpcy53b3JraW5nRGlyZWN0b3J5IH0pO1xuICAgIGNvbnNvbGUubG9nKFwiUGFja2FnZSBpbnN0YWxsZWQuXCIpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGxpc3RQcm92aWRlclBhY2thZ2VzKCk6IFByb21pc2U8XG4gICAgeyBuYW1lOiBzdHJpbmc7IHZlcnNpb246IHN0cmluZyB9W11cbiAgPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBvbVBhdGggPSBwYXRoLmpvaW4odGhpcy53b3JraW5nRGlyZWN0b3J5LCBcInBvbS54bWxcIik7XG4gICAgICBpZiAoIWV4aXN0c1N5bmMocG9tUGF0aCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3JzLlVzYWdlKFxuICAgICAgICAgIFwiTm8gcG9tLnhtbCBmb3VuZCBpbiBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBQbGVhc2UgcnVuIHRoZSBjb21tYW5kIGZyb20gdGhlIHJvb3Qgb2YgeW91ciBwcm9qZWN0LlwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvbSA9IGF3YWl0IGZzLnJlYWRGaWxlKHBvbVBhdGgsIFwidXRmOFwiKTtcbiAgICAgIGNvbnN0IHBvbVhtbCA9IChhd2FpdCB4bWwyanMocG9tLCB7fSkpIGFzIEVsZW1lbnQ7XG5cbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9XG4gICAgICAgIHBvbVhtbC5lbGVtZW50c1xuICAgICAgICAgID8uZmluZCgoZWwpID0+IGVsLm5hbWUgPT09IFwicHJvamVjdFwiKVxuICAgICAgICAgID8uZWxlbWVudHM/LmZpbmQoKGVsKSA9PiBlbC5uYW1lID09PSBcImRlcGVuZGVuY2llc1wiKT8uZWxlbWVudHMgPz8gW107XG5cbiAgICAgIHJldHVybiBkZXBlbmRlbmNpZXNcbiAgICAgICAgLm1hcCgoZGVwKSA9PiAoe1xuICAgICAgICAgIG5hbWU6IGAke1xuICAgICAgICAgICAgZGVwLmVsZW1lbnRzPy5maW5kKChlbCkgPT4gZWwubmFtZSA9PT0gXCJncm91cElkXCIpPy5lbGVtZW50cz8uWzBdXG4gICAgICAgICAgICAgIC50ZXh0XG4gICAgICAgICAgfS4ke1xuICAgICAgICAgICAgZGVwLmVsZW1lbnRzPy5maW5kKChlbCkgPT4gZWwubmFtZSA9PT0gXCJhcnRpZmFjdElkXCIpPy5lbGVtZW50cz8uWzBdXG4gICAgICAgICAgICAgIC50ZXh0XG4gICAgICAgICAgfWAsXG4gICAgICAgICAgdmVyc2lvbjogZGVwLmVsZW1lbnRzPy5maW5kKChlbCkgPT4gZWwubmFtZSA9PT0gXCJ2ZXJzaW9uXCIpXG4gICAgICAgICAgICA/LmVsZW1lbnRzPy5bMF0udGV4dCBhcyBzdHJpbmcsXG4gICAgICAgIH0pKVxuICAgICAgICAuZmlsdGVyKChkZXApID0+IGRlcC5uYW1lLnN0YXJ0c1dpdGgoXCJjb20uaGFzaGljb3JwLmNka3RmLXByb3ZpZGVyLVwiKSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDb3VsZCBub3QgZGV0ZXJtaW5lIGluc3RhbGxlZCBwYWNrYWdlcyByZWFkaW5nIHRoZSBwb20ueG1sOiAke2UubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBHcmFkbGVQYWNrYWdlTWFuYWdlciBleHRlbmRzIEphdmFQYWNrYWdlTWFuYWdlciB7XG4gIHB1YmxpYyBzdGF0aWMgaXNHcmFkbGVQcm9qZWN0KHdvcmtpbmdEaXJlY3Rvcnk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc0dyYWRsZVByb2plY3Qod29ya2luZ0RpcmVjdG9yeSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYWRkUGFja2FnZShcbiAgICBwYWNrYWdlRlFOOiBzdHJpbmcsXG4gICAgcGFja2FnZVZlcnNpb24gPSBcImxhdGVzdC5yZWxlYXNlXCJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgYnVpbGRHcmFkbGVQYXRoID0gcGF0aC5qb2luKHRoaXMud29ya2luZ0RpcmVjdG9yeSwgXCJidWlsZC5ncmFkbGVcIik7XG4gICAgY29uc3QgYnVpbGRHcmFkbGUgPSBhd2FpdCBmcy5yZWFkRmlsZShidWlsZEdyYWRsZVBhdGgsIFwidXRmOFwiKTtcbiAgICBjb25zdCBidWlsZEdyYWRsZUxpbmVzID0gYnVpbGRHcmFkbGUuc3BsaXQoL1xccj9cXG4vKTtcblxuICAgIGNvbnN0IGRlcGVuZGVuY2llc1JlZ2V4ID0gL2RlcGVuZGVuY2llc1xccytcXHsvaTtcbiAgICBjb25zdCBkZXBlbmRlbmN5QmxvY2tTdGFydCA9IGJ1aWxkR3JhZGxlTGluZXMuZmluZEluZGV4KChsaW5lKSA9PlxuICAgICAgZGVwZW5kZW5jaWVzUmVnZXgudGVzdChsaW5lKVxuICAgICk7XG4gICAgaWYgKGRlcGVuZGVuY3lCbG9ja1N0YXJ0ID09PSAtMSkge1xuICAgICAgdGhyb3cgRXJyb3JzLlVzYWdlKFxuICAgICAgICBcIkNvdWxkIG5vdCBmaW5kIGRlcGVuZGVuY2llcyBzZWN0aW9uIGluIHRoZSBidWlsZC5ncmFkbGVcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWNrYWdlU2VnbWVudHMgPSBwYWNrYWdlRlFOLnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IHBhY2thZ2VTZWdtZW50cy5wb3AoKTtcbiAgICBjb25zdCBncm91cE5hbWUgPSBwYWNrYWdlU2VnbWVudHMuam9pbihcIi5cIik7XG4gICAgY29uc3QgZGVwZW5kZW5jeVNwZWNpZmllciA9IGAke2dyb3VwTmFtZX06JHtwYWNrYWdlTmFtZX1gO1xuICAgIGNvbnN0IGRlcGVuZGVuY3lBbmRWZXJzaW9uU3BlY2lmaWVyID0gYCR7ZGVwZW5kZW5jeVNwZWNpZmllcn06JHtwYWNrYWdlVmVyc2lvbn1gO1xuXG4gICAgY29uc3QgZXhpc3RpbmdEZXBlbmRlbmN5ID0gYnVpbGRHcmFkbGVMaW5lcy5maW5kSW5kZXgoKGxpbmUpID0+XG4gICAgICBsaW5lLmluY2x1ZGVzKGRlcGVuZGVuY3lTcGVjaWZpZXIpXG4gICAgKTtcbiAgICBpZiAoZXhpc3RpbmdEZXBlbmRlbmN5ICE9PSAtMSkge1xuICAgICAgYnVpbGRHcmFkbGVMaW5lcy5zcGxpY2UoZXhpc3RpbmdEZXBlbmRlbmN5LCAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdQYWNrYWdlRGVwZW5kZW5jeSA9IGBcXHRpbXBsZW1lbnRhdGlvbiAnJHtkZXBlbmRlbmN5QW5kVmVyc2lvblNwZWNpZmllcn0nYDtcbiAgICBidWlsZEdyYWRsZUxpbmVzLnNwbGljZShkZXBlbmRlbmN5QmxvY2tTdGFydCArIDEsIDAsIG5ld1BhY2thZ2VEZXBlbmRlbmN5KTtcblxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShidWlsZEdyYWRsZVBhdGgsIGJ1aWxkR3JhZGxlTGluZXMuam9pbihcIlxcblwiKSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgbGlzdFByb3ZpZGVyUGFja2FnZXMoKTogUHJvbWlzZTxcbiAgICB7IG5hbWU6IHN0cmluZzsgdmVyc2lvbjogc3RyaW5nIH1bXVxuICA+IHtcbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBhd2FpdCBnZXRHcmFkbGVEZXBlbmRlbmNpZXMoKTtcbiAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgdGhyb3cgRXJyb3JzLlVzYWdlKFwiQ291bGQgbm90IGZpbmQgYW55IGRlcGVuZGVuY2llc1wiKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXBlbmRlbmN5TGlzdCA9IGRlcGVuZGVuY2llc1xuICAgICAgLm1hcCgobGluZSkgPT4gZ2V0RGVwZW5kZW5jeUluZm9ybWF0aW9uRnJvbUxpbmUobGluZSkpXG4gICAgICAuZmlsdGVyKChkZXApID0+IHtcbiAgICAgICAgaWYgKCFkZXApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcC5uYW1lLmluY2x1ZGVzKFwiY2RrdGYtcHJvdmlkZXItXCIpO1xuICAgICAgfSlcbiAgICAgIC5tYXAoKGRlcCkgPT4gKHtcbiAgICAgICAgbmFtZTogYGNvbS5oYXNoaWNvcnAuJHtkZXAhLm5hbWV9YCxcbiAgICAgICAgdmVyc2lvbjogZGVwIS52ZXJzaW9uLFxuICAgICAgfSkpO1xuXG4gICAgcmV0dXJuIGRlcGVuZGVuY3lMaXN0O1xuICB9XG59XG5cbmNsYXNzIEdvUGFja2FnZU1hbmFnZXIgZXh0ZW5kcyBQYWNrYWdlTWFuYWdlciB7XG4gIHB1YmxpYyBhc3luYyBhZGRQYWNrYWdlKFxuICAgIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gICAgcGFja2FnZVZlcnNpb24/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coYEFkZGluZyBwYWNrYWdlICR7cGFja2FnZU5hbWV9IEAgJHtwYWNrYWdlVmVyc2lvbn1gKTtcblxuICAgIGNvbnN0IG1ham9yVmVyc2lvbjogbnVtYmVyIHwgdW5kZWZpbmVkID0gcGFja2FnZVZlcnNpb25cbiAgICAgID8gc2VtdmVyLm1ham9yKHBhY2thZ2VWZXJzaW9uKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgdmVyc2lvblBhY2thZ2VTdWZmaXggPSBcIlwiO1xuICAgIGlmICh0eXBlb2YgbWFqb3JWZXJzaW9uID09PSBcIm51bWJlclwiICYmIG1ham9yVmVyc2lvbiA+IDEpIHtcbiAgICAgIHZlcnNpb25QYWNrYWdlU3VmZml4ID0gYC92JHttYWpvclZlcnNpb259YDtcbiAgICB9XG5cbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgUnVubmluZyAnZ28gZ2V0ICR7cGFja2FnZU5hbWV9JHt2ZXJzaW9uUGFja2FnZVN1ZmZpeH1AdiR7cGFja2FnZVZlcnNpb259J2BcbiAgICApO1xuICAgIC8vIEluc3RhbGxcbiAgICBhd2FpdCBleGVjKFxuICAgICAgXCJnb1wiLFxuICAgICAgW1wiZ2V0XCIsIGAke3BhY2thZ2VOYW1lfSR7dmVyc2lvblBhY2thZ2VTdWZmaXh9QHYke3BhY2thZ2VWZXJzaW9ufWBdLFxuICAgICAge1xuICAgICAgICBjd2Q6IHRoaXMud29ya2luZ0RpcmVjdG9yeSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY29uc29sZS5sb2coXCJQYWNrYWdlIGluc3RhbGxlZC5cIik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgaXNOcG1WZXJzaW9uQXZhaWxhYmxlKFxuICAgIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gICAgcGFja2FnZVZlcnNpb246IHN0cmluZ1xuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsb2dnZXIuZGVidWcoYENoZWNraW5nIGlmICR7cGFja2FnZU5hbWV9QCR7cGFja2FnZVZlcnNpb259IGlzIGF2YWlsYWJsZWApO1xuXG4gICAgLy8gZS5nLiBnaXRodWIuY29tL2Nka3RmL2Nka3RmLXByb3ZpZGVyLWdvb2dsZS1nby9nb29nbGVcbiAgICBjb25zdCBwYXJ0cyA9IHBhY2thZ2VOYW1lLnNwbGl0KFwiL1wiKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBFcnJvcnMuSW50ZXJuYWwoXG4gICAgICAgIGBFeHBlY3RpbmcgR28gcGFja2FnZSBuYW1lIHRvIGJlIGluIHRoZSBmb3JtYXQgb2YgZ2l0aHViLmNvbS88b3JnPi88cmVwbz4vPHBhY2thZ2U+LCBnb3QgJHtwYWNrYWdlTmFtZX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG9yZyA9IHBhcnRzWzFdO1xuICAgIGNvbnN0IHJlcG8gPSBwYXJ0c1syXTtcbiAgICBjb25zdCBwYWNrYWdlUGF0aCA9IHBhcnRzWzNdO1xuXG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvJHtvcmd9LyR7cmVwb30vZ2l0L3JlZi90YWdzLyR7cGFja2FnZVBhdGh9L3Yke3BhY2thZ2VWZXJzaW9ufWA7XG4gICAgbG9nZ2VyLmRlYnVnKGBGZXRjaGluZyB0YWdzIGZvciAke29yZ30vJHtyZXBvfSBmcm9tICcke3VybH0nYCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL3ZuZC5naXRodWIranNvblwiLFxuICAgICAgICBcIlVzZXItQWdlbnRcIjogXCJIYXNoaUNvcnAvY2RrdGYtY2xpXCIsXG4gICAgICAgIC4uLihHSVRIVUJfQVBJX1RPS0VOX0NES1RGXG4gICAgICAgICAgPyB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtHSVRIVUJfQVBJX1RPS0VOX0NES1RGfWAgfVxuICAgICAgICAgIDoge30pLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGpzb24gPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKSBhcyBhbnk7XG4gICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgYEdvdCByZXNwb25zZSBmcm9tIEdpdEh1YnMgcmVwb3NpdG9yeSB0YWcgZW5kcG9pbnQgZm9yICR7cGFja2FnZU5hbWV9OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBqc29uXG4gICAgICApfWBcbiAgICApO1xuXG4gICAgaWYgKGpzb24gJiYganNvbi5yZWYpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGxvZ2dlci5pbmZvKFxuICAgICAgYENvdWxkIG5vdCBmaW5kIHRoZSB0YWcgJHtwYWNrYWdlUGF0aH0vdiR7cGFja2FnZVZlcnNpb259IGluIHRoZSByZXBvc2l0b3J5ICR7b3JnfS8ke3JlcG99OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICBqc29uXG4gICAgICApfX1gXG4gICAgKTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBsaXN0UHJvdmlkZXJQYWNrYWdlcygpOiBQcm9taXNlPFxuICAgIHsgbmFtZTogc3RyaW5nOyB2ZXJzaW9uOiBzdHJpbmcgfVtdXG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBnb1N1bVBhdGggPSBwYXRoLmpvaW4odGhpcy53b3JraW5nRGlyZWN0b3J5LCBcImdvLnN1bVwiKTtcbiAgICAgIGlmICghZXhpc3RzU3luYyhnb1N1bVBhdGgpKSB7XG4gICAgICAgIHRocm93IEVycm9ycy5Vc2FnZShcbiAgICAgICAgICBcIk5vIGdvLnN1bSBmb3VuZCBpbiBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBQbGVhc2UgcnVuIHRoZSBjb21tYW5kIGZyb20gdGhlIHJvb3Qgb2YgeW91ciBwcm9qZWN0LlwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdvU3VtID0gYXdhaXQgZnMucmVhZEZpbGUoZ29TdW1QYXRoLCBcInV0ZjhcIik7XG4gICAgICBjb25zdCBkZWR1cGVkUHJvdmlkZXJOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgICAgcmV0dXJuIGdvU3VtXG4gICAgICAgIC5zcGxpdChcIlxcblwiKVxuICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgIChsaW5lKSA9PlxuICAgICAgICAgICAgbGluZS5zdGFydHNXaXRoKFwiZ2l0aHViLmNvbS9oYXNoaWNvcnAvY2RrdGYtcHJvdmlkZXJcIikgfHxcbiAgICAgICAgICAgIGxpbmUuc3RhcnRzV2l0aChcImdpdGh1Yi5jb20vY2RrdGYvY2RrdGYtcHJvdmlkZXJcIilcbiAgICAgICAgKVxuICAgICAgICAubWFwKChsaW5lKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcnMuSW50ZXJuYWwoXG4gICAgICAgICAgICAgIGBFeHBlY3RlZCBsaW5lIGluIGdvLnN1bSB0byBiZSBpbiB0aGUgZm9ybWF0IG9mICc8cGFja2FnZT4gPHZlcnNpb24+IDxjaGVja3N1bT4nLCBnb3Q6ICR7bGluZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHBhcnRbMF0gY291bGQgYmUgZ2l0aHViLmNvbS9hd3MvY29uc3RydWN0cy1nby9jb25zdHJ1Y3RzL3YxMFxuICAgICAgICAgIGNvbnN0IG5hbWUgPSBwYXJ0c1swXS5zcGxpdChcIi9cIikuc2xpY2UoMCwgNCkuam9pbihcIi9cIik7XG5cbiAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gcGFydHNbMV0uc3BsaXQoXCIvXCIpWzBdO1xuXG4gICAgICAgICAgaWYgKGRlZHVwZWRQcm92aWRlck5hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJcIiwgdmVyc2lvbjogXCJcIiB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZHVwZWRQcm92aWRlck5hbWVzLmFkZChuYW1lKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgIChwcm92aWRlckluZm8pID0+ICEhcHJvdmlkZXJJbmZvLm5hbWUgJiYgISFwcm92aWRlckluZm8udmVyc2lvblxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGRldGVybWluZSBpbnN0YWxsZWQgcGFja2FnZXMgcmVhZGluZyB0aGUgZ28uc3VtOiAke2UubWVzc2FnZX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIl19