"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DependencyManager = exports.ProviderConstraint = exports.DEFAULT_NAMESPACE = exports.DEFAULT_HOSTNAME = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const commons_1 = require("@cdktf/commons");
const codemaker_1 = require("codemaker");
const cdktf_config_1 = require("../cdktf-config");
const cdktf_config_manager_1 = require("./cdktf-config-manager");
const package_manager_1 = require("./package-manager");
const prebuilt_providers_1 = require("./prebuilt-providers");
const registry_api_1 = require("./registry-api");
const version_constraints_1 = require("./version-constraints");
const semver = __importStar(require("semver"));
const local_provider_versions_1 = require("../local-provider-versions");
const local_provider_constraints_1 = require("../local-provider-constraints");
// ref: https://www.terraform.io/language/providers/requirements#source-addresses
exports.DEFAULT_HOSTNAME = "registry.terraform.io";
exports.DEFAULT_NAMESPACE = "hashicorp";
function normalizeProviderSource(source) {
    // returns <HOSTNAME>/<NAMESPACE>/<TYPE>
    const slashes = source.split("/").length - 1;
    switch (slashes) {
        case 0:
            return `${exports.DEFAULT_HOSTNAME}/${exports.DEFAULT_NAMESPACE}/${source}`;
        case 1:
            return `${exports.DEFAULT_HOSTNAME}/${source}`;
        default:
            return source;
    }
}
class ProviderConstraint {
    // TODO: add examples to cli command description (i.e. =,~>.> etc.)
    // if no version constraint is specified, we assume the latest version
    // if specific version is specified without e.g. =, we allow patch level increments (e.g. ~>2.12 for "2.12")
    constructor(source, version) {
        this.version = version;
        this.source = normalizeProviderSource(source);
    }
    static fromConfigEntry(provider) {
        if (typeof provider === "string") {
            const [src, version] = provider.split("@");
            return new ProviderConstraint(src.trim(), version ? version.trim() : undefined);
        }
        const src = (provider.namespace ? `${provider.namespace}/` : "") +
            (provider.source || provider.name);
        return new ProviderConstraint(src, provider.version);
    }
    isFromTerraformRegistry() {
        return this.hostname === exports.DEFAULT_HOSTNAME;
    }
    /**
     * the namespace of the provider
     * e.g. "hashicorp" or "kreuzwerker"
     */
    get namespace() {
        return this.source.split("/")[1];
    }
    /**
     * the name of the provider
     * e.g. "aws"
     */
    get name() {
        return this.source.split("/")[2];
    }
    /**
     * the hostname of the provider
     * e.g. "registry.terraform.io"
     */
    get hostname() {
        return this.source.split("/")[0];
    }
    /**
     * returns a simplified provider name, dropping namespace and hostname
     * if they match the defaults
     */
    get simplifiedName() {
        return this.source
            .split("/")
            .filter((part) => part !== exports.DEFAULT_HOSTNAME && part !== exports.DEFAULT_NAMESPACE)
            .join("/");
    }
    /**
     * checks if the version constraint matches the given version
     * @param version an actual version (e.g. "4.12.1")
     * @returns true if the version is compatible with the constraint
     */
    matchesVersion(version) {
        if (this.version) {
            return (0, version_constraints_1.versionMatchesConstraint)(version, this.version);
        }
        return true;
    }
    toString() {
        return `${this.source}${this.version ? `@${this.version}` : ""}`;
    }
}
exports.ProviderConstraint = ProviderConstraint;
/**
 * manages dependencies of a CDKTF project (e.g. terraform providers)
 */
class DependencyManager {
    constructor(targetLanguage, cdktfVersion, projectDirectory) {
        this.targetLanguage = targetLanguage;
        this.cdktfVersion = cdktfVersion;
        this.projectDirectory = projectDirectory;
        this.packageManager = package_manager_1.PackageManager.forLanguage(targetLanguage, this.projectDirectory);
    }
    async addProvider(constraint) {
        if (await this.hasPrebuiltProvider(constraint)) {
            await this.addPrebuiltProvider(constraint);
            return { addedLocalProvider: false };
        }
        else {
            await this.addLocalProvider(constraint);
            return { addedLocalProvider: true };
        }
    }
    async upgradeProvider(constraint) {
        console.log(`Upgrading ${constraint.simplifiedName}...`);
        const cdktfJson = new cdktf_config_manager_1.CdktfConfigManager();
        const prebuiltVersion = await this.getCurrentlyInstalledVersion(constraint);
        if (prebuiltVersion) {
            await this.upgradePrebuiltProvider(constraint, prebuiltVersion);
            return { addedLocalProvider: false };
        }
        if (await cdktfJson.hasProvider(constraint)) {
            await cdktfJson.updateProvider(constraint);
            return { addedLocalProvider: true };
        }
        throw commons_1.Errors.Usage(`Trying to upgrade ${constraint.simplifiedName} but it is not installed, please use "cdktf provider add ${constraint.simplifiedName}" to add it.`);
    }
    async getCurrentlyInstalledVersion(constraint) {
        var _a;
        commons_1.logger.info(`Checking if ${constraint.simplifiedName} is installed...`);
        const packageName = await this.tryGetPackageName(constraint);
        if (!packageName)
            return; // not available as pre-built provider, so can't be installed as such
        commons_1.logger.debug(`Expecting package ${packageName} to be installed if provider is installed as pre-built one`);
        let installedPackages;
        try {
            installedPackages = await this.packageManager.listProviderPackages();
        }
        catch (e) {
            throw new Error(`Failed to list packages: ${e}`);
        }
        commons_1.logger.debug(`Installed packages found: ${JSON.stringify(installedPackages, null, 2)}`);
        return (_a = installedPackages.find((pkg) => pkg.name === packageName)) === null || _a === void 0 ? void 0 : _a.version;
    }
    async upgradePrebuiltProvider(constraint, currentVersion) {
        commons_1.logger.debug(`Searching for latest matching version of ${constraint.simplifiedName}`);
        const packageName = await this.getPackageName(constraint);
        const packageVersion = await this.getMatchingProviderVersion(constraint);
        commons_1.logger.debug(`Found package ${packageName}@${packageVersion}`);
        if (packageVersion !== currentVersion) {
            await this.packageManager.addPackage(packageName, packageVersion);
        }
        else {
            console.log(`The latest version of ${packageName} is already installed: ${packageVersion}`);
        }
    }
    async hasPrebuiltProvider(constraint) {
        commons_1.logger.debug(`determining whether pre-built provider exists for ${constraint.source} with version constraint ${constraint.version} and cdktf version ${this.cdktfVersion}`);
        commons_1.logger.info(`Checking whether pre-built provider exists for the following constraints:
  provider: ${constraint.simplifiedName}
  version : ${constraint.version || "latest"}
  language: ${this.targetLanguage}
  cdktf   : ${this.cdktfVersion}
`);
        if (this.targetLanguage === commons_1.Language.GO &&
            semver.lt(this.cdktfVersion, "0.12.0")) {
            commons_1.logger.info(`Before CDKTF 0.12.0 there were no pre-built providers published for Go.`);
            return false;
        }
        const v = await (0, prebuilt_providers_1.getPrebuiltProviderVersions)(constraint, this.cdktfVersion);
        const exists = v !== null;
        if (exists) {
            commons_1.logger.info(`Found pre-built provider.`);
        }
        else {
            commons_1.logger.info(`Pre-built provider does not exist for the given constraints.`);
        }
        return exists;
    }
    async tryGetPackageName(constraint) {
        const npmPackageName = await (0, prebuilt_providers_1.getNpmPackageName)(constraint);
        if (!npmPackageName)
            return;
        const prebuiltProviderRepository = await (0, prebuilt_providers_1.getPrebuiltProviderRepositoryName)(npmPackageName);
        return this.convertPackageName(npmPackageName, prebuiltProviderRepository);
    }
    async getPackageName(constraint) {
        const packageName = await this.tryGetPackageName(constraint);
        if (!packageName) {
            throw commons_1.Errors.Usage(`Could not find pre-built provider for ${constraint.source}`);
        }
        return packageName;
    }
    async getMatchingProviderVersion(constraint) {
        const packageName = await this.getPackageName(constraint);
        const prebuiltProviderNpmVersions = await (0, prebuilt_providers_1.getPrebuiltProviderVersions)(constraint, this.cdktfVersion);
        if (!prebuiltProviderNpmVersions) {
            throw commons_1.Errors.Usage(`No pre-built provider found for ${constraint.source} with version constraint ${constraint.version} and cdktf version ${this.cdktfVersion}`);
        }
        const packageVersion = await this.getLanguageSpecificPackageVersion(packageName, prebuiltProviderNpmVersions);
        if (!packageVersion) {
            throw commons_1.Errors.Usage(`No pre-built provider found for ${constraint.source} with version constraint ${constraint.version} and cdktf version ${this.cdktfVersion} for language ${this.targetLanguage}.`);
        }
        return packageVersion;
    }
    async addPrebuiltProvider(constraint, silent = false) {
        commons_1.logger.debug(`adding pre-built provider ${constraint.source} with version constraint ${constraint.version} for cdktf version ${this.cdktfVersion}`);
        const packageName = await this.getPackageName(constraint);
        const packageVersion = await this.getMatchingProviderVersion(constraint);
        await this.packageManager.addPackage(packageName, packageVersion, silent);
        // TODO: more debug logs
    }
    // The version we use for npm might differ from other registries
    // This happens mostly in cases where a provider update failed to publish to one of the registries
    // In that case we use the latest version that was published successfully and works with the current cdktf release
    async getLanguageSpecificPackageVersion(packageName, prebuiltProviderNpmVersions) {
        commons_1.logger.debug("Found possibly matching versions (released on npm): ", prebuiltProviderNpmVersions);
        commons_1.logger.debug("Searching through package manager to find latest available version for given language");
        for (const version of prebuiltProviderNpmVersions) {
            try {
                const isAvailable = await this.packageManager.isNpmVersionAvailable(packageName, version);
                if (isAvailable) {
                    return version;
                }
            }
            catch (err) {
                commons_1.logger.info(`Could not find version ${version} for package ${packageName}: '${err}'. Skipping...`);
            }
        }
        return null;
    }
    async addLocalProvider(constraint) {
        commons_1.logger.info(`Adding local provider ${constraint.source} with version constraint ${constraint.version} to cdktf.json`);
        if (!constraint.version && constraint.isFromTerraformRegistry()) {
            const v = await (0, registry_api_1.getLatestVersion)(constraint);
            if (v) {
                constraint = new ProviderConstraint(constraint.source, 
                // "1.3.2" -> "~> 1.3"
                `~> ${v.split(".").slice(0, 2).join(".")}`);
            }
            else {
                throw commons_1.Errors.Usage(`Could not find a version for the provider '${constraint}' in the public registry. This could be due to a typo, please take a look at https://cdk.tf/registry-providers to find all supported providers.`);
            }
        }
        await new cdktf_config_manager_1.CdktfConfigManager().addProvider(constraint);
    }
    /**
     * Converts an NPM package name of a pre-built provider package to the name in the target language
     */
    convertPackageName(name, repository) {
        const providerName = name.replace("@cdktf/provider-", "");
        switch (this.targetLanguage) {
            case commons_1.Language.GO: // e.g. github.com/cdktf/cdktf-provider-opentelekomcloud-go/opentelekomcloud
                if (repository) {
                    return `${repository}-go/${providerName}`;
                }
                return `github.com/cdktf/cdktf-provider-${providerName}-go/${providerName}`;
            case commons_1.Language.TYPESCRIPT: // e.g. @cdktf/provider-random
                return name; // already the correct name
            case commons_1.Language.CSHARP: // e.g. HashiCorp.Cdktf.Providers.Opentelekomcloud
                return `HashiCorp.Cdktf.Providers.` + (0, codemaker_1.toPascalCase)(providerName);
            case commons_1.Language.JAVA: // e.g. com.hashicorp.opentelekomcloud
                return `com.hashicorp.cdktf-provider-${providerName}`;
            case commons_1.Language.PYTHON: // e.g. cdktf-cdktf-provider-opentelekomcloud
                return `cdktf-cdktf-provider-${providerName}`;
            default:
                throw new Error(`converting package name for language ${this.targetLanguage} not implemented yet`);
        }
    }
    /**
     * Converts an package name of a pre-built provider package in target language to the name in npm
     * Inverse of: `convertPackageName`
     */
    convertFromPackageNameToNpm(name) {
        const npmPackagePrefix = "@cdktf/provider-";
        const regexes = {
            [commons_1.Language.GO]: /github.com\/(?:cdktf|hashicorp)\/cdktf-provider-(.+)-go\//i,
            [commons_1.Language.TYPESCRIPT]: /(.+)/i,
            [commons_1.Language.CSHARP]: /HashiCorp\.Cdktf\.Providers\.(.+)/i,
            [commons_1.Language.JAVA]: /com\.hashicorp\.cdktf-provider-(.+)/i,
            [commons_1.Language.PYTHON]: /cdktf-cdktf-provider-(.+)/i,
        };
        const regex = regexes[this.targetLanguage];
        if (!regex) {
            throw commons_1.Errors.Usage("Language not supported for pre-built providers");
        }
        const match = regex.exec(name);
        if (!match) {
            throw new Error(`Package name is not in expected format: ${name}`);
        }
        switch (this.targetLanguage) {
            case commons_1.Language.GO: // e.g. github.com/cdktf/cdktf-provider-opentelekomcloud-go/opentelekomcloud
                return npmPackagePrefix + match[1];
            case commons_1.Language.TYPESCRIPT: // e.g. @cdktf/provider-random
                return match[1]; // already the correct name
            case commons_1.Language.CSHARP: // e.g. HashiCorp.Cdktf.Providers.Opentelekomcloud
                return npmPackagePrefix + (0, codemaker_1.toSnakeCase)(match[1]);
            case commons_1.Language.JAVA: // e.g. com.hashicorp.opentelekomcloud
                return npmPackagePrefix + match[1];
            case commons_1.Language.PYTHON: // e.g. cdktf-cdktf-provider-opentelekomcloud
                return npmPackagePrefix + match[1];
            default:
                throw new Error(`converting package name for language ${this.targetLanguage} not implemented yet`);
        }
    }
    async allProviders() {
        const cdktfJson = cdktf_config_1.CdktfConfig.read();
        const localVersions = new local_provider_versions_1.LocalProviderVersions();
        const localProviderConfigs = cdktfJson.terraformProviders;
        const prebuiltProviderConfigs = await this.packageManager.listProviderPackages();
        const prebuiltProvidersInfo = await Promise.all(prebuiltProviderConfigs.map(async (prebuiltProviderConfig) => {
            const packageName = this.convertFromPackageNameToNpm(prebuiltProviderConfig.name);
            const providerInformation = await (0, prebuilt_providers_1.getPrebuiltProviderVersionInformation)(packageName, prebuiltProviderConfig.version);
            return {
                ...providerInformation,
                packageName: prebuiltProviderConfig.name,
            };
        }));
        const constraints = new local_provider_constraints_1.LocalProviderConstraints();
        const localProvidersInfo = await Promise.all(localProviderConfigs.map(async (localProviderConfig) => {
            const constraint = ProviderConstraint.fromConfigEntry(localProviderConfig);
            const version = await localVersions.versionForProvider(constraint.simplifiedName);
            const constraintValue = await constraints.constraintForProvider(constraint.simplifiedName);
            return {
                providerName: constraint.simplifiedName,
                providerConstraint: constraintValue || constraint.version,
                providerVersion: version,
            };
        }));
        return {
            local: localProvidersInfo,
            prebuilt: prebuiltProvidersInfo,
        };
    }
}
exports.DependencyManager = DependencyManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwZW5kZW5jeS1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZGVwZW5kZW5jeS1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyw0Q0FLd0I7QUFDeEIseUNBQXNEO0FBQ3RELGtEQUE4QztBQUM5QyxpRUFBNEQ7QUFDNUQsdURBQW1EO0FBQ25ELDZEQUs4QjtBQUM5QixpREFBa0Q7QUFDbEQsK0RBQWlFO0FBQ2pFLCtDQUFpQztBQUNqQyx3RUFBbUU7QUFDbkUsOEVBQXlFO0FBRXpFLGlGQUFpRjtBQUNwRSxRQUFBLGdCQUFnQixHQUFHLHVCQUF1QixDQUFDO0FBQzNDLFFBQUEsaUJBQWlCLEdBQUcsV0FBVyxDQUFDO0FBQzdDLFNBQVMsdUJBQXVCLENBQUMsTUFBYztJQUM3Qyx3Q0FBd0M7SUFDeEMsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQzdDLFFBQVEsT0FBTyxFQUFFO1FBQ2YsS0FBSyxDQUFDO1lBQ0osT0FBTyxHQUFHLHdCQUFnQixJQUFJLHlCQUFpQixJQUFJLE1BQU0sRUFBRSxDQUFDO1FBQzlELEtBQUssQ0FBQztZQUNKLE9BQU8sR0FBRyx3QkFBZ0IsSUFBSSxNQUFNLEVBQUUsQ0FBQztRQUN6QztZQUNFLE9BQU8sTUFBTSxDQUFDO0tBQ2pCO0FBQ0gsQ0FBQztBQUVELE1BQWEsa0JBQWtCO0lBTzdCLG1FQUFtRTtJQUNuRSxzRUFBc0U7SUFDdEUsNEdBQTRHO0lBQzVHLFlBQVksTUFBYyxFQUFrQixPQUEyQjtRQUEzQixZQUFPLEdBQVAsT0FBTyxDQUFvQjtRQUNyRSxJQUFJLENBQUMsTUFBTSxHQUFHLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRCxNQUFNLENBQUMsZUFBZSxDQUNwQixRQUFnRDtRQUVoRCxJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsRUFBRTtZQUNoQyxNQUFNLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDM0MsT0FBTyxJQUFJLGtCQUFrQixDQUMzQixHQUFHLENBQUMsSUFBSSxFQUFFLEVBQ1YsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FDckMsQ0FBQztTQUNIO1FBRUQsTUFBTSxHQUFHLEdBQ1AsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ3BELENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFckMsT0FBTyxJQUFJLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVNLHVCQUF1QjtRQUM1QixPQUFPLElBQUksQ0FBQyxRQUFRLEtBQUssd0JBQWdCLENBQUM7SUFDNUMsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQVcsU0FBUztRQUNsQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFXLElBQUk7UUFDYixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFXLFFBQVE7UUFDakIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBVyxjQUFjO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLE1BQU07YUFDZixLQUFLLENBQUMsR0FBRyxDQUFDO2FBQ1YsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLEtBQUssd0JBQWdCLElBQUksSUFBSSxLQUFLLHlCQUFpQixDQUFDO2FBQ3pFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNmLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksY0FBYyxDQUFDLE9BQWU7UUFDbkMsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2hCLE9BQU8sSUFBQSw4Q0FBd0IsRUFBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ3hEO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU0sUUFBUTtRQUNiLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUNuRSxDQUFDO0NBQ0Y7QUF0RkQsZ0RBc0ZDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLGlCQUFpQjtJQUc1QixZQUNtQixjQUF3QixFQUNqQyxZQUFvQixFQUNYLGdCQUF3QjtRQUZ4QixtQkFBYyxHQUFkLGNBQWMsQ0FBVTtRQUNqQyxpQkFBWSxHQUFaLFlBQVksQ0FBUTtRQUNYLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBUTtRQUV6QyxJQUFJLENBQUMsY0FBYyxHQUFHLGdDQUFjLENBQUMsV0FBVyxDQUM5QyxjQUFjLEVBQ2QsSUFBSSxDQUFDLGdCQUFnQixDQUN0QixDQUFDO0lBQ0osQ0FBQztJQUVELEtBQUssQ0FBQyxXQUFXLENBQ2YsVUFBOEI7UUFFOUIsSUFBSSxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUM5QyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUMzQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsS0FBSyxFQUFFLENBQUM7U0FDdEM7YUFBTTtZQUNMLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ3hDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxJQUFJLEVBQUUsQ0FBQztTQUNyQztJQUNILENBQUM7SUFFRCxLQUFLLENBQUMsZUFBZSxDQUFDLFVBQThCO1FBQ2xELE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxVQUFVLENBQUMsY0FBYyxLQUFLLENBQUMsQ0FBQztRQUN6RCxNQUFNLFNBQVMsR0FBRyxJQUFJLHlDQUFrQixFQUFFLENBQUM7UUFDM0MsTUFBTSxlQUFlLEdBQUcsTUFBTSxJQUFJLENBQUMsNEJBQTRCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDNUUsSUFBSSxlQUFlLEVBQUU7WUFDbkIsTUFBTSxJQUFJLENBQUMsdUJBQXVCLENBQUMsVUFBVSxFQUFFLGVBQWUsQ0FBQyxDQUFDO1lBQ2hFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxLQUFLLEVBQUUsQ0FBQztTQUN0QztRQUNELElBQUksTUFBTSxTQUFTLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzNDLE1BQU0sU0FBUyxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUMzQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxFQUFFLENBQUM7U0FDckM7UUFFRCxNQUFNLGdCQUFNLENBQUMsS0FBSyxDQUNoQixxQkFBcUIsVUFBVSxDQUFDLGNBQWMsNERBQTRELFVBQVUsQ0FBQyxjQUFjLGNBQWMsQ0FDbEosQ0FBQztJQUNKLENBQUM7SUFFRCxLQUFLLENBQUMsNEJBQTRCLENBQUMsVUFBOEI7O1FBQy9ELGdCQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsVUFBVSxDQUFDLGNBQWMsa0JBQWtCLENBQUMsQ0FBQztRQUN4RSxNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUU3RCxJQUFJLENBQUMsV0FBVztZQUFFLE9BQU8sQ0FBQyxxRUFBcUU7UUFFL0YsZ0JBQU0sQ0FBQyxLQUFLLENBQ1YscUJBQXFCLFdBQVcsNERBQTRELENBQzdGLENBQUM7UUFFRixJQUFJLGlCQUFpQixDQUFDO1FBQ3RCLElBQUk7WUFDRixpQkFBaUIsR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztTQUN0RTtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNsRDtRQUVELGdCQUFNLENBQUMsS0FBSyxDQUNWLDZCQUE2QixJQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxDQUMxRSxDQUFDO1FBRUYsT0FBTyxNQUFBLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksS0FBSyxXQUFXLENBQUMsMENBQUUsT0FBTyxDQUFDO0lBQzVFLENBQUM7SUFFRCxLQUFLLENBQUMsdUJBQXVCLENBQzNCLFVBQThCLEVBQzlCLGNBQXNCO1FBRXRCLGdCQUFNLENBQUMsS0FBSyxDQUNWLDRDQUE0QyxVQUFVLENBQUMsY0FBYyxFQUFFLENBQ3hFLENBQUM7UUFFRixNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDMUQsTUFBTSxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsMEJBQTBCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFekUsZ0JBQU0sQ0FBQyxLQUFLLENBQUMsaUJBQWlCLFdBQVcsSUFBSSxjQUFjLEVBQUUsQ0FBQyxDQUFDO1FBQy9ELElBQUksY0FBYyxLQUFLLGNBQWMsRUFBRTtZQUNyQyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxjQUFjLENBQUMsQ0FBQztTQUNuRTthQUFNO1lBQ0wsT0FBTyxDQUFDLEdBQUcsQ0FDVCx5QkFBeUIsV0FBVywwQkFBMEIsY0FBYyxFQUFFLENBQy9FLENBQUM7U0FDSDtJQUNILENBQUM7SUFFRCxLQUFLLENBQUMsbUJBQW1CLENBQUMsVUFBOEI7UUFDdEQsZ0JBQU0sQ0FBQyxLQUFLLENBQ1YscURBQXFELFVBQVUsQ0FBQyxNQUFNLDRCQUE0QixVQUFVLENBQUMsT0FBTyxzQkFBc0IsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUM5SixDQUFDO1FBRUYsZ0JBQU0sQ0FBQyxJQUFJLENBQUM7Y0FDRixVQUFVLENBQUMsY0FBYztjQUN6QixVQUFVLENBQUMsT0FBTyxJQUFJLFFBQVE7Y0FDOUIsSUFBSSxDQUFDLGNBQWM7Y0FDbkIsSUFBSSxDQUFDLFlBQVk7Q0FDOUIsQ0FBQyxDQUFDO1FBRUMsSUFDRSxJQUFJLENBQUMsY0FBYyxLQUFLLGtCQUFRLENBQUMsRUFBRTtZQUNuQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDLEVBQ3RDO1lBQ0EsZ0JBQU0sQ0FBQyxJQUFJLENBQ1QseUVBQXlFLENBQzFFLENBQUM7WUFDRixPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsTUFBTSxDQUFDLEdBQUcsTUFBTSxJQUFBLGdEQUEyQixFQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDM0UsTUFBTSxNQUFNLEdBQUcsQ0FBQyxLQUFLLElBQUksQ0FBQztRQUUxQixJQUFJLE1BQU0sRUFBRTtZQUNWLGdCQUFNLENBQUMsSUFBSSxDQUFDLDJCQUEyQixDQUFDLENBQUM7U0FDMUM7YUFBTTtZQUNMLGdCQUFNLENBQUMsSUFBSSxDQUNULDhEQUE4RCxDQUMvRCxDQUFDO1NBQ0g7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRU8sS0FBSyxDQUFDLGlCQUFpQixDQUM3QixVQUE4QjtRQUU5QixNQUFNLGNBQWMsR0FBRyxNQUFNLElBQUEsc0NBQWlCLEVBQUMsVUFBVSxDQUFDLENBQUM7UUFFM0QsSUFBSSxDQUFDLGNBQWM7WUFBRSxPQUFPO1FBRTVCLE1BQU0sMEJBQTBCLEdBQUcsTUFBTSxJQUFBLHNEQUFpQyxFQUN4RSxjQUFjLENBQ2YsQ0FBQztRQUVGLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO0lBQzdFLENBQUM7SUFFTyxLQUFLLENBQUMsY0FBYyxDQUMxQixVQUE4QjtRQUU5QixNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUM3RCxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sZ0JBQU0sQ0FBQyxLQUFLLENBQ2hCLHlDQUF5QyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQzdELENBQUM7U0FDSDtRQUNELE9BQU8sV0FBVyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxLQUFLLENBQUMsMEJBQTBCLENBQUMsVUFBOEI7UUFDN0QsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTFELE1BQU0sMkJBQTJCLEdBQUcsTUFBTSxJQUFBLGdEQUEyQixFQUNuRSxVQUFVLEVBQ1YsSUFBSSxDQUFDLFlBQVksQ0FDbEIsQ0FBQztRQUNGLElBQUksQ0FBQywyQkFBMkIsRUFBRTtZQUNoQyxNQUFNLGdCQUFNLENBQUMsS0FBSyxDQUNoQixtQ0FBbUMsVUFBVSxDQUFDLE1BQU0sNEJBQTRCLFVBQVUsQ0FBQyxPQUFPLHNCQUFzQixJQUFJLENBQUMsWUFBWSxFQUFFLENBQzVJLENBQUM7U0FDSDtRQUVELE1BQU0sY0FBYyxHQUFHLE1BQU0sSUFBSSxDQUFDLGlDQUFpQyxDQUNqRSxXQUFXLEVBQ1gsMkJBQTJCLENBQzVCLENBQUM7UUFFRixJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ25CLE1BQU0sZ0JBQU0sQ0FBQyxLQUFLLENBQ2hCLG1DQUFtQyxVQUFVLENBQUMsTUFBTSw0QkFBNEIsVUFBVSxDQUFDLE9BQU8sc0JBQXNCLElBQUksQ0FBQyxZQUFZLGlCQUFpQixJQUFJLENBQUMsY0FBYyxHQUFHLENBQ2pMLENBQUM7U0FDSDtRQUVELE9BQU8sY0FBYyxDQUFDO0lBQ3hCLENBQUM7SUFFRCxLQUFLLENBQUMsbUJBQW1CLENBQUMsVUFBOEIsRUFBRSxNQUFNLEdBQUcsS0FBSztRQUN0RSxnQkFBTSxDQUFDLEtBQUssQ0FDViw2QkFBNkIsVUFBVSxDQUFDLE1BQU0sNEJBQTRCLFVBQVUsQ0FBQyxPQUFPLHNCQUFzQixJQUFJLENBQUMsWUFBWSxFQUFFLENBQ3RJLENBQUM7UUFFRixNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDMUQsTUFBTSxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsMEJBQTBCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDekUsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsY0FBYyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRTFFLHdCQUF3QjtJQUMxQixDQUFDO0lBRUQsZ0VBQWdFO0lBQ2hFLGtHQUFrRztJQUNsRyxrSEFBa0g7SUFDMUcsS0FBSyxDQUFDLGlDQUFpQyxDQUM3QyxXQUFtQixFQUNuQiwyQkFBcUM7UUFFckMsZ0JBQU0sQ0FBQyxLQUFLLENBQ1Ysc0RBQXNELEVBQ3RELDJCQUEyQixDQUM1QixDQUFDO1FBQ0YsZ0JBQU0sQ0FBQyxLQUFLLENBQ1YsdUZBQXVGLENBQ3hGLENBQUM7UUFFRixLQUFLLE1BQU0sT0FBTyxJQUFJLDJCQUEyQixFQUFFO1lBQ2pELElBQUk7Z0JBQ0YsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLHFCQUFxQixDQUNqRSxXQUFXLEVBQ1gsT0FBTyxDQUNSLENBQUM7Z0JBQ0YsSUFBSSxXQUFXLEVBQUU7b0JBQ2YsT0FBTyxPQUFPLENBQUM7aUJBQ2hCO2FBQ0Y7WUFBQyxPQUFPLEdBQUcsRUFBRTtnQkFDWixnQkFBTSxDQUFDLElBQUksQ0FDVCwwQkFBMEIsT0FBTyxnQkFBZ0IsV0FBVyxNQUFNLEdBQUcsZ0JBQWdCLENBQ3RGLENBQUM7YUFDSDtTQUNGO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsS0FBSyxDQUFDLGdCQUFnQixDQUFDLFVBQThCO1FBQ25ELGdCQUFNLENBQUMsSUFBSSxDQUNULHlCQUF5QixVQUFVLENBQUMsTUFBTSw0QkFBNEIsVUFBVSxDQUFDLE9BQU8sZ0JBQWdCLENBQ3pHLENBQUM7UUFFRixJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sSUFBSSxVQUFVLENBQUMsdUJBQXVCLEVBQUUsRUFBRTtZQUMvRCxNQUFNLENBQUMsR0FBRyxNQUFNLElBQUEsK0JBQWdCLEVBQUMsVUFBVSxDQUFDLENBQUM7WUFDN0MsSUFBSSxDQUFDLEVBQUU7Z0JBQ0wsVUFBVSxHQUFHLElBQUksa0JBQWtCLENBQ2pDLFVBQVUsQ0FBQyxNQUFNO2dCQUNqQixzQkFBc0I7Z0JBQ3RCLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUMzQyxDQUFDO2FBQ0g7aUJBQU07Z0JBQ0wsTUFBTSxnQkFBTSxDQUFDLEtBQUssQ0FDaEIsOENBQThDLFVBQVUsaUpBQWlKLENBQzFNLENBQUM7YUFDSDtTQUNGO1FBRUQsTUFBTSxJQUFJLHlDQUFrQixFQUFFLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFRDs7T0FFRztJQUNLLGtCQUFrQixDQUFDLElBQVksRUFBRSxVQUFrQjtRQUN6RCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGtCQUFrQixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzFELFFBQVEsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUMzQixLQUFLLGtCQUFRLENBQUMsRUFBRSxFQUFFLDRFQUE0RTtnQkFDNUYsSUFBSSxVQUFVLEVBQUU7b0JBQ2QsT0FBTyxHQUFHLFVBQVUsT0FBTyxZQUFZLEVBQUUsQ0FBQztpQkFDM0M7Z0JBRUQsT0FBTyxtQ0FBbUMsWUFBWSxPQUFPLFlBQVksRUFBRSxDQUFDO1lBQzlFLEtBQUssa0JBQVEsQ0FBQyxVQUFVLEVBQUUsOEJBQThCO2dCQUN0RCxPQUFPLElBQUksQ0FBQyxDQUFDLDJCQUEyQjtZQUMxQyxLQUFLLGtCQUFRLENBQUMsTUFBTSxFQUFFLGtEQUFrRDtnQkFDdEUsT0FBTyw0QkFBNEIsR0FBRyxJQUFBLHdCQUFZLEVBQUMsWUFBWSxDQUFDLENBQUM7WUFDbkUsS0FBSyxrQkFBUSxDQUFDLElBQUksRUFBRSxzQ0FBc0M7Z0JBQ3hELE9BQU8sZ0NBQWdDLFlBQVksRUFBRSxDQUFDO1lBQ3hELEtBQUssa0JBQVEsQ0FBQyxNQUFNLEVBQUUsNkNBQTZDO2dCQUNqRSxPQUFPLHdCQUF3QixZQUFZLEVBQUUsQ0FBQztZQUNoRDtnQkFDRSxNQUFNLElBQUksS0FBSyxDQUNiLHdDQUF3QyxJQUFJLENBQUMsY0FBYyxzQkFBc0IsQ0FDbEYsQ0FBQztTQUNMO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNLLDJCQUEyQixDQUFDLElBQVk7UUFDOUMsTUFBTSxnQkFBZ0IsR0FBRyxrQkFBa0IsQ0FBQztRQUM1QyxNQUFNLE9BQU8sR0FBRztZQUNkLENBQUMsa0JBQVEsQ0FBQyxFQUFFLENBQUMsRUFDWCw0REFBNEQ7WUFDOUQsQ0FBQyxrQkFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFLE9BQU87WUFDOUIsQ0FBQyxrQkFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLG9DQUFvQztZQUN2RCxDQUFDLGtCQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsc0NBQXNDO1lBQ3ZELENBQUMsa0JBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSw0QkFBNEI7U0FDaEQsQ0FBQztRQUNGLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNWLE1BQU0sZ0JBQU0sQ0FBQyxLQUFLLENBQUMsZ0RBQWdELENBQUMsQ0FBQztTQUN0RTtRQUVELE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDL0IsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDcEU7UUFFRCxRQUFRLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDM0IsS0FBSyxrQkFBUSxDQUFDLEVBQUUsRUFBRSw0RUFBNEU7Z0JBQzVGLE9BQU8sZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLEtBQUssa0JBQVEsQ0FBQyxVQUFVLEVBQUUsOEJBQThCO2dCQUN0RCxPQUFPLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLDJCQUEyQjtZQUM5QyxLQUFLLGtCQUFRLENBQUMsTUFBTSxFQUFFLGtEQUFrRDtnQkFDdEUsT0FBTyxnQkFBZ0IsR0FBRyxJQUFBLHVCQUFXLEVBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEQsS0FBSyxrQkFBUSxDQUFDLElBQUksRUFBRSxzQ0FBc0M7Z0JBQ3hELE9BQU8sZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLEtBQUssa0JBQVEsQ0FBQyxNQUFNLEVBQUUsNkNBQTZDO2dCQUNqRSxPQUFPLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyQztnQkFDRSxNQUFNLElBQUksS0FBSyxDQUNiLHdDQUF3QyxJQUFJLENBQUMsY0FBYyxzQkFBc0IsQ0FDbEYsQ0FBQztTQUNMO0lBQ0gsQ0FBQztJQUVNLEtBQUssQ0FBQyxZQUFZO1FBQ3ZCLE1BQU0sU0FBUyxHQUFHLDBCQUFXLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDckMsTUFBTSxhQUFhLEdBQUcsSUFBSSwrQ0FBcUIsRUFBRSxDQUFDO1FBRWxELE1BQU0sb0JBQW9CLEdBQUcsU0FBUyxDQUFDLGtCQUFrQixDQUFDO1FBQzFELE1BQU0sdUJBQXVCLEdBQzNCLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1FBRW5ELE1BQU0scUJBQXFCLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUM3Qyx1QkFBdUIsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLHNCQUFzQixFQUFFLEVBQUU7WUFDM0QsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLDJCQUEyQixDQUNsRCxzQkFBc0IsQ0FBQyxJQUFJLENBQzVCLENBQUM7WUFFRixNQUFNLG1CQUFtQixHQUFHLE1BQU0sSUFBQSwwREFBcUMsRUFDckUsV0FBVyxFQUNYLHNCQUFzQixDQUFDLE9BQU8sQ0FDL0IsQ0FBQztZQUVGLE9BQU87Z0JBQ0wsR0FBRyxtQkFBbUI7Z0JBQ3RCLFdBQVcsRUFBRSxzQkFBc0IsQ0FBQyxJQUFJO2FBQ3pDLENBQUM7UUFDSixDQUFDLENBQUMsQ0FDSCxDQUFDO1FBRUYsTUFBTSxXQUFXLEdBQUcsSUFBSSxxREFBd0IsRUFBRSxDQUFDO1FBRW5ELE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUMxQyxvQkFBb0IsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLG1CQUFtQixFQUFFLEVBQUU7WUFDckQsTUFBTSxVQUFVLEdBQ2Qsa0JBQWtCLENBQUMsZUFBZSxDQUFDLG1CQUFtQixDQUFDLENBQUM7WUFDMUQsTUFBTSxPQUFPLEdBQUcsTUFBTSxhQUFhLENBQUMsa0JBQWtCLENBQ3BELFVBQVUsQ0FBQyxjQUFjLENBQzFCLENBQUM7WUFDRixNQUFNLGVBQWUsR0FBRyxNQUFNLFdBQVcsQ0FBQyxxQkFBcUIsQ0FDN0QsVUFBVSxDQUFDLGNBQWMsQ0FDMUIsQ0FBQztZQUVGLE9BQU87Z0JBQ0wsWUFBWSxFQUFFLFVBQVUsQ0FBQyxjQUFjO2dCQUN2QyxrQkFBa0IsRUFBRSxlQUFlLElBQUksVUFBVSxDQUFDLE9BQU87Z0JBQ3pELGVBQWUsRUFBRSxPQUFPO2FBQ3pCLENBQUM7UUFDSixDQUFDLENBQUMsQ0FDSCxDQUFDO1FBRUYsT0FBTztZQUNMLEtBQUssRUFBRSxrQkFBa0I7WUFDekIsUUFBUSxFQUFFLHFCQUFxQjtTQUNoQyxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBL1dELDhDQStXQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgSGFzaGlDb3JwLCBJbmNcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNUEwtMi4wXG5pbXBvcnQge1xuICBMYW5ndWFnZSxcbiAgRXJyb3JzLFxuICBsb2dnZXIsXG4gIFRlcnJhZm9ybURlcGVuZGVuY3lDb25zdHJhaW50LFxufSBmcm9tIFwiQGNka3RmL2NvbW1vbnNcIjtcbmltcG9ydCB7IHRvUGFzY2FsQ2FzZSwgdG9TbmFrZUNhc2UgfSBmcm9tIFwiY29kZW1ha2VyXCI7XG5pbXBvcnQgeyBDZGt0ZkNvbmZpZyB9IGZyb20gXCIuLi9jZGt0Zi1jb25maWdcIjtcbmltcG9ydCB7IENka3RmQ29uZmlnTWFuYWdlciB9IGZyb20gXCIuL2Nka3RmLWNvbmZpZy1tYW5hZ2VyXCI7XG5pbXBvcnQgeyBQYWNrYWdlTWFuYWdlciB9IGZyb20gXCIuL3BhY2thZ2UtbWFuYWdlclwiO1xuaW1wb3J0IHtcbiAgZ2V0TnBtUGFja2FnZU5hbWUsXG4gIGdldFByZWJ1aWx0UHJvdmlkZXJSZXBvc2l0b3J5TmFtZSxcbiAgZ2V0UHJlYnVpbHRQcm92aWRlclZlcnNpb25JbmZvcm1hdGlvbixcbiAgZ2V0UHJlYnVpbHRQcm92aWRlclZlcnNpb25zLFxufSBmcm9tIFwiLi9wcmVidWlsdC1wcm92aWRlcnNcIjtcbmltcG9ydCB7IGdldExhdGVzdFZlcnNpb24gfSBmcm9tIFwiLi9yZWdpc3RyeS1hcGlcIjtcbmltcG9ydCB7IHZlcnNpb25NYXRjaGVzQ29uc3RyYWludCB9IGZyb20gXCIuL3ZlcnNpb24tY29uc3RyYWludHNcIjtcbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tIFwic2VtdmVyXCI7XG5pbXBvcnQgeyBMb2NhbFByb3ZpZGVyVmVyc2lvbnMgfSBmcm9tIFwiLi4vbG9jYWwtcHJvdmlkZXItdmVyc2lvbnNcIjtcbmltcG9ydCB7IExvY2FsUHJvdmlkZXJDb25zdHJhaW50cyB9IGZyb20gXCIuLi9sb2NhbC1wcm92aWRlci1jb25zdHJhaW50c1wiO1xuXG4vLyByZWY6IGh0dHBzOi8vd3d3LnRlcnJhZm9ybS5pby9sYW5ndWFnZS9wcm92aWRlcnMvcmVxdWlyZW1lbnRzI3NvdXJjZS1hZGRyZXNzZXNcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hPU1ROQU1FID0gXCJyZWdpc3RyeS50ZXJyYWZvcm0uaW9cIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX05BTUVTUEFDRSA9IFwiaGFzaGljb3JwXCI7XG5mdW5jdGlvbiBub3JtYWxpemVQcm92aWRlclNvdXJjZShzb3VyY2U6IHN0cmluZykge1xuICAvLyByZXR1cm5zIDxIT1NUTkFNRT4vPE5BTUVTUEFDRT4vPFRZUEU+XG4gIGNvbnN0IHNsYXNoZXMgPSBzb3VyY2Uuc3BsaXQoXCIvXCIpLmxlbmd0aCAtIDE7XG4gIHN3aXRjaCAoc2xhc2hlcykge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBgJHtERUZBVUxUX0hPU1ROQU1FfS8ke0RFRkFVTFRfTkFNRVNQQUNFfS8ke3NvdXJjZX1gO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBgJHtERUZBVUxUX0hPU1ROQU1FfS8ke3NvdXJjZX1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc291cmNlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm92aWRlckNvbnN0cmFpbnQge1xuICAvKipcbiAgICogbm9ybWFsaXplZCBzb3VyY2Ugb2YgdGhlIHByb3ZpZGVyXG4gICAqIGUuZy4gXCJyZWdpc3RyeS50ZXJyYWZvcm0uaW8vaGFzaGljb3JwL2F3c1wiXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgc291cmNlOiBzdHJpbmc7XG5cbiAgLy8gVE9ETzogYWRkIGV4YW1wbGVzIHRvIGNsaSBjb21tYW5kIGRlc2NyaXB0aW9uIChpLmUuID0sfj4uPiBldGMuKVxuICAvLyBpZiBubyB2ZXJzaW9uIGNvbnN0cmFpbnQgaXMgc3BlY2lmaWVkLCB3ZSBhc3N1bWUgdGhlIGxhdGVzdCB2ZXJzaW9uXG4gIC8vIGlmIHNwZWNpZmljIHZlcnNpb24gaXMgc3BlY2lmaWVkIHdpdGhvdXQgZS5nLiA9LCB3ZSBhbGxvdyBwYXRjaCBsZXZlbCBpbmNyZW1lbnRzIChlLmcuIH4+Mi4xMiBmb3IgXCIyLjEyXCIpXG4gIGNvbnN0cnVjdG9yKHNvdXJjZTogc3RyaW5nLCBwdWJsaWMgcmVhZG9ubHkgdmVyc2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBub3JtYWxpemVQcm92aWRlclNvdXJjZShzb3VyY2UpO1xuICB9XG5cbiAgc3RhdGljIGZyb21Db25maWdFbnRyeShcbiAgICBwcm92aWRlcjogc3RyaW5nIHwgVGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnRcbiAgKTogUHJvdmlkZXJDb25zdHJhaW50IHtcbiAgICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBbc3JjLCB2ZXJzaW9uXSA9IHByb3ZpZGVyLnNwbGl0KFwiQFwiKTtcbiAgICAgIHJldHVybiBuZXcgUHJvdmlkZXJDb25zdHJhaW50KFxuICAgICAgICBzcmMudHJpbSgpLFxuICAgICAgICB2ZXJzaW9uID8gdmVyc2lvbi50cmltKCkgOiB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3JjID1cbiAgICAgIChwcm92aWRlci5uYW1lc3BhY2UgPyBgJHtwcm92aWRlci5uYW1lc3BhY2V9L2AgOiBcIlwiKSArXG4gICAgICAocHJvdmlkZXIuc291cmNlIHx8IHByb3ZpZGVyLm5hbWUpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm92aWRlckNvbnN0cmFpbnQoc3JjLCBwcm92aWRlci52ZXJzaW9uKTtcbiAgfVxuXG4gIHB1YmxpYyBpc0Zyb21UZXJyYWZvcm1SZWdpc3RyeSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5ob3N0bmFtZSA9PT0gREVGQVVMVF9IT1NUTkFNRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGUgbmFtZXNwYWNlIG9mIHRoZSBwcm92aWRlclxuICAgKiBlLmcuIFwiaGFzaGljb3JwXCIgb3IgXCJrcmV1endlcmtlclwiXG4gICAqL1xuICBwdWJsaWMgZ2V0IG5hbWVzcGFjZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5zcGxpdChcIi9cIilbMV07XG4gIH1cblxuICAvKipcbiAgICogdGhlIG5hbWUgb2YgdGhlIHByb3ZpZGVyXG4gICAqIGUuZy4gXCJhd3NcIlxuICAgKi9cbiAgcHVibGljIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLnNwbGl0KFwiL1wiKVsyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGUgaG9zdG5hbWUgb2YgdGhlIHByb3ZpZGVyXG4gICAqIGUuZy4gXCJyZWdpc3RyeS50ZXJyYWZvcm0uaW9cIlxuICAgKi9cbiAgcHVibGljIGdldCBob3N0bmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5zcGxpdChcIi9cIilbMF07XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBhIHNpbXBsaWZpZWQgcHJvdmlkZXIgbmFtZSwgZHJvcHBpbmcgbmFtZXNwYWNlIGFuZCBob3N0bmFtZVxuICAgKiBpZiB0aGV5IG1hdGNoIHRoZSBkZWZhdWx0c1xuICAgKi9cbiAgcHVibGljIGdldCBzaW1wbGlmaWVkTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZVxuICAgICAgLnNwbGl0KFwiL1wiKVxuICAgICAgLmZpbHRlcigocGFydCkgPT4gcGFydCAhPT0gREVGQVVMVF9IT1NUTkFNRSAmJiBwYXJ0ICE9PSBERUZBVUxUX05BTUVTUEFDRSlcbiAgICAgIC5qb2luKFwiL1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjaGVja3MgaWYgdGhlIHZlcnNpb24gY29uc3RyYWludCBtYXRjaGVzIHRoZSBnaXZlbiB2ZXJzaW9uXG4gICAqIEBwYXJhbSB2ZXJzaW9uIGFuIGFjdHVhbCB2ZXJzaW9uIChlLmcuIFwiNC4xMi4xXCIpXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHZlcnNpb24gaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjb25zdHJhaW50XG4gICAqL1xuICBwdWJsaWMgbWF0Y2hlc1ZlcnNpb24odmVyc2lvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMudmVyc2lvbikge1xuICAgICAgcmV0dXJuIHZlcnNpb25NYXRjaGVzQ29uc3RyYWludCh2ZXJzaW9uLCB0aGlzLnZlcnNpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5zb3VyY2V9JHt0aGlzLnZlcnNpb24gPyBgQCR7dGhpcy52ZXJzaW9ufWAgOiBcIlwifWA7XG4gIH1cbn1cblxuLyoqXG4gKiBtYW5hZ2VzIGRlcGVuZGVuY2llcyBvZiBhIENES1RGIHByb2plY3QgKGUuZy4gdGVycmFmb3JtIHByb3ZpZGVycylcbiAqL1xuZXhwb3J0IGNsYXNzIERlcGVuZGVuY3lNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBwYWNrYWdlTWFuYWdlcjogUGFja2FnZU1hbmFnZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgcHJpdmF0ZSBjZGt0ZlZlcnNpb246IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByb2plY3REaXJlY3Rvcnk6IHN0cmluZ1xuICApIHtcbiAgICB0aGlzLnBhY2thZ2VNYW5hZ2VyID0gUGFja2FnZU1hbmFnZXIuZm9yTGFuZ3VhZ2UoXG4gICAgICB0YXJnZXRMYW5ndWFnZSxcbiAgICAgIHRoaXMucHJvamVjdERpcmVjdG9yeVxuICAgICk7XG4gIH1cblxuICBhc3luYyBhZGRQcm92aWRlcihcbiAgICBjb25zdHJhaW50OiBQcm92aWRlckNvbnN0cmFpbnRcbiAgKTogUHJvbWlzZTx7IGFkZGVkTG9jYWxQcm92aWRlcjogYm9vbGVhbiB9PiB7XG4gICAgaWYgKGF3YWl0IHRoaXMuaGFzUHJlYnVpbHRQcm92aWRlcihjb25zdHJhaW50KSkge1xuICAgICAgYXdhaXQgdGhpcy5hZGRQcmVidWlsdFByb3ZpZGVyKGNvbnN0cmFpbnQpO1xuICAgICAgcmV0dXJuIHsgYWRkZWRMb2NhbFByb3ZpZGVyOiBmYWxzZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCB0aGlzLmFkZExvY2FsUHJvdmlkZXIoY29uc3RyYWludCk7XG4gICAgICByZXR1cm4geyBhZGRlZExvY2FsUHJvdmlkZXI6IHRydWUgfTtcbiAgICB9XG4gIH1cblxuICBhc3luYyB1cGdyYWRlUHJvdmlkZXIoY29uc3RyYWludDogUHJvdmlkZXJDb25zdHJhaW50KSB7XG4gICAgY29uc29sZS5sb2coYFVwZ3JhZGluZyAke2NvbnN0cmFpbnQuc2ltcGxpZmllZE5hbWV9Li4uYCk7XG4gICAgY29uc3QgY2RrdGZKc29uID0gbmV3IENka3RmQ29uZmlnTWFuYWdlcigpO1xuICAgIGNvbnN0IHByZWJ1aWx0VmVyc2lvbiA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudGx5SW5zdGFsbGVkVmVyc2lvbihjb25zdHJhaW50KTtcbiAgICBpZiAocHJlYnVpbHRWZXJzaW9uKSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZ3JhZGVQcmVidWlsdFByb3ZpZGVyKGNvbnN0cmFpbnQsIHByZWJ1aWx0VmVyc2lvbik7XG4gICAgICByZXR1cm4geyBhZGRlZExvY2FsUHJvdmlkZXI6IGZhbHNlIH07XG4gICAgfVxuICAgIGlmIChhd2FpdCBjZGt0Zkpzb24uaGFzUHJvdmlkZXIoY29uc3RyYWludCkpIHtcbiAgICAgIGF3YWl0IGNka3RmSnNvbi51cGRhdGVQcm92aWRlcihjb25zdHJhaW50KTtcbiAgICAgIHJldHVybiB7IGFkZGVkTG9jYWxQcm92aWRlcjogdHJ1ZSB9O1xuICAgIH1cblxuICAgIHRocm93IEVycm9ycy5Vc2FnZShcbiAgICAgIGBUcnlpbmcgdG8gdXBncmFkZSAke2NvbnN0cmFpbnQuc2ltcGxpZmllZE5hbWV9IGJ1dCBpdCBpcyBub3QgaW5zdGFsbGVkLCBwbGVhc2UgdXNlIFwiY2RrdGYgcHJvdmlkZXIgYWRkICR7Y29uc3RyYWludC5zaW1wbGlmaWVkTmFtZX1cIiB0byBhZGQgaXQuYFxuICAgICk7XG4gIH1cblxuICBhc3luYyBnZXRDdXJyZW50bHlJbnN0YWxsZWRWZXJzaW9uKGNvbnN0cmFpbnQ6IFByb3ZpZGVyQ29uc3RyYWludCkge1xuICAgIGxvZ2dlci5pbmZvKGBDaGVja2luZyBpZiAke2NvbnN0cmFpbnQuc2ltcGxpZmllZE5hbWV9IGlzIGluc3RhbGxlZC4uLmApO1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gYXdhaXQgdGhpcy50cnlHZXRQYWNrYWdlTmFtZShjb25zdHJhaW50KTtcblxuICAgIGlmICghcGFja2FnZU5hbWUpIHJldHVybjsgLy8gbm90IGF2YWlsYWJsZSBhcyBwcmUtYnVpbHQgcHJvdmlkZXIsIHNvIGNhbid0IGJlIGluc3RhbGxlZCBhcyBzdWNoXG5cbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgRXhwZWN0aW5nIHBhY2thZ2UgJHtwYWNrYWdlTmFtZX0gdG8gYmUgaW5zdGFsbGVkIGlmIHByb3ZpZGVyIGlzIGluc3RhbGxlZCBhcyBwcmUtYnVpbHQgb25lYFxuICAgICk7XG5cbiAgICBsZXQgaW5zdGFsbGVkUGFja2FnZXM7XG4gICAgdHJ5IHtcbiAgICAgIGluc3RhbGxlZFBhY2thZ2VzID0gYXdhaXQgdGhpcy5wYWNrYWdlTWFuYWdlci5saXN0UHJvdmlkZXJQYWNrYWdlcygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3QgcGFja2FnZXM6ICR7ZX1gKTtcbiAgICB9XG5cbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgSW5zdGFsbGVkIHBhY2thZ2VzIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KGluc3RhbGxlZFBhY2thZ2VzLCBudWxsLCAyKX1gXG4gICAgKTtcblxuICAgIHJldHVybiBpbnN0YWxsZWRQYWNrYWdlcy5maW5kKChwa2cpID0+IHBrZy5uYW1lID09PSBwYWNrYWdlTmFtZSk/LnZlcnNpb247XG4gIH1cblxuICBhc3luYyB1cGdyYWRlUHJlYnVpbHRQcm92aWRlcihcbiAgICBjb25zdHJhaW50OiBQcm92aWRlckNvbnN0cmFpbnQsXG4gICAgY3VycmVudFZlcnNpb246IHN0cmluZ1xuICApIHtcbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgU2VhcmNoaW5nIGZvciBsYXRlc3QgbWF0Y2hpbmcgdmVyc2lvbiBvZiAke2NvbnN0cmFpbnQuc2ltcGxpZmllZE5hbWV9YFxuICAgICk7XG5cbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9IGF3YWl0IHRoaXMuZ2V0UGFja2FnZU5hbWUoY29uc3RyYWludCk7XG4gICAgY29uc3QgcGFja2FnZVZlcnNpb24gPSBhd2FpdCB0aGlzLmdldE1hdGNoaW5nUHJvdmlkZXJWZXJzaW9uKGNvbnN0cmFpbnQpO1xuXG4gICAgbG9nZ2VyLmRlYnVnKGBGb3VuZCBwYWNrYWdlICR7cGFja2FnZU5hbWV9QCR7cGFja2FnZVZlcnNpb259YCk7XG4gICAgaWYgKHBhY2thZ2VWZXJzaW9uICE9PSBjdXJyZW50VmVyc2lvbikge1xuICAgICAgYXdhaXQgdGhpcy5wYWNrYWdlTWFuYWdlci5hZGRQYWNrYWdlKHBhY2thZ2VOYW1lLCBwYWNrYWdlVmVyc2lvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgVGhlIGxhdGVzdCB2ZXJzaW9uIG9mICR7cGFja2FnZU5hbWV9IGlzIGFscmVhZHkgaW5zdGFsbGVkOiAke3BhY2thZ2VWZXJzaW9ufWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaGFzUHJlYnVpbHRQcm92aWRlcihjb25zdHJhaW50OiBQcm92aWRlckNvbnN0cmFpbnQpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgZGV0ZXJtaW5pbmcgd2hldGhlciBwcmUtYnVpbHQgcHJvdmlkZXIgZXhpc3RzIGZvciAke2NvbnN0cmFpbnQuc291cmNlfSB3aXRoIHZlcnNpb24gY29uc3RyYWludCAke2NvbnN0cmFpbnQudmVyc2lvbn0gYW5kIGNka3RmIHZlcnNpb24gJHt0aGlzLmNka3RmVmVyc2lvbn1gXG4gICAgKTtcblxuICAgIGxvZ2dlci5pbmZvKGBDaGVja2luZyB3aGV0aGVyIHByZS1idWlsdCBwcm92aWRlciBleGlzdHMgZm9yIHRoZSBmb2xsb3dpbmcgY29uc3RyYWludHM6XG4gIHByb3ZpZGVyOiAke2NvbnN0cmFpbnQuc2ltcGxpZmllZE5hbWV9XG4gIHZlcnNpb24gOiAke2NvbnN0cmFpbnQudmVyc2lvbiB8fCBcImxhdGVzdFwifVxuICBsYW5ndWFnZTogJHt0aGlzLnRhcmdldExhbmd1YWdlfVxuICBjZGt0ZiAgIDogJHt0aGlzLmNka3RmVmVyc2lvbn1cbmApO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy50YXJnZXRMYW5ndWFnZSA9PT0gTGFuZ3VhZ2UuR08gJiZcbiAgICAgIHNlbXZlci5sdCh0aGlzLmNka3RmVmVyc2lvbiwgXCIwLjEyLjBcIilcbiAgICApIHtcbiAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICBgQmVmb3JlIENES1RGIDAuMTIuMCB0aGVyZSB3ZXJlIG5vIHByZS1idWlsdCBwcm92aWRlcnMgcHVibGlzaGVkIGZvciBHby5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHYgPSBhd2FpdCBnZXRQcmVidWlsdFByb3ZpZGVyVmVyc2lvbnMoY29uc3RyYWludCwgdGhpcy5jZGt0ZlZlcnNpb24pO1xuICAgIGNvbnN0IGV4aXN0cyA9IHYgIT09IG51bGw7XG5cbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICBsb2dnZXIuaW5mbyhgRm91bmQgcHJlLWJ1aWx0IHByb3ZpZGVyLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuaW5mbyhcbiAgICAgICAgYFByZS1idWlsdCBwcm92aWRlciBkb2VzIG5vdCBleGlzdCBmb3IgdGhlIGdpdmVuIGNvbnN0cmFpbnRzLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4aXN0cztcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgdHJ5R2V0UGFja2FnZU5hbWUoXG4gICAgY29uc3RyYWludDogUHJvdmlkZXJDb25zdHJhaW50XG4gICk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgbnBtUGFja2FnZU5hbWUgPSBhd2FpdCBnZXROcG1QYWNrYWdlTmFtZShjb25zdHJhaW50KTtcblxuICAgIGlmICghbnBtUGFja2FnZU5hbWUpIHJldHVybjtcblxuICAgIGNvbnN0IHByZWJ1aWx0UHJvdmlkZXJSZXBvc2l0b3J5ID0gYXdhaXQgZ2V0UHJlYnVpbHRQcm92aWRlclJlcG9zaXRvcnlOYW1lKFxuICAgICAgbnBtUGFja2FnZU5hbWVcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuY29udmVydFBhY2thZ2VOYW1lKG5wbVBhY2thZ2VOYW1lLCBwcmVidWlsdFByb3ZpZGVyUmVwb3NpdG9yeSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldFBhY2thZ2VOYW1lKFxuICAgIGNvbnN0cmFpbnQ6IFByb3ZpZGVyQ29uc3RyYWludFxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gYXdhaXQgdGhpcy50cnlHZXRQYWNrYWdlTmFtZShjb25zdHJhaW50KTtcbiAgICBpZiAoIXBhY2thZ2VOYW1lKSB7XG4gICAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoXG4gICAgICAgIGBDb3VsZCBub3QgZmluZCBwcmUtYnVpbHQgcHJvdmlkZXIgZm9yICR7Y29uc3RyYWludC5zb3VyY2V9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhY2thZ2VOYW1lO1xuICB9XG5cbiAgYXN5bmMgZ2V0TWF0Y2hpbmdQcm92aWRlclZlcnNpb24oY29uc3RyYWludDogUHJvdmlkZXJDb25zdHJhaW50KSB7XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSBhd2FpdCB0aGlzLmdldFBhY2thZ2VOYW1lKGNvbnN0cmFpbnQpO1xuXG4gICAgY29uc3QgcHJlYnVpbHRQcm92aWRlck5wbVZlcnNpb25zID0gYXdhaXQgZ2V0UHJlYnVpbHRQcm92aWRlclZlcnNpb25zKFxuICAgICAgY29uc3RyYWludCxcbiAgICAgIHRoaXMuY2RrdGZWZXJzaW9uXG4gICAgKTtcbiAgICBpZiAoIXByZWJ1aWx0UHJvdmlkZXJOcG1WZXJzaW9ucykge1xuICAgICAgdGhyb3cgRXJyb3JzLlVzYWdlKFxuICAgICAgICBgTm8gcHJlLWJ1aWx0IHByb3ZpZGVyIGZvdW5kIGZvciAke2NvbnN0cmFpbnQuc291cmNlfSB3aXRoIHZlcnNpb24gY29uc3RyYWludCAke2NvbnN0cmFpbnQudmVyc2lvbn0gYW5kIGNka3RmIHZlcnNpb24gJHt0aGlzLmNka3RmVmVyc2lvbn1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHBhY2thZ2VWZXJzaW9uID0gYXdhaXQgdGhpcy5nZXRMYW5ndWFnZVNwZWNpZmljUGFja2FnZVZlcnNpb24oXG4gICAgICBwYWNrYWdlTmFtZSxcbiAgICAgIHByZWJ1aWx0UHJvdmlkZXJOcG1WZXJzaW9uc1xuICAgICk7XG5cbiAgICBpZiAoIXBhY2thZ2VWZXJzaW9uKSB7XG4gICAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoXG4gICAgICAgIGBObyBwcmUtYnVpbHQgcHJvdmlkZXIgZm91bmQgZm9yICR7Y29uc3RyYWludC5zb3VyY2V9IHdpdGggdmVyc2lvbiBjb25zdHJhaW50ICR7Y29uc3RyYWludC52ZXJzaW9ufSBhbmQgY2RrdGYgdmVyc2lvbiAke3RoaXMuY2RrdGZWZXJzaW9ufSBmb3IgbGFuZ3VhZ2UgJHt0aGlzLnRhcmdldExhbmd1YWdlfS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwYWNrYWdlVmVyc2lvbjtcbiAgfVxuXG4gIGFzeW5jIGFkZFByZWJ1aWx0UHJvdmlkZXIoY29uc3RyYWludDogUHJvdmlkZXJDb25zdHJhaW50LCBzaWxlbnQgPSBmYWxzZSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBhZGRpbmcgcHJlLWJ1aWx0IHByb3ZpZGVyICR7Y29uc3RyYWludC5zb3VyY2V9IHdpdGggdmVyc2lvbiBjb25zdHJhaW50ICR7Y29uc3RyYWludC52ZXJzaW9ufSBmb3IgY2RrdGYgdmVyc2lvbiAke3RoaXMuY2RrdGZWZXJzaW9ufWBcbiAgICApO1xuXG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSBhd2FpdCB0aGlzLmdldFBhY2thZ2VOYW1lKGNvbnN0cmFpbnQpO1xuICAgIGNvbnN0IHBhY2thZ2VWZXJzaW9uID0gYXdhaXQgdGhpcy5nZXRNYXRjaGluZ1Byb3ZpZGVyVmVyc2lvbihjb25zdHJhaW50KTtcbiAgICBhd2FpdCB0aGlzLnBhY2thZ2VNYW5hZ2VyLmFkZFBhY2thZ2UocGFja2FnZU5hbWUsIHBhY2thZ2VWZXJzaW9uLCBzaWxlbnQpO1xuXG4gICAgLy8gVE9ETzogbW9yZSBkZWJ1ZyBsb2dzXG4gIH1cblxuICAvLyBUaGUgdmVyc2lvbiB3ZSB1c2UgZm9yIG5wbSBtaWdodCBkaWZmZXIgZnJvbSBvdGhlciByZWdpc3RyaWVzXG4gIC8vIFRoaXMgaGFwcGVucyBtb3N0bHkgaW4gY2FzZXMgd2hlcmUgYSBwcm92aWRlciB1cGRhdGUgZmFpbGVkIHRvIHB1Ymxpc2ggdG8gb25lIG9mIHRoZSByZWdpc3RyaWVzXG4gIC8vIEluIHRoYXQgY2FzZSB3ZSB1c2UgdGhlIGxhdGVzdCB2ZXJzaW9uIHRoYXQgd2FzIHB1Ymxpc2hlZCBzdWNjZXNzZnVsbHkgYW5kIHdvcmtzIHdpdGggdGhlIGN1cnJlbnQgY2RrdGYgcmVsZWFzZVxuICBwcml2YXRlIGFzeW5jIGdldExhbmd1YWdlU3BlY2lmaWNQYWNrYWdlVmVyc2lvbihcbiAgICBwYWNrYWdlTmFtZTogc3RyaW5nLFxuICAgIHByZWJ1aWx0UHJvdmlkZXJOcG1WZXJzaW9uczogc3RyaW5nW11cbiAgKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgXCJGb3VuZCBwb3NzaWJseSBtYXRjaGluZyB2ZXJzaW9ucyAocmVsZWFzZWQgb24gbnBtKTogXCIsXG4gICAgICBwcmVidWlsdFByb3ZpZGVyTnBtVmVyc2lvbnNcbiAgICApO1xuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIFwiU2VhcmNoaW5nIHRocm91Z2ggcGFja2FnZSBtYW5hZ2VyIHRvIGZpbmQgbGF0ZXN0IGF2YWlsYWJsZSB2ZXJzaW9uIGZvciBnaXZlbiBsYW5ndWFnZVwiXG4gICAgKTtcblxuICAgIGZvciAoY29uc3QgdmVyc2lvbiBvZiBwcmVidWlsdFByb3ZpZGVyTnBtVmVyc2lvbnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGlzQXZhaWxhYmxlID0gYXdhaXQgdGhpcy5wYWNrYWdlTWFuYWdlci5pc05wbVZlcnNpb25BdmFpbGFibGUoXG4gICAgICAgICAgcGFja2FnZU5hbWUsXG4gICAgICAgICAgdmVyc2lvblxuICAgICAgICApO1xuICAgICAgICBpZiAoaXNBdmFpbGFibGUpIHtcbiAgICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgIGBDb3VsZCBub3QgZmluZCB2ZXJzaW9uICR7dmVyc2lvbn0gZm9yIHBhY2thZ2UgJHtwYWNrYWdlTmFtZX06ICcke2Vycn0nLiBTa2lwcGluZy4uLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBhc3luYyBhZGRMb2NhbFByb3ZpZGVyKGNvbnN0cmFpbnQ6IFByb3ZpZGVyQ29uc3RyYWludCkge1xuICAgIGxvZ2dlci5pbmZvKFxuICAgICAgYEFkZGluZyBsb2NhbCBwcm92aWRlciAke2NvbnN0cmFpbnQuc291cmNlfSB3aXRoIHZlcnNpb24gY29uc3RyYWludCAke2NvbnN0cmFpbnQudmVyc2lvbn0gdG8gY2RrdGYuanNvbmBcbiAgICApO1xuXG4gICAgaWYgKCFjb25zdHJhaW50LnZlcnNpb24gJiYgY29uc3RyYWludC5pc0Zyb21UZXJyYWZvcm1SZWdpc3RyeSgpKSB7XG4gICAgICBjb25zdCB2ID0gYXdhaXQgZ2V0TGF0ZXN0VmVyc2lvbihjb25zdHJhaW50KTtcbiAgICAgIGlmICh2KSB7XG4gICAgICAgIGNvbnN0cmFpbnQgPSBuZXcgUHJvdmlkZXJDb25zdHJhaW50KFxuICAgICAgICAgIGNvbnN0cmFpbnQuc291cmNlLFxuICAgICAgICAgIC8vIFwiMS4zLjJcIiAtPiBcIn4+IDEuM1wiXG4gICAgICAgICAgYH4+ICR7di5zcGxpdChcIi5cIikuc2xpY2UoMCwgMikuam9pbihcIi5cIil9YFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3JzLlVzYWdlKFxuICAgICAgICAgIGBDb3VsZCBub3QgZmluZCBhIHZlcnNpb24gZm9yIHRoZSBwcm92aWRlciAnJHtjb25zdHJhaW50fScgaW4gdGhlIHB1YmxpYyByZWdpc3RyeS4gVGhpcyBjb3VsZCBiZSBkdWUgdG8gYSB0eXBvLCBwbGVhc2UgdGFrZSBhIGxvb2sgYXQgaHR0cHM6Ly9jZGsudGYvcmVnaXN0cnktcHJvdmlkZXJzIHRvIGZpbmQgYWxsIHN1cHBvcnRlZCBwcm92aWRlcnMuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IG5ldyBDZGt0ZkNvbmZpZ01hbmFnZXIoKS5hZGRQcm92aWRlcihjb25zdHJhaW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBOUE0gcGFja2FnZSBuYW1lIG9mIGEgcHJlLWJ1aWx0IHByb3ZpZGVyIHBhY2thZ2UgdG8gdGhlIG5hbWUgaW4gdGhlIHRhcmdldCBsYW5ndWFnZVxuICAgKi9cbiAgcHJpdmF0ZSBjb252ZXJ0UGFja2FnZU5hbWUobmFtZTogc3RyaW5nLCByZXBvc2l0b3J5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHByb3ZpZGVyTmFtZSA9IG5hbWUucmVwbGFjZShcIkBjZGt0Zi9wcm92aWRlci1cIiwgXCJcIik7XG4gICAgc3dpdGNoICh0aGlzLnRhcmdldExhbmd1YWdlKSB7XG4gICAgICBjYXNlIExhbmd1YWdlLkdPOiAvLyBlLmcuIGdpdGh1Yi5jb20vY2RrdGYvY2RrdGYtcHJvdmlkZXItb3BlbnRlbGVrb21jbG91ZC1nby9vcGVudGVsZWtvbWNsb3VkXG4gICAgICAgIGlmIChyZXBvc2l0b3J5KSB7XG4gICAgICAgICAgcmV0dXJuIGAke3JlcG9zaXRvcnl9LWdvLyR7cHJvdmlkZXJOYW1lfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYGdpdGh1Yi5jb20vY2RrdGYvY2RrdGYtcHJvdmlkZXItJHtwcm92aWRlck5hbWV9LWdvLyR7cHJvdmlkZXJOYW1lfWA7XG4gICAgICBjYXNlIExhbmd1YWdlLlRZUEVTQ1JJUFQ6IC8vIGUuZy4gQGNka3RmL3Byb3ZpZGVyLXJhbmRvbVxuICAgICAgICByZXR1cm4gbmFtZTsgLy8gYWxyZWFkeSB0aGUgY29ycmVjdCBuYW1lXG4gICAgICBjYXNlIExhbmd1YWdlLkNTSEFSUDogLy8gZS5nLiBIYXNoaUNvcnAuQ2RrdGYuUHJvdmlkZXJzLk9wZW50ZWxla29tY2xvdWRcbiAgICAgICAgcmV0dXJuIGBIYXNoaUNvcnAuQ2RrdGYuUHJvdmlkZXJzLmAgKyB0b1Bhc2NhbENhc2UocHJvdmlkZXJOYW1lKTtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuSkFWQTogLy8gZS5nLiBjb20uaGFzaGljb3JwLm9wZW50ZWxla29tY2xvdWRcbiAgICAgICAgcmV0dXJuIGBjb20uaGFzaGljb3JwLmNka3RmLXByb3ZpZGVyLSR7cHJvdmlkZXJOYW1lfWA7XG4gICAgICBjYXNlIExhbmd1YWdlLlBZVEhPTjogLy8gZS5nLiBjZGt0Zi1jZGt0Zi1wcm92aWRlci1vcGVudGVsZWtvbWNsb3VkXG4gICAgICAgIHJldHVybiBgY2RrdGYtY2RrdGYtcHJvdmlkZXItJHtwcm92aWRlck5hbWV9YDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgY29udmVydGluZyBwYWNrYWdlIG5hbWUgZm9yIGxhbmd1YWdlICR7dGhpcy50YXJnZXRMYW5ndWFnZX0gbm90IGltcGxlbWVudGVkIHlldGBcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gcGFja2FnZSBuYW1lIG9mIGEgcHJlLWJ1aWx0IHByb3ZpZGVyIHBhY2thZ2UgaW4gdGFyZ2V0IGxhbmd1YWdlIHRvIHRoZSBuYW1lIGluIG5wbVxuICAgKiBJbnZlcnNlIG9mOiBgY29udmVydFBhY2thZ2VOYW1lYFxuICAgKi9cbiAgcHJpdmF0ZSBjb252ZXJ0RnJvbVBhY2thZ2VOYW1lVG9OcG0obmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBucG1QYWNrYWdlUHJlZml4ID0gXCJAY2RrdGYvcHJvdmlkZXItXCI7XG4gICAgY29uc3QgcmVnZXhlcyA9IHtcbiAgICAgIFtMYW5ndWFnZS5HT106XG4gICAgICAgIC9naXRodWIuY29tXFwvKD86Y2RrdGZ8aGFzaGljb3JwKVxcL2Nka3RmLXByb3ZpZGVyLSguKyktZ29cXC8vaSxcbiAgICAgIFtMYW5ndWFnZS5UWVBFU0NSSVBUXTogLyguKykvaSxcbiAgICAgIFtMYW5ndWFnZS5DU0hBUlBdOiAvSGFzaGlDb3JwXFwuQ2RrdGZcXC5Qcm92aWRlcnNcXC4oLispL2ksXG4gICAgICBbTGFuZ3VhZ2UuSkFWQV06IC9jb21cXC5oYXNoaWNvcnBcXC5jZGt0Zi1wcm92aWRlci0oLispL2ksXG4gICAgICBbTGFuZ3VhZ2UuUFlUSE9OXTogL2Nka3RmLWNka3RmLXByb3ZpZGVyLSguKykvaSxcbiAgICB9O1xuICAgIGNvbnN0IHJlZ2V4ID0gcmVnZXhlc1t0aGlzLnRhcmdldExhbmd1YWdlXTtcbiAgICBpZiAoIXJlZ2V4KSB7XG4gICAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoXCJMYW5ndWFnZSBub3Qgc3VwcG9ydGVkIGZvciBwcmUtYnVpbHQgcHJvdmlkZXJzXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhuYW1lKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhY2thZ2UgbmFtZSBpcyBub3QgaW4gZXhwZWN0ZWQgZm9ybWF0OiAke25hbWV9YCk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLnRhcmdldExhbmd1YWdlKSB7XG4gICAgICBjYXNlIExhbmd1YWdlLkdPOiAvLyBlLmcuIGdpdGh1Yi5jb20vY2RrdGYvY2RrdGYtcHJvdmlkZXItb3BlbnRlbGVrb21jbG91ZC1nby9vcGVudGVsZWtvbWNsb3VkXG4gICAgICAgIHJldHVybiBucG1QYWNrYWdlUHJlZml4ICsgbWF0Y2hbMV07XG4gICAgICBjYXNlIExhbmd1YWdlLlRZUEVTQ1JJUFQ6IC8vIGUuZy4gQGNka3RmL3Byb3ZpZGVyLXJhbmRvbVxuICAgICAgICByZXR1cm4gbWF0Y2hbMV07IC8vIGFscmVhZHkgdGhlIGNvcnJlY3QgbmFtZVxuICAgICAgY2FzZSBMYW5ndWFnZS5DU0hBUlA6IC8vIGUuZy4gSGFzaGlDb3JwLkNka3RmLlByb3ZpZGVycy5PcGVudGVsZWtvbWNsb3VkXG4gICAgICAgIHJldHVybiBucG1QYWNrYWdlUHJlZml4ICsgdG9TbmFrZUNhc2UobWF0Y2hbMV0pO1xuICAgICAgY2FzZSBMYW5ndWFnZS5KQVZBOiAvLyBlLmcuIGNvbS5oYXNoaWNvcnAub3BlbnRlbGVrb21jbG91ZFxuICAgICAgICByZXR1cm4gbnBtUGFja2FnZVByZWZpeCArIG1hdGNoWzFdO1xuICAgICAgY2FzZSBMYW5ndWFnZS5QWVRIT046IC8vIGUuZy4gY2RrdGYtY2RrdGYtcHJvdmlkZXItb3BlbnRlbGVrb21jbG91ZFxuICAgICAgICByZXR1cm4gbnBtUGFja2FnZVByZWZpeCArIG1hdGNoWzFdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBjb252ZXJ0aW5nIHBhY2thZ2UgbmFtZSBmb3IgbGFuZ3VhZ2UgJHt0aGlzLnRhcmdldExhbmd1YWdlfSBub3QgaW1wbGVtZW50ZWQgeWV0YFxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBhbGxQcm92aWRlcnMoKSB7XG4gICAgY29uc3QgY2RrdGZKc29uID0gQ2RrdGZDb25maWcucmVhZCgpO1xuICAgIGNvbnN0IGxvY2FsVmVyc2lvbnMgPSBuZXcgTG9jYWxQcm92aWRlclZlcnNpb25zKCk7XG5cbiAgICBjb25zdCBsb2NhbFByb3ZpZGVyQ29uZmlncyA9IGNka3RmSnNvbi50ZXJyYWZvcm1Qcm92aWRlcnM7XG4gICAgY29uc3QgcHJlYnVpbHRQcm92aWRlckNvbmZpZ3MgPVxuICAgICAgYXdhaXQgdGhpcy5wYWNrYWdlTWFuYWdlci5saXN0UHJvdmlkZXJQYWNrYWdlcygpO1xuXG4gICAgY29uc3QgcHJlYnVpbHRQcm92aWRlcnNJbmZvID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBwcmVidWlsdFByb3ZpZGVyQ29uZmlncy5tYXAoYXN5bmMgKHByZWJ1aWx0UHJvdmlkZXJDb25maWcpID0+IHtcbiAgICAgICAgY29uc3QgcGFja2FnZU5hbWUgPSB0aGlzLmNvbnZlcnRGcm9tUGFja2FnZU5hbWVUb05wbShcbiAgICAgICAgICBwcmVidWlsdFByb3ZpZGVyQ29uZmlnLm5hbWVcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBwcm92aWRlckluZm9ybWF0aW9uID0gYXdhaXQgZ2V0UHJlYnVpbHRQcm92aWRlclZlcnNpb25JbmZvcm1hdGlvbihcbiAgICAgICAgICBwYWNrYWdlTmFtZSxcbiAgICAgICAgICBwcmVidWlsdFByb3ZpZGVyQ29uZmlnLnZlcnNpb25cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnByb3ZpZGVySW5mb3JtYXRpb24sXG4gICAgICAgICAgcGFja2FnZU5hbWU6IHByZWJ1aWx0UHJvdmlkZXJDb25maWcubmFtZSxcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gbmV3IExvY2FsUHJvdmlkZXJDb25zdHJhaW50cygpO1xuXG4gICAgY29uc3QgbG9jYWxQcm92aWRlcnNJbmZvID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBsb2NhbFByb3ZpZGVyQ29uZmlncy5tYXAoYXN5bmMgKGxvY2FsUHJvdmlkZXJDb25maWcpID0+IHtcbiAgICAgICAgY29uc3QgY29uc3RyYWludCA9XG4gICAgICAgICAgUHJvdmlkZXJDb25zdHJhaW50LmZyb21Db25maWdFbnRyeShsb2NhbFByb3ZpZGVyQ29uZmlnKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IGxvY2FsVmVyc2lvbnMudmVyc2lvbkZvclByb3ZpZGVyKFxuICAgICAgICAgIGNvbnN0cmFpbnQuc2ltcGxpZmllZE5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY29uc3RyYWludFZhbHVlID0gYXdhaXQgY29uc3RyYWludHMuY29uc3RyYWludEZvclByb3ZpZGVyKFxuICAgICAgICAgIGNvbnN0cmFpbnQuc2ltcGxpZmllZE5hbWVcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByb3ZpZGVyTmFtZTogY29uc3RyYWludC5zaW1wbGlmaWVkTmFtZSxcbiAgICAgICAgICBwcm92aWRlckNvbnN0cmFpbnQ6IGNvbnN0cmFpbnRWYWx1ZSB8fCBjb25zdHJhaW50LnZlcnNpb24sXG4gICAgICAgICAgcHJvdmlkZXJWZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2FsOiBsb2NhbFByb3ZpZGVyc0luZm8sXG4gICAgICBwcmVidWlsdDogcHJlYnVpbHRQcm92aWRlcnNJbmZvLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==