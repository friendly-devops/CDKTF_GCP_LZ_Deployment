"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CdktfProject = exports.isWaitingForUserInputUpdate = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const commons_1 = require("@cdktf/commons");
const synth_stack_1 = require("./synth-stack");
const synth_1 = require("./synth");
const cdktf_stack_1 = require("./cdktf-stack");
const execution_logs_1 = require("./execution-logs");
const stack_helpers_1 = require("./helpers/stack-helpers");
const cdktf_project_io_handler_1 = require("./cdktf-project-io-handler");
function isWaitingForUserInputUpdate(update) {
    return ["waiting for approval", "waiting for sentinel override"].includes(update.type);
}
exports.isWaitingForUserInputUpdate = isWaitingForUserInputUpdate;
class CdktfProject {
    constructor({ synthCommand, outDir, onUpdate, onLog, workingDirectory = process.cwd(), synthOrigin, hcl = false, }) {
        // Set during deploy / destroy
        this.stacksToRun = [];
        // This means sth different in deploy / destroy
        this.stopAllStacksThatCanNotRunWithout = () => { }; // eslint-disable-line @typescript-eslint/no-empty-function
        this.synthCommand = synthCommand;
        this.outDir = outDir;
        this.workingDirectory = workingDirectory;
        this.onUpdate = onUpdate;
        this.onLog = onLog;
        const ac = new AbortController();
        this.abortSignal = ac.signal;
        this.synthOrigin = synthOrigin;
        this.hcl =
            process.env.SYNTH_HCL_OUTPUT === "true" ||
                process.env.SYNTH_HCL_OUTPUT === "1" ||
                hcl;
        this.hardAbort = ac.abort.bind(ac);
        this.ioHandler = new cdktf_project_io_handler_1.CdktfProjectIOHandler();
    }
    stopAllStacks() {
        this.stacksToRun.forEach((stack) => stack.stop());
        this.ioHandler.filterUserInputEventsFromBuffer();
    }
    handleUserUpdate(update, operations, originalCallback, eventType) {
        const callbacks = (update) => Object.fromEntries(Object.entries(operations).map(([key, value]) => {
            return [
                key,
                // This is passed in to make typescript happy only
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                (_) => {
                    value(update);
                    // We need to defer these calls for the case that approve() is instantly invoked
                    // in the listener that receives these callbacks as it otherwise would already
                    // remove the "waiting for stack approval" event from the buffer before we even
                    // set waitingForApproval to true (at the end of this if statement) which results
                    // in buffered updates which will never unblock
                    setTimeout(() => this.ioHandler.resumeAfterUserInput(update.stackName), 0);
                },
            ];
        }));
        // always send to buffer, as resumeAfterUserInput() always expects a matching event
        this.ioHandler.pushEvent({
            cb: originalCallback,
            value: {
                type: eventType,
                stackName: update.stackName,
                ...callbacks(update),
            },
            type: "projectUpdate",
        });
        // if we aren't already waiting, this needs to go to cb() too to arrive at the UI
        if (!this.ioHandler.isWaitingForUserInput()) {
            originalCallback({
                type: eventType,
                stackName: update.stackName,
                ...callbacks(update),
            });
        }
    }
    handleUserInputProcess(cb) {
        return (update) => {
            if (update.type === "external stack approval reply") {
                if (!update.approved) {
                    this.stopAllStacksThatCanNotRunWithout(update.stackName);
                }
                this.ioHandler.resumeAfterUserInput(update.stackName);
                return; // aka don't send this event to any buffer
            }
            if (update.type === "external stack sentinel override reply") {
                if (!update.overridden) {
                    this.stopAllStacksThatCanNotRunWithout(update.stackName);
                }
                this.ioHandler.resumeAfterUserInput(update.stackName);
                return; // aka don't send this event to any buffer
            }
            if (update.type === "waiting for stack approval" ||
                update.type === "waiting for stack sentinel override") {
                if (update.type === "waiting for stack approval") {
                    this.handleUserUpdate(update, {
                        approve: (update) => update.approve(),
                        dismiss: (update) => {
                            update.reject();
                            this.stopAllStacksThatCanNotRunWithout(update.stackName);
                        },
                        stop: (update) => {
                            update.reject();
                            this.stopAllStacks();
                        },
                    }, cb, "waiting for approval");
                }
                else if (update.type === "waiting for stack sentinel override") {
                    this.handleUserUpdate(update, {
                        override: (update) => {
                            update.override();
                        },
                        reject: (update) => {
                            update.reject();
                            this.stopAllStacksThatCanNotRunWithout(update.stackName);
                        },
                    }, cb, "waiting for sentinel override");
                }
                this.ioHandler.awaitUserInput();
            }
            else {
                if (this.ioHandler.isWaitingForUserInput()) {
                    this.ioHandler.pushEvent({
                        cb,
                        value: update,
                        type: "projectUpdate",
                    });
                }
                else {
                    cb(update);
                }
            }
        };
    }
    getStackExecutor(stack, opts = {}) {
        const enhanceLogMessage = (0, execution_logs_1.createEnhanceLogMessage)(stack);
        const onLog = this.ioHandler.bufferWhileAwaitingUserInput(this.onLog);
        return new cdktf_stack_1.CdktfStack({
            ...opts,
            stack,
            onUpdate: this.handleUserInputProcess(this.onUpdate),
            onLog: onLog
                ? ({ message }) => onLog({
                    stackName: stack.name,
                    message,
                    messageWithConstructPath: enhanceLogMessage(message),
                })
                : undefined,
            abortSignal: this.abortSignal,
        });
    }
    get outputsByConstructId() {
        return this.stacksToRun.reduce((acc, stack) => ({
            ...acc,
            ...stack.outputsByConstructId,
        }), {});
    }
    async synth(noColor) {
        this.onUpdate({
            type: "synthesizing",
        });
        const stacks = await synth_stack_1.SynthStack.synth(this.abortSignal, this.synthCommand, this.outDir, this.workingDirectory, false, noColor, this.synthOrigin, this.hcl);
        (0, synth_1.printAnnotations)(stacks);
        this.onUpdate({
            type: "synthesized",
            stacks,
        });
        return stacks;
    }
    async readSynthesizedStacks() {
        const stacks = await synth_stack_1.SynthStack.readSynthesizedStacks(this.outDir);
        (0, synth_1.printAnnotations)(stacks);
        this.onUpdate({
            type: "synthesized",
            stacks,
        });
        return stacks;
    }
    async diff(opts = {}) {
        const stacks = opts.skipSynth
            ? await this.readSynthesizedStacks()
            : await this.synth(opts.noColor);
        const stack = this.getStackExecutor((0, stack_helpers_1.getSingleStack)(stacks, opts === null || opts === void 0 ? void 0 : opts.stackName, "diff"));
        await stack.initalizeTerraform(opts.noColor);
        try {
            await stack.diff(opts);
        }
        catch (e) {
            throw commons_1.Errors.External(`Stack failed to plan: ${stack.stack.name}. Please check the logs for more information.`, e);
        }
        if (stack.error) {
            throw commons_1.Errors.External(`Stack failed to plan: ${stack.stack.name}. Please check the logs for more information.`, new Error(stack.error));
        }
        try {
            await this.projectTelemetry("diff", {
                stackMetadata: stacks.map((stack) => JSON.parse(stack.content)["//"]
                    ? JSON.parse(stack.content)["//"].metadata
                    : {}),
                errors: stack.error,
                requiredProviders: stacks.map((stack) => JSON.parse(stack.content)["terraform"]
                    ? JSON.parse(stack.content)["terraform"].required_providers
                    : {}),
            });
        }
        catch (e) {
            commons_1.logger.debug("Failed to send telemetry", e);
        }
    }
    async execute(method, next, opts) {
        // We only support refresh only on deploy, a bit of a leaky abstraction here
        if (opts.refreshOnly && method !== "deploy") {
            throw commons_1.Errors.Internal(`Refresh only is only supported on deploy`);
        }
        const maxParallelRuns = !opts.parallelism || opts.parallelism < 0 ? Infinity : opts.parallelism;
        const allExecutions = [];
        await this.initializeStacksToRunInSerial(opts.noColor);
        while (this.stacksToRun.filter((stack) => stack.isPending).length > 0) {
            const runningStacks = this.stacksToRun.filter((stack) => stack.isRunning);
            if (runningStacks.length >= maxParallelRuns) {
                await Promise.race(runningStacks.map((s) => s.currentWorkPromise));
                continue;
            }
            try {
                const nextRunningExecutor = await next();
                if (!nextRunningExecutor) {
                    // In this case we have no pending stacks, but we also can not find a new executor
                    break;
                }
                const promise = method === "deploy"
                    ? nextRunningExecutor.deploy(opts)
                    : nextRunningExecutor.destroy(opts);
                allExecutions.push(promise);
            }
            catch (e) {
                // await next() threw an error because a stack failed to apply/destroy
                // wait for all other currently running stacks to complete before propagating that error
                commons_1.logger.debug("Encountered an error while awaiting stack to finish", e);
                const openStacks = this.stacksToRun.filter((ex) => ex.currentWorkPromise);
                commons_1.logger.debug("Waiting for still running stacks to finish:", openStacks);
                await Promise.allSettled(openStacks.map((ex) => ex.currentWorkPromise));
                commons_1.logger.debug("Done waiting for still running stacks. All pending work finished");
                throw e;
            }
        }
        // We end the loop when all stacks are started, now we need to wait for them to be done
        // We wait for all work to finish even if one of the promises threw an error.
        await (0, commons_1.ensureAllSettledBeforeThrowing)(Promise.all(allExecutions), allExecutions);
    }
    async deploy(opts = {}) {
        const stacks = opts.skipSynth
            ? await this.readSynthesizedStacks()
            : await this.synth(opts.noColor);
        const stacksToRun = (0, stack_helpers_1.getMultipleStacks)(stacks, opts.stackNames, "deploy");
        if (!opts.ignoreMissingStackDependencies) {
            (0, stack_helpers_1.checkIfAllDependenciesAreIncluded)(stacksToRun);
        }
        this.stopAllStacksThatCanNotRunWithout = (stackName) => {
            (0, stack_helpers_1.findAllNestedDependantStacks)(this.stacksToRun, stackName).forEach((stack) => stack.stop());
        };
        this.stacksToRun = stacksToRun.map((stack) => this.getStackExecutor(stack, opts));
        const next = opts.ignoreMissingStackDependencies
            ? () => Promise.resolve(this.stacksToRun.filter((stack) => stack.isPending)[0])
            : () => (0, stack_helpers_1.getStackWithNoUnmetDependencies)(this.stacksToRun);
        await this.execute("deploy", next, opts);
        const unprocessedStacks = this.stacksToRun.filter((executor) => executor.isPending);
        if (unprocessedStacks.length > 0) {
            throw commons_1.Errors.External(`Some stacks failed to deploy: ${unprocessedStacks
                .map((s) => s.stack.name)
                .join(", ")}. Please check the logs for more information.`);
        }
        try {
            await this.projectTelemetry("deploy", {
                stackMetadata: stacksToRun.map((stack) => JSON.parse(stack.content)["//"]
                    ? JSON.parse(stack.content)["//"].metadata
                    : {}),
                failedStacks: unprocessedStacks.map((stack) => stack.error),
                requiredProviders: stacksToRun.map((stack) => JSON.parse(stack.content)["terraform"]
                    ? JSON.parse(stack.content)["terraform"].required_providers
                    : {}),
            });
        }
        catch (e) {
            commons_1.logger.debug("Failed to send telemetry", e);
        }
    }
    async destroy(opts = {}) {
        const stacks = opts.skipSynth
            ? await this.readSynthesizedStacks()
            : await this.synth(opts.noColor);
        const stacksToRun = (0, stack_helpers_1.getMultipleStacks)(stacks, opts.stackNames, "destroy");
        if (!opts.ignoreMissingStackDependencies) {
            (0, stack_helpers_1.checkIfAllDependantsAreIncluded)(stacksToRun, stacks);
        }
        this.stopAllStacksThatCanNotRunWithout = (stackName) => {
            const stackExecutor = this.stacksToRun.find((s) => s.stack.name === stackName);
            if (!stackExecutor) {
                throw commons_1.Errors.Internal(`Could not find stack "${stackName}" that was stopped`);
            }
            stackExecutor.stack.dependencies.forEach((dependant) => {
                this.stopAllStacksThatCanNotRunWithout(dependant);
                const dependantStack = this.stacksToRun.find((s) => s.stack.name === dependant);
                if (!dependantStack) {
                    throw commons_1.Errors.Internal(`Could not find stack "${dependant}" that was stopped`);
                }
                dependantStack.stop();
            });
        };
        this.stacksToRun = stacksToRun.map((stack) => this.getStackExecutor(stack, opts));
        const next = opts.ignoreMissingStackDependencies
            ? () => Promise.resolve(this.stacksToRun.filter((stack) => stack.currentState !== "done")[0])
            : () => (0, stack_helpers_1.getStackWithNoUnmetDependants)(this.stacksToRun);
        await this.execute("destroy", next, opts);
        const unprocessedStacks = this.stacksToRun.filter((executor) => executor.isPending);
        if (unprocessedStacks.length > 0) {
            throw commons_1.Errors.External(`Some stacks failed to destroy: ${unprocessedStacks
                .map((s) => s.stack.name)
                .join(", ")}. Please check the logs for more information.`);
        }
        try {
            await this.projectTelemetry("destroy", {
                stackMetadata: stacksToRun.map((stack) => JSON.parse(stack.content)["//"]
                    ? JSON.parse(stack.content)["//"].metadata
                    : {}),
                failedStacks: unprocessedStacks.map((stack) => stack.error),
                requiredProviders: stacksToRun.map((stack) => JSON.parse(stack.content)["terraform"]
                    ? JSON.parse(stack.content)["terraform"].required_providers
                    : {}),
            });
        }
        catch (e) {
            commons_1.logger.debug("Failed to send telemetry", e);
        }
    }
    async projectTelemetry(command, payload) {
        const config = (0, commons_1.readConfigSync)();
        await (0, commons_1.sendTelemetry)(command, {
            ...payload,
            language: config.language,
        });
    }
    async fetchOutputs(opts) {
        const stacks = opts.skipSynth
            ? await this.readSynthesizedStacks()
            : await this.synth();
        const stacksToRun = (0, stack_helpers_1.getMultipleStacks)(stacks, opts.stackNames || [], "deploy");
        if (stacksToRun.length === 0) {
            throw new Error("No stacks to fetch outputs for specified");
        }
        this.stacksToRun = stacksToRun.map((stack) => 
        // Options are empty, because MultipleStackOptions doesn't have any relevant
        // options for `getStackExecutor`, hence defaults are fine
        this.getStackExecutor(stack, {}));
        await this.initializeStacksToRunInSerial();
        const outputs = await Promise.all(this.stacksToRun.map(async (s) => {
            const output = await s.fetchOutputs();
            return {
                [s.stack.name]: output,
            };
        }));
        return outputs.reduce((acc, curr) => ({ ...acc, ...curr }), {});
    }
    // Serially run terraform init to prohibit text file busy errors for the cache files
    async initializeStacksToRunInSerial(noColor) {
        for (const stack of this.stacksToRun) {
            await stack.initalizeTerraform(noColor);
        }
    }
}
exports.CdktfProject = CdktfProject;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrdGYtcHJvamVjdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNka3RmLXByb2plY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyw0Q0FNd0I7QUFDeEIsK0NBQTBFO0FBQzFFLG1DQUEyQztBQUMzQywrQ0FRdUI7QUFFdkIscURBQTJEO0FBQzNELDJEQVFpQztBQUNqQyx5RUFBbUU7QUF3Rm5FLFNBQWdCLDJCQUEyQixDQUN6QyxNQUFtQztJQUVuQyxPQUFPLENBQUMsc0JBQXNCLEVBQUUsK0JBQStCLENBQUMsQ0FBQyxRQUFRLENBQ3ZFLE1BQU0sQ0FBQyxJQUFJLENBQ1osQ0FBQztBQUNKLENBQUM7QUFORCxrRUFNQztBQWNELE1BQWEsWUFBWTtJQXFCdkIsWUFBWSxFQUNWLFlBQVksRUFDWixNQUFNLEVBQ04sUUFBUSxFQUNSLEtBQUssRUFDTCxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQ2hDLFdBQVcsRUFDWCxHQUFHLEdBQUcsS0FBSyxHQUNTO1FBaEJ0Qiw4QkFBOEI7UUFDdkIsZ0JBQVcsR0FBaUIsRUFBRSxDQUFDO1FBQ3RDLCtDQUErQztRQUN2QyxzQ0FBaUMsR0FDdkMsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFDLENBQUMsMkRBQTJEO1FBYXJFLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztRQUN6QyxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixNQUFNLEVBQUUsR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQztRQUM3QixJQUFJLENBQUMs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QUVGLE1BQU0sSUFBSSxDQUFDLDZCQUE2QixFQUFFLENBQUM7UUFDM0MsTUFBTSxPQUFPLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUMvQixJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDL0IsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDdEMsT0FBTztnQkFDTCxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTTthQUN2QixDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQ0gsQ0FBQztRQUVGLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FDbkIsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFJLEVBQUUsQ0FBQyxFQUNwQyxFQUFFLENBQ3VCLENBQUM7SUFDOUIsQ0FBQztJQUVELG9GQUFvRjtJQUM1RSxLQUFLLENBQUMsNkJBQTZCLENBQ3pDLE9BQWlCO1FBRWpCLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNwQyxNQUFNLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN6QztJQUNILENBQUM7Q0FDRjtBQTloQkQsb0NBOGhCQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgSGFzaGlDb3JwLCBJbmNcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNUEwtMi4wXG5pbXBvcnQge1xuICBFcnJvcnMsXG4gIGVuc3VyZUFsbFNldHRsZWRCZWZvcmVUaHJvd2luZyxcbiAgbG9nZ2VyLFxuICByZWFkQ29uZmlnU3luYyxcbiAgc2VuZFRlbGVtZXRyeSxcbn0gZnJvbSBcIkBjZGt0Zi9jb21tb25zXCI7XG5pbXBvcnQgeyBTeW50aGVzaXplZFN0YWNrLCBTeW50aE9yaWdpbiwgU3ludGhTdGFjayB9IGZyb20gXCIuL3N5bnRoLXN0YWNrXCI7XG5pbXBvcnQgeyBwcmludEFubm90YXRpb25zIH0gZnJvbSBcIi4vc3ludGhcIjtcbmltcG9ydCB7XG4gIENka3RmU3RhY2ssXG4gIEV4dGVybmFsU3RhY2tBcHByb3ZhbFVwZGF0ZSxcbiAgRXh0ZXJuYWxTdGFja1NlbnRpbmVsT3ZlcnJpZGVVcGRhdGUsXG4gIFN0YWNrQXBwcm92YWxVcGRhdGUsXG4gIFN0YWNrU2VudGluZWxPdmVycmlkZVVwZGF0ZSxcbiAgU3RhY2tVcGRhdGUsXG4gIFN0YWNrVXNlcklucHV0VXBkYXRlLFxufSBmcm9tIFwiLi9jZGt0Zi1zdGFja1wiO1xuaW1wb3J0IHsgTmVzdGVkVGVycmFmb3JtT3V0cHV0cyB9IGZyb20gXCIuL291dHB1dFwiO1xuaW1wb3J0IHsgY3JlYXRlRW5oYW5jZUxvZ01lc3NhZ2UgfSBmcm9tIFwiLi9leGVjdXRpb24tbG9nc1wiO1xuaW1wb3J0IHtcbiAgY2hlY2tJZkFsbERlcGVuZGFudHNBcmVJbmNsdWRlZCxcbiAgY2hlY2tJZkFsbERlcGVuZGVuY2llc0FyZUluY2x1ZGVkLFxuICBmaW5kQWxsTmVzdGVkRGVwZW5kYW50U3RhY2tzLFxuICBnZXRNdWx0aXBsZVN0YWNrcyxcbiAgZ2V0U2luZ2xlU3RhY2ssXG4gIGdldFN0YWNrV2l0aE5vVW5tZXREZXBlbmRhbnRzLFxuICBnZXRTdGFja1dpdGhOb1VubWV0RGVwZW5kZW5jaWVzLFxufSBmcm9tIFwiLi9oZWxwZXJzL3N0YWNrLWhlbHBlcnNcIjtcbmltcG9ydCB7IENka3RmUHJvamVjdElPSGFuZGxlciB9IGZyb20gXCIuL2Nka3RmLXByb2plY3QtaW8taGFuZGxlclwiO1xuXG50eXBlIE11bHRpU3RhY2tBcHByb3ZhbFVwZGF0ZSA9IHtcbiAgdHlwZTogXCJ3YWl0aW5nIGZvciBhcHByb3ZhbFwiO1xuICBzdGFja05hbWU6IHN0cmluZztcbiAgYXBwcm92ZTogKCkgPT4gdm9pZDtcbiAgZGlzbWlzczogKCkgPT4gdm9pZDtcbiAgc3RvcDogKCkgPT4gdm9pZDtcbn07XG5cbnR5cGUgTXVsdGlTdGFja1NlbnRpbmVsT3ZlcnJpZGVVcGRhdGUgPSB7XG4gIHR5cGU6IFwid2FpdGluZyBmb3Igc2VudGluZWwgb3ZlcnJpZGVcIjtcbiAgc3RhY2tOYW1lOiBzdHJpbmc7XG4gIG92ZXJyaWRlOiAoKSA9PiB2b2lkO1xuICByZWplY3Q6ICgpID0+IHZvaWQ7XG59O1xuXG5leHBvcnQgdHlwZSBNdWx0aVN0YWNrVXBkYXRlID1cbiAgfCBNdWx0aVN0YWNrQXBwcm92YWxVcGRhdGVcbiAgfCBNdWx0aVN0YWNrU2VudGluZWxPdmVycmlkZVVwZGF0ZTtcblxuZXhwb3J0IHR5cGUgUHJvamVjdFVwZGF0ZSA9XG4gIHwge1xuICAgICAgdHlwZTogXCJzeW50aGVzaXppbmdcIjtcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogXCJzeW50aGVzaXplZFwiO1xuICAgICAgc3RhY2tzOiBTeW50aGVzaXplZFN0YWNrW107XG4gICAgICBlcnJvck1lc3NhZ2U/OiBzdHJpbmc7XG4gICAgfVxuICB8IFN0YWNrVXBkYXRlXG4gIHwgTXVsdGlTdGFja1VwZGF0ZTtcblxuZXhwb3J0IHR5cGUgU2luZ2xlU3RhY2tPcHRpb25zID0ge1xuICBzdGFja05hbWU/OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBNdWx0aXBsZVN0YWNrT3B0aW9ucyA9IHtcbiAgc3RhY2tOYW1lcz86IHN0cmluZ1tdO1xufTtcblxuZXhwb3J0IHR5cGUgU2tpcFN5bnRoT3B0aW9ucyA9IHtcbiAgc2tpcFN5bnRoPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIEZldGNoT3V0cHV0T3B0aW9ucyA9IFNraXBTeW50aE9wdGlvbnMgJiBNdWx0aXBsZVN0YWNrT3B0aW9ucztcblxuZXhwb3J0IHR5cGUgQXV0b0FwcHJvdmVPcHRpb25zID0ge1xuICBhdXRvQXBwcm92ZT86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBEaWZmT3B0aW9ucyA9IFNpbmdsZVN0YWNrT3B0aW9ucyAmXG4gIFNraXBTeW50aE9wdGlvbnMgJiB7XG4gICAgcmVmcmVzaE9ubHk/OiBib29sZWFuO1xuICAgIHRlcnJhZm9ybVBhcmFsbGVsaXNtPzogbnVtYmVyO1xuICAgIHZhcnM/OiBzdHJpbmdbXTtcbiAgICB2YXJGaWxlcz86IHN0cmluZ1tdO1xuICAgIG5vQ29sb3I/OiBib29sZWFuO1xuICAgIG1pZ3JhdGVTdGF0ZT86IGJvb2xlYW47XG4gICAgc2tpcFN5bnRoPzogYm9vbGVhbjtcbiAgfTtcblxuZXhwb3J0IHR5cGUgTXV0YXRpb25PcHRpb25zID0gTXVsdGlwbGVTdGFja09wdGlvbnMgJlxuICBTa2lwU3ludGhPcHRpb25zICZcbiAgQXV0b0FwcHJvdmVPcHRpb25zICYge1xuICAgIHJlZnJlc2hPbmx5PzogYm9vbGVhbjtcbiAgICBpZ25vcmVNaXNzaW5nU3RhY2tEZXBlbmRlbmNpZXM/OiBib29sZWFuO1xuICAgIHBhcmFsbGVsaXNtPzogbnVtYmVyO1xuICAgIHRlcnJhZm9ybVBhcmFsbGVsaXNtPzogbnVtYmVyO1xuICAgIHZhcnM/OiBzdHJpbmdbXTtcbiAgICB2YXJGaWxlcz86IHN0cmluZ1tdO1xuICAgIG5vQ29sb3I/OiBib29sZWFuO1xuICAgIG1pZ3JhdGVTdGF0ZT86IGJvb2xlYW47XG4gIH07XG5cbmV4cG9ydCB0eXBlIExvZ01lc3NhZ2UgPSB7XG4gIHN0YWNrTmFtZTogc3RyaW5nO1xuICBtZXNzYWdlV2l0aENvbnN0cnVjdFBhdGg/OiBzdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbn07XG5cbi8vIFN0b3JlcyBhIGxvZyB2YWx1ZSBvZiBhIGNlcnRhaW4gdHlwZSB1bnRpbCBpdCBjYW4gYmUgc2VudFxudHlwZSBCdWZmZXJlZDxULCBWPiA9IHtcbiAgY2I6IChpdGVtOiBUKSA9PiB2b2lkO1xuICB2YWx1ZTogVDtcbiAgdHlwZTogVjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1dhaXRpbmdGb3JVc2VySW5wdXRVcGRhdGUoXG4gIHVwZGF0ZTogUHJvamVjdFVwZGF0ZSB8IFN0YWNrVXBkYXRlXG4pIHtcbiAgcmV0dXJuIFtcIndhaXRpbmcgZm9yIGFwcHJvdmFsXCIsIFwid2FpdGluZyBmb3Igc2VudGluZWwgb3ZlcnJpZGVcIl0uaW5jbHVkZXMoXG4gICAgdXBkYXRlLnR5cGVcbiAgKTtcbn1cblxuZXhwb3J0IHR5cGUgUHJvamVjdEV2ZW50ID1cbiAgfCBCdWZmZXJlZDxQcm9qZWN0VXBkYXRlLCBcInByb2plY3RVcGRhdGVcIj5cbiAgfCBCdWZmZXJlZDxMb2dNZXNzYWdlLCBcImxvZ01lc3NhZ2VcIj47XG5leHBvcnQgdHlwZSBDZGt0ZlByb2plY3RPcHRpb25zID0ge1xuICBzeW50aENvbW1hbmQ6IHN0cmluZztcbiAgb3V0RGlyOiBzdHJpbmc7XG4gIG9uVXBkYXRlOiAodXBkYXRlOiBQcm9qZWN0VXBkYXRlKSA9PiB2b2lkO1xuICBvbkxvZz86IChsb2c6IExvZ01lc3NhZ2UpID0+IHZvaWQ7XG4gIHdvcmtpbmdEaXJlY3Rvcnk/OiBzdHJpbmc7XG4gIHN5bnRoT3JpZ2luPzogU3ludGhPcmlnaW47XG4gIGhjbD86IGJvb2xlYW47XG59O1xuZXhwb3J0IGNsYXNzIENka3RmUHJvamVjdCB7XG4gIHB1YmxpYyBzdGFja3M/OiBTeW50aGVzaXplZFN0YWNrW107XG4gIHB1YmxpYyBoYXJkQWJvcnQ6ICgpID0+IHZvaWQ7XG5cbiAgcHJpdmF0ZSBzeW50aENvbW1hbmQ6IHN0cmluZztcbiAgcHJpdmF0ZSBvdXREaXI6IHN0cmluZztcbiAgcHJpdmF0ZSB3b3JraW5nRGlyZWN0b3J5OiBzdHJpbmc7XG4gIHByaXZhdGUgb25VcGRhdGU6ICh1cGRhdGU6IFByb2plY3RVcGRhdGUpID0+IHZvaWQ7XG4gIHByaXZhdGUgb25Mb2c/OiAobG9nOiBMb2dNZXNzYWdlKSA9PiB2b2lkO1xuICBwcml2YXRlIGFib3J0U2lnbmFsOiBBYm9ydFNpZ25hbDtcbiAgcHJpdmF0ZSBzeW50aE9yaWdpbj86IFN5bnRoT3JpZ2luO1xuICBwcml2YXRlIGhjbD86IGJvb2xlYW47XG5cbiAgLy8gU2V0IGR1cmluZyBkZXBsb3kgLyBkZXN0cm95XG4gIHB1YmxpYyBzdGFja3NUb1J1bjogQ2RrdGZTdGFja1tdID0gW107XG4gIC8vIFRoaXMgbWVhbnMgc3RoIGRpZmZlcmVudCBpbiBkZXBsb3kgLyBkZXN0cm95XG4gIHByaXZhdGUgc3RvcEFsbFN0YWNrc1RoYXRDYW5Ob3RSdW5XaXRob3V0OiAoc3RhY2tOYW1lOiBzdHJpbmcpID0+IHZvaWQgPVxuICAgICgpID0+IHt9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuXG4gIHByaXZhdGUgaW9IYW5kbGVyOiBDZGt0ZlByb2plY3RJT0hhbmRsZXI7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHN5bnRoQ29tbWFuZCxcbiAgICBvdXREaXIsXG4gICAgb25VcGRhdGUsXG4gICAgb25Mb2csXG4gICAgd29ya2luZ0RpcmVjdG9yeSA9IHByb2Nlc3MuY3dkKCksXG4gICAgc3ludGhPcmlnaW4sXG4gICAgaGNsID0gZmFsc2UsXG4gIH06IENka3RmUHJvamVjdE9wdGlvbnMpIHtcbiAgICB0aGlzLnN5bnRoQ29tbWFuZCA9IHN5bnRoQ29tbWFuZDtcbiAgICB0aGlzLm91dERpciA9IG91dERpcjtcbiAgICB0aGlzLndvcmtpbmdEaXJlY3RvcnkgPSB3b3JraW5nRGlyZWN0b3J5O1xuICAgIHRoaXMub25VcGRhdGUgPSBvblVwZGF0ZTtcbiAgICB0aGlzLm9uTG9nID0gb25Mb2c7XG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5hYm9ydFNpZ25hbCA9IGFjLnNpZ25hbDtcbiAgICB0aGlzLnN5bnRoT3JpZ2luID0gc3ludGhPcmlnaW47XG4gICAgdGhpcy5oY2wgPVxuICAgICAgcHJvY2Vzcy5lbnYuU1lOVEhfSENMX09VVFBVVCA9PT0gXCJ0cnVlXCIgfHxcbiAgICAgIHByb2Nlc3MuZW52LlNZTlRIX0hDTF9PVVRQVVQgPT09IFwiMVwiIHx8XG4gICAgICBoY2w7XG5cbiAgICB0aGlzLmhhcmRBYm9ydCA9IGFjLmFib3J0LmJpbmQoYWMpO1xuICAgIHRoaXMuaW9IYW5kbGVyID0gbmV3IENka3RmUHJvamVjdElPSGFuZGxlcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdG9wQWxsU3RhY2tzKCkge1xuICAgIHRoaXMuc3RhY2tzVG9SdW4uZm9yRWFjaCgoc3RhY2spID0+IHN0YWNrLnN0b3AoKSk7XG4gICAgdGhpcy5pb0hhbmRsZXIuZmlsdGVyVXNlcklucHV0RXZlbnRzRnJvbUJ1ZmZlcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVVc2VyVXBkYXRlPFxuICAgIFQgZXh0ZW5kcyBNdWx0aVN0YWNrVXBkYXRlLFxuICAgIFYgZXh0ZW5kcyBTdGFja1VzZXJJbnB1dFVwZGF0ZVxuICA+KFxuICAgIHVwZGF0ZTogU3RhY2tVc2VySW5wdXRVcGRhdGUsXG4gICAgb3BlcmF0aW9uczogUmVjb3JkPHN0cmluZywgKHVwZGF0ZTogVikgPT4gdm9pZD4sXG4gICAgb3JpZ2luYWxDYWxsYmFjazogKHVwZGF0ZVRvU2VuZDogUHJvamVjdFVwZGF0ZSkgPT4gdm9pZCxcbiAgICBldmVudFR5cGU6IFRbXCJ0eXBlXCJdXG4gICkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh1cGRhdGU6IFYpID0+XG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG9wZXJhdGlvbnMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcGFzc2VkIGluIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweSBvbmx5XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAoXzogVikgPT4ge1xuICAgICAgICAgICAgICB2YWx1ZSh1cGRhdGUpO1xuXG4gICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdGhlc2UgY2FsbHMgZm9yIHRoZSBjYXNlIHRoYXQgYXBwcm92ZSgpIGlzIGluc3RhbnRseSBpbnZva2VkXG4gICAgICAgICAgICAgIC8vIGluIHRoZSBsaXN0ZW5lciB0aGF0IHJlY2VpdmVzIHRoZXNlIGNhbGxiYWNrcyBhcyBpdCBvdGhlcndpc2Ugd291bGQgYWxyZWFkeVxuICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIFwid2FpdGluZyBmb3Igc3RhY2sgYXBwcm92YWxcIiBldmVudCBmcm9tIHRoZSBidWZmZXIgYmVmb3JlIHdlIGV2ZW5cbiAgICAgICAgICAgICAgLy8gc2V0IHdhaXRpbmdGb3JBcHByb3ZhbCB0byB0cnVlIChhdCB0aGUgZW5kIG9mIHRoaXMgaWYgc3RhdGVtZW50KSB3aGljaCByZXN1bHRzXG4gICAgICAgICAgICAgIC8vIGluIGJ1ZmZlcmVkIHVwZGF0ZXMgd2hpY2ggd2lsbCBuZXZlciB1bmJsb2NrXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgICAgKCkgPT4gdGhpcy5pb0hhbmRsZXIucmVzdW1lQWZ0ZXJVc2VySW5wdXQodXBkYXRlLnN0YWNrTmFtZSksXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIC8vIGFsd2F5cyBzZW5kIHRvIGJ1ZmZlciwgYXMgcmVzdW1lQWZ0ZXJVc2VySW5wdXQoKSBhbHdheXMgZXhwZWN0cyBhIG1hdGNoaW5nIGV2ZW50XG4gICAgdGhpcy5pb0hhbmRsZXIucHVzaEV2ZW50KHtcbiAgICAgIGNiOiBvcmlnaW5hbENhbGxiYWNrLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogZXZlbnRUeXBlLFxuICAgICAgICBzdGFja05hbWU6IHVwZGF0ZS5zdGFja05hbWUsXG4gICAgICAgIC4uLmNhbGxiYWNrcyh1cGRhdGUgYXMgViksXG4gICAgICB9IGFzIFQsXG4gICAgICB0eXBlOiBcInByb2plY3RVcGRhdGVcIixcbiAgICB9KTtcblxuICAgIC8vIGlmIHdlIGFyZW4ndCBhbHJlYWR5IHdhaXRpbmcsIHRoaXMgbmVlZHMgdG8gZ28gdG8gY2IoKSB0b28gdG8gYXJyaXZlIGF0IHRoZSBVSVxuICAgIGlmICghdGhpcy5pb0hhbmRsZXIuaXNXYWl0aW5nRm9yVXNlcklucHV0KCkpIHtcbiAgICAgIG9yaWdpbmFsQ2FsbGJhY2soe1xuICAgICAgICB0eXBlOiBldmVudFR5cGUsXG4gICAgICAgIHN0YWNrTmFtZTogdXBkYXRlLnN0YWNrTmFtZSxcbiAgICAgICAgLi4uY2FsbGJhY2tzKHVwZGF0ZSBhcyBWKSxcbiAgICAgIH0gYXMgVCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVVc2VySW5wdXRQcm9jZXNzKGNiOiAodXBkYXRlVG9TZW5kOiBQcm9qZWN0VXBkYXRlKSA9PiB2b2lkKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHVwZGF0ZTpcbiAgICAgICAgfCBTdGFja1VwZGF0ZVxuICAgICAgICB8IFN0YWNrQXBwcm92YWxVcGRhdGVcbiAgICAgICAgfCBFeHRlcm5hbFN0YWNrQXBwcm92YWxVcGRhdGVcbiAgICAgICAgfCBTdGFja1NlbnRpbmVsT3ZlcnJpZGVVcGRhdGVcbiAgICAgICAgfCBFeHRlcm5hbFN0YWNrU2VudGluZWxPdmVycmlkZVVwZGF0ZVxuICAgICkgPT4ge1xuICAgICAgaWYgKHVwZGF0ZS50eXBlID09PSBcImV4dGVybmFsIHN0YWNrIGFwcHJvdmFsIHJlcGx5XCIpIHtcbiAgICAgICAgaWYgKCF1cGRhdGUuYXBwcm92ZWQpIHtcbiAgICAgICAgICB0aGlzLnN0b3BBbGxTdGFja3NUaGF0Q2FuTm90UnVuV2l0aG91dCh1cGRhdGUuc3RhY2tOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlvSGFuZGxlci5yZXN1bWVBZnRlclVzZXJJbnB1dCh1cGRhdGUuc3RhY2tOYW1lKTtcbiAgICAgICAgcmV0dXJuOyAvLyBha2EgZG9uJ3Qgc2VuZCB0aGlzIGV2ZW50IHRvIGFueSBidWZmZXJcbiAgICAgIH1cbiAgICAgIGlmICh1cGRhdGUudHlwZSA9PT0gXCJleHRlcm5hbCBzdGFjayBzZW50aW5lbCBvdmVycmlkZSByZXBseVwiKSB7XG4gICAgICAgIGlmICghdXBkYXRlLm92ZXJyaWRkZW4pIHtcbiAgICAgICAgICB0aGlzLnN0b3BBbGxTdGFja3NUaGF0Q2FuTm90UnVuV2l0aG91dCh1cGRhdGUuc3RhY2tOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlvSGFuZGxlci5yZXN1bWVBZnRlclVzZXJJbnB1dCh1cGRhdGUuc3RhY2tOYW1lKTtcbiAgICAgICAgcmV0dXJuOyAvLyBha2EgZG9uJ3Qgc2VuZCB0aGlzIGV2ZW50IHRvIGFueSBidWZmZXJcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICB1cGRhdGUudHlwZSA9PT0gXCJ3YWl0aW5nIGZvciBzdGFjayBhcHByb3ZhbFwiIHx8XG4gICAgICAgIHVwZGF0ZS50eXBlID09PSBcIndhaXRpbmcgZm9yIHN0YWNrIHNlbnRpbmVsIG92ZXJyaWRlXCJcbiAgICAgICkge1xuICAgICAgICBpZiAodXBkYXRlLnR5cGUgPT09IFwid2FpdGluZyBmb3Igc3RhY2sgYXBwcm92YWxcIikge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVXNlclVwZGF0ZTxNdWx0aVN0YWNrQXBwcm92YWxVcGRhdGUsIFN0YWNrQXBwcm92YWxVcGRhdGU+KFxuICAgICAgICAgICAgdXBkYXRlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBhcHByb3ZlOiAodXBkYXRlKSA9PiB1cGRhdGUuYXBwcm92ZSgpLFxuICAgICAgICAgICAgICBkaXNtaXNzOiAodXBkYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEFsbFN0YWNrc1RoYXRDYW5Ob3RSdW5XaXRob3V0KHVwZGF0ZS5zdGFja05hbWUpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdG9wOiAodXBkYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEFsbFN0YWNrcygpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNiLFxuICAgICAgICAgICAgXCJ3YWl0aW5nIGZvciBhcHByb3ZhbFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICh1cGRhdGUudHlwZSA9PT0gXCJ3YWl0aW5nIGZvciBzdGFjayBzZW50aW5lbCBvdmVycmlkZVwiKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVVc2VyVXBkYXRlPFxuICAgICAgICAgICAgTXVsdGlTdGFja1NlbnRpbmVsT3ZlcnJpZGVVcGRhdGUsXG4gICAgICAgICAgICBTdGFja1NlbnRpbmVsT3ZlcnJpZGVVcGRhdGVcbiAgICAgICAgICA+KFxuICAgICAgICAgICAgdXBkYXRlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdmVycmlkZTogKHVwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZS5vdmVycmlkZSgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZWplY3Q6ICh1cGRhdGUpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGUucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wQWxsU3RhY2tzVGhhdENhbk5vdFJ1bldpdGhvdXQodXBkYXRlLnN0YWNrTmFtZSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2IsXG4gICAgICAgICAgICBcIndhaXRpbmcgZm9yIHNlbnRpbmVsIG92ZXJyaWRlXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pb0hhbmRsZXIuYXdhaXRVc2VySW5wdXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlvSGFuZGxlci5pc1dhaXRpbmdGb3JVc2VySW5wdXQoKSkge1xuICAgICAgICAgIHRoaXMuaW9IYW5kbGVyLnB1c2hFdmVudCh7XG4gICAgICAgICAgICBjYixcbiAgICAgICAgICAgIHZhbHVlOiB1cGRhdGUsXG4gICAgICAgICAgICB0eXBlOiBcInByb2plY3RVcGRhdGVcIixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYih1cGRhdGUgYXMgUHJvamVjdFVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGdldFN0YWNrRXhlY3V0b3IoXG4gICAgc3RhY2s6IFN5bnRoZXNpemVkU3RhY2ssXG4gICAgb3B0czogQXV0b0FwcHJvdmVPcHRpb25zID0ge31cbiAgKSB7XG4gICAgY29uc3QgZW5oYW5jZUxvZ01lc3NhZ2UgPSBjcmVhdGVFbmhhbmNlTG9nTWVzc2FnZShzdGFjayk7XG4gICAgY29uc3Qgb25Mb2cgPSB0aGlzLmlvSGFuZGxlci5idWZmZXJXaGlsZUF3YWl0aW5nVXNlcklucHV0KHRoaXMub25Mb2cpO1xuICAgIHJldHVybiBuZXcgQ2RrdGZTdGFjayh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgc3RhY2ssXG4gICAgICBvblVwZGF0ZTogdGhpcy5oYW5kbGVVc2VySW5wdXRQcm9jZXNzKHRoaXMub25VcGRhdGUpLFxuICAgICAgb25Mb2c6IG9uTG9nXG4gICAgICAgID8gKHsgbWVzc2FnZSB9KSA9PlxuICAgICAgICAgICAgb25Mb2coe1xuICAgICAgICAgICAgICBzdGFja05hbWU6IHN0YWNrLm5hbWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIG1lc3NhZ2VXaXRoQ29uc3RydWN0UGF0aDogZW5oYW5jZUxvZ01lc3NhZ2UobWVzc2FnZSksXG4gICAgICAgICAgICB9KVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIGFib3J0U2lnbmFsOiB0aGlzLmFib3J0U2lnbmFsLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGdldCBvdXRwdXRzQnlDb25zdHJ1Y3RJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja3NUb1J1bi5yZWR1Y2UoXG4gICAgICAoYWNjLCBzdGFjaykgPT4gKHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICAuLi5zdGFjay5vdXRwdXRzQnlDb25zdHJ1Y3RJZCxcbiAgICAgIH0pLFxuICAgICAge30gYXMgTmVzdGVkVGVycmFmb3JtT3V0cHV0c1xuICAgICk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc3ludGgobm9Db2xvcj86IGJvb2xlYW4pIHtcbiAgICB0aGlzLm9uVXBkYXRlKHtcbiAgICAgIHR5cGU6IFwic3ludGhlc2l6aW5nXCIsXG4gICAgfSk7XG5cbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBTeW50aFN0YWNrLnN5bnRoKFxuICAgICAgdGhpcy5hYm9ydFNpZ25hbCBhcyBhbnksXG4gICAgICB0aGlzLnN5bnRoQ29tbWFuZCxcbiAgICAgIHRoaXMub3V0RGlyLFxuICAgICAgdGhpcy53b3JraW5nRGlyZWN0b3J5LFxuICAgICAgZmFsc2UsXG4gICAgICBub0NvbG9yLFxuICAgICAgdGhpcy5zeW50aE9yaWdpbixcbiAgICAgIHRoaXMuaGNsXG4gICAgKTtcblxuICAgIHByaW50QW5ub3RhdGlvbnMoc3RhY2tzKTtcblxuICAgIHRoaXMub25VcGRhdGUoe1xuICAgICAgdHlwZTogXCJzeW50aGVzaXplZFwiLFxuICAgICAgc3RhY2tzLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByZWFkU3ludGhlc2l6ZWRTdGFja3MoKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgU3ludGhTdGFjay5yZWFkU3ludGhlc2l6ZWRTdGFja3ModGhpcy5vdXREaXIpO1xuXG4gICAgcHJpbnRBbm5vdGF0aW9ucyhzdGFja3MpO1xuXG4gICAgdGhpcy5vblVwZGF0ZSh7XG4gICAgICB0eXBlOiBcInN5bnRoZXNpemVkXCIsXG4gICAgICBzdGFja3MsXG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkaWZmKG9wdHM6IERpZmZPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzdGFja3MgPSBvcHRzLnNraXBTeW50aFxuICAgICAgPyBhd2FpdCB0aGlzLnJlYWRTeW50aGVzaXplZFN0YWNrcygpXG4gICAgICA6IGF3YWl0IHRoaXMuc3ludGgob3B0cy5ub0NvbG9yKTtcbiAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2tFeGVjdXRvcihcbiAgICAgIGdldFNpbmdsZVN0YWNrKHN0YWNrcywgb3B0cz8uc3RhY2tOYW1lLCBcImRpZmZcIilcbiAgICApO1xuICAgIGF3YWl0IHN0YWNrLmluaXRhbGl6ZVRlcnJhZm9ybShvcHRzLm5vQ29sb3IpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHN0YWNrLmRpZmYob3B0cyk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICB0aHJvdyBFcnJvcnMuRXh0ZXJuYWwoXG4gICAgICAgIGBTdGFjayBmYWlsZWQgdG8gcGxhbjogJHtzdGFjay5zdGFjay5uYW1lfS4gUGxlYXNlIGNoZWNrIHRoZSBsb2dzIGZvciBtb3JlIGluZm9ybWF0aW9uLmAsXG4gICAgICAgIGVcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChzdGFjay5lcnJvcikge1xuICAgICAgdGhyb3cgRXJyb3JzLkV4dGVybmFsKFxuICAgICAgICBgU3RhY2sgZmFpbGVkIHRvIHBsYW46ICR7c3RhY2suc3RhY2submFtZX0uIFBsZWFzZSBjaGVjayB0aGUgbG9ncyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gLFxuICAgICAgICBuZXcgRXJyb3Ioc3RhY2suZXJyb3IpXG4gICAgICApO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnByb2plY3RUZWxlbWV0cnkoXCJkaWZmXCIsIHtcbiAgICAgICAgc3RhY2tNZXRhZGF0YTogc3RhY2tzLm1hcCgoc3RhY2spID0+XG4gICAgICAgICAgSlNPTi5wYXJzZShzdGFjay5jb250ZW50KVtcIi8vXCJdXG4gICAgICAgICAgICA/IEpTT04ucGFyc2Uoc3RhY2suY29udGVudClbXCIvL1wiXS5tZXRhZGF0YVxuICAgICAgICAgICAgOiB7fVxuICAgICAgICApLFxuICAgICAgICBlcnJvcnM6IHN0YWNrLmVycm9yLFxuICAgICAgICByZXF1aXJlZFByb3ZpZGVyczogc3RhY2tzLm1hcCgoc3RhY2s6IGFueSkgPT5cbiAgICAgICAgICBKU09OLnBhcnNlKHN0YWNrLmNvbnRlbnQpW1widGVycmFmb3JtXCJdXG4gICAgICAgICAgICA/IEpTT04ucGFyc2Uoc3RhY2suY29udGVudClbXCJ0ZXJyYWZvcm1cIl0ucmVxdWlyZWRfcHJvdmlkZXJzXG4gICAgICAgICAgICA6IHt9XG4gICAgICAgICksXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuZGVidWcoXCJGYWlsZWQgdG8gc2VuZCB0ZWxlbWV0cnlcIiwgZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBleGVjdXRlKFxuICAgIG1ldGhvZDogXCJkZXBsb3lcIiB8IFwiZGVzdHJveVwiLFxuICAgIG5leHQ6ICgpID0+IFByb21pc2U8Q2RrdGZTdGFjayB8IHVuZGVmaW5lZD4sXG4gICAgb3B0czogTXV0YXRpb25PcHRpb25zXG4gICkge1xuICAgIC8vIFdlIG9ubHkgc3VwcG9ydCByZWZyZXNoIG9ubHkgb24gZGVwbG95LCBhIGJpdCBvZiBhIGxlYWt5IGFic3RyYWN0aW9uIGhlcmVcbiAgICBpZiAob3B0cy5yZWZyZXNoT25seSAmJiBtZXRob2QgIT09IFwiZGVwbG95XCIpIHtcbiAgICAgIHRocm93IEVycm9ycy5JbnRlcm5hbChgUmVmcmVzaCBvbmx5IGlzIG9ubHkgc3VwcG9ydGVkIG9uIGRlcGxveWApO1xuICAgIH1cbiAgICBjb25zdCBtYXhQYXJhbGxlbFJ1bnMgPVxuICAgICAgIW9wdHMucGFyYWxsZWxpc20gfHwgb3B0cy5wYXJhbGxlbGlzbSA8IDAgPyBJbmZpbml0eSA6IG9wdHMucGFyYWxsZWxpc207XG4gICAgY29uc3QgYWxsRXhlY3V0aW9ucyA9IFtdO1xuXG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplU3RhY2tzVG9SdW5JblNlcmlhbChvcHRzLm5vQ29sb3IpO1xuICAgIHdoaWxlICh0aGlzLnN0YWNrc1RvUnVuLmZpbHRlcigoc3RhY2spID0+IHN0YWNrLmlzUGVuZGluZykubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcnVubmluZ1N0YWNrcyA9IHRoaXMuc3RhY2tzVG9SdW4uZmlsdGVyKChzdGFjaykgPT4gc3RhY2suaXNSdW5uaW5nKTtcbiAgICAgIGlmIChydW5uaW5nU3RhY2tzLmxlbmd0aCA+PSBtYXhQYXJhbGxlbFJ1bnMpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKHJ1bm5pbmdTdGFja3MubWFwKChzKSA9PiBzLmN1cnJlbnRXb3JrUHJvbWlzZSkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5leHRSdW5uaW5nRXhlY3V0b3IgPSBhd2FpdCBuZXh0KCk7XG4gICAgICAgIGlmICghbmV4dFJ1bm5pbmdFeGVjdXRvcikge1xuICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBoYXZlIG5vIHBlbmRpbmcgc3RhY2tzLCBidXQgd2UgYWxzbyBjYW4gbm90IGZpbmQgYSBuZXcgZXhlY3V0b3JcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID1cbiAgICAgICAgICBtZXRob2QgPT09IFwiZGVwbG95XCJcbiAgICAgICAgICAgID8gbmV4dFJ1bm5pbmdFeGVjdXRvci5kZXBsb3kob3B0cylcbiAgICAgICAgICAgIDogbmV4dFJ1bm5pbmdFeGVjdXRvci5kZXN0cm95KG9wdHMpO1xuXG4gICAgICAgIGFsbEV4ZWN1dGlvbnMucHVzaChwcm9taXNlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gYXdhaXQgbmV4dCgpIHRocmV3IGFuIGVycm9yIGJlY2F1c2UgYSBzdGFjayBmYWlsZWQgdG8gYXBwbHkvZGVzdHJveVxuICAgICAgICAvLyB3YWl0IGZvciBhbGwgb3RoZXIgY3VycmVudGx5IHJ1bm5pbmcgc3RhY2tzIHRvIGNvbXBsZXRlIGJlZm9yZSBwcm9wYWdhdGluZyB0aGF0IGVycm9yXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGF3YWl0aW5nIHN0YWNrIHRvIGZpbmlzaFwiLCBlKTtcbiAgICAgICAgY29uc3Qgb3BlblN0YWNrcyA9IHRoaXMuc3RhY2tzVG9SdW4uZmlsdGVyKFxuICAgICAgICAgIChleCkgPT4gZXguY3VycmVudFdvcmtQcm9taXNlXG4gICAgICAgICk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIldhaXRpbmcgZm9yIHN0aWxsIHJ1bm5pbmcgc3RhY2tzIHRvIGZpbmlzaDpcIiwgb3BlblN0YWNrcyk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChvcGVuU3RhY2tzLm1hcCgoZXgpID0+IGV4LmN1cnJlbnRXb3JrUHJvbWlzZSkpO1xuICAgICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgICAgXCJEb25lIHdhaXRpbmcgZm9yIHN0aWxsIHJ1bm5pbmcgc3RhY2tzLiBBbGwgcGVuZGluZyB3b3JrIGZpbmlzaGVkXCJcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgZW5kIHRoZSBsb29wIHdoZW4gYWxsIHN0YWNrcyBhcmUgc3RhcnRlZCwgbm93IHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlbSB0byBiZSBkb25lXG4gICAgLy8gV2Ugd2FpdCBmb3IgYWxsIHdvcmsgdG8gZmluaXNoIGV2ZW4gaWYgb25lIG9mIHRoZSBwcm9taXNlcyB0aHJldyBhbiBlcnJvci5cbiAgICBhd2FpdCBlbnN1cmVBbGxTZXR0bGVkQmVmb3JlVGhyb3dpbmcoXG4gICAgICBQcm9taXNlLmFsbChhbGxFeGVjdXRpb25zKSxcbiAgICAgIGFsbEV4ZWN1dGlvbnNcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlcGxveShvcHRzOiBNdXRhdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHN0YWNrcyA9IG9wdHMuc2tpcFN5bnRoXG4gICAgICA/IGF3YWl0IHRoaXMucmVhZFN5bnRoZXNpemVkU3RhY2tzKClcbiAgICAgIDogYXdhaXQgdGhpcy5zeW50aChvcHRzLm5vQ29sb3IpO1xuICAgIGNvbnN0IHN0YWNrc1RvUnVuID0gZ2V0TXVsdGlwbGVTdGFja3Moc3RhY2tzLCBvcHRzLnN0YWNrTmFtZXMsIFwiZGVwbG95XCIpO1xuICAgIGlmICghb3B0cy5pZ25vcmVNaXNzaW5nU3RhY2tEZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNoZWNrSWZBbGxEZXBlbmRlbmNpZXNBcmVJbmNsdWRlZChzdGFja3NUb1J1bik7XG4gICAgfVxuXG4gICAgdGhpcy5zdG9wQWxsU3RhY2tzVGhhdENhbk5vdFJ1bldpdGhvdXQgPSAoc3RhY2tOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGZpbmRBbGxOZXN0ZWREZXBlbmRhbnRTdGFja3ModGhpcy5zdGFja3NUb1J1biwgc3RhY2tOYW1lKS5mb3JFYWNoKFxuICAgICAgICAoc3RhY2spID0+IHN0YWNrLnN0b3AoKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdGFja3NUb1J1biA9IHN0YWNrc1RvUnVuLm1hcCgoc3RhY2spID0+XG4gICAgICB0aGlzLmdldFN0YWNrRXhlY3V0b3Ioc3RhY2ssIG9wdHMpXG4gICAgKTtcblxuICAgIGNvbnN0IG5leHQgPSBvcHRzLmlnbm9yZU1pc3NpbmdTdGFja0RlcGVuZGVuY2llc1xuICAgICAgPyAoKSA9PlxuICAgICAgICAgIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICAgIHRoaXMuc3RhY2tzVG9SdW4uZmlsdGVyKChzdGFjaykgPT4gc3RhY2suaXNQZW5kaW5nKVswXVxuICAgICAgICAgIClcbiAgICAgIDogKCkgPT4gZ2V0U3RhY2tXaXRoTm9Vbm1ldERlcGVuZGVuY2llcyh0aGlzLnN0YWNrc1RvUnVuKTtcblxuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZShcImRlcGxveVwiLCBuZXh0LCBvcHRzKTtcblxuICAgIGNvbnN0IHVucHJvY2Vzc2VkU3RhY2tzID0gdGhpcy5zdGFja3NUb1J1bi5maWx0ZXIoXG4gICAgICAoZXhlY3V0b3IpID0+IGV4ZWN1dG9yLmlzUGVuZGluZ1xuICAgICk7XG4gICAgaWYgKHVucHJvY2Vzc2VkU3RhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IEVycm9ycy5FeHRlcm5hbChcbiAgICAgICAgYFNvbWUgc3RhY2tzIGZhaWxlZCB0byBkZXBsb3k6ICR7dW5wcm9jZXNzZWRTdGFja3NcbiAgICAgICAgICAubWFwKChzKSA9PiBzLnN0YWNrLm5hbWUpXG4gICAgICAgICAgLmpvaW4oXCIsIFwiKX0uIFBsZWFzZSBjaGVjayB0aGUgbG9ncyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnByb2plY3RUZWxlbWV0cnkoXCJkZXBsb3lcIiwge1xuICAgICAgICBzdGFja01ldGFkYXRhOiBzdGFja3NUb1J1bi5tYXAoKHN0YWNrKSA9PlxuICAgICAgICAgIEpTT04ucGFyc2Uoc3RhY2suY29udGVudClbXCIvL1wiXVxuICAgICAgICAgICAgPyBKU09OLnBhcnNlKHN0YWNrLmNvbnRlbnQpW1wiLy9cIl0ubWV0YWRhdGFcbiAgICAgICAgICAgIDoge31cbiAgICAgICAgKSxcbiAgICAgICAgZmFpbGVkU3RhY2tzOiB1bnByb2Nlc3NlZFN0YWNrcy5tYXAoKHN0YWNrKSA9PiBzdGFjay5lcnJvciksXG4gICAgICAgIHJlcXVpcmVkUHJvdmlkZXJzOiBzdGFja3NUb1J1bi5tYXAoKHN0YWNrOiBhbnkpID0+XG4gICAgICAgICAgSlNPTi5wYXJzZShzdGFjay5jb250ZW50KVtcInRlcnJhZm9ybVwiXVxuICAgICAgICAgICAgPyBKU09OLnBhcnNlKHN0YWNrLmNvbnRlbnQpW1widGVycmFmb3JtXCJdLnJlcXVpcmVkX3Byb3ZpZGVyc1xuICAgICAgICAgICAgOiB7fVxuICAgICAgICApLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiRmFpbGVkIHRvIHNlbmQgdGVsZW1ldHJ5XCIsIGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZXN0cm95KG9wdHM6IE11dGF0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgc3RhY2tzID0gb3B0cy5za2lwU3ludGhcbiAgICAgID8gYXdhaXQgdGhpcy5yZWFkU3ludGhlc2l6ZWRTdGFja3MoKVxuICAgICAgOiBhd2FpdCB0aGlzLnN5bnRoKG9wdHMubm9Db2xvcik7XG4gICAgY29uc3Qgc3RhY2tzVG9SdW4gPSBnZXRNdWx0aXBsZVN0YWNrcyhzdGFja3MsIG9wdHMuc3RhY2tOYW1lcywgXCJkZXN0cm95XCIpO1xuXG4gICAgaWYgKCFvcHRzLmlnbm9yZU1pc3NpbmdTdGFja0RlcGVuZGVuY2llcykge1xuICAgICAgY2hlY2tJZkFsbERlcGVuZGFudHNBcmVJbmNsdWRlZChzdGFja3NUb1J1biwgc3RhY2tzKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3BBbGxTdGFja3NUaGF0Q2FuTm90UnVuV2l0aG91dCA9IChzdGFja05hbWU6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3Qgc3RhY2tFeGVjdXRvciA9IHRoaXMuc3RhY2tzVG9SdW4uZmluZChcbiAgICAgICAgKHMpID0+IHMuc3RhY2submFtZSA9PT0gc3RhY2tOYW1lXG4gICAgICApO1xuICAgICAgaWYgKCFzdGFja0V4ZWN1dG9yKSB7XG4gICAgICAgIHRocm93IEVycm9ycy5JbnRlcm5hbChcbiAgICAgICAgICBgQ291bGQgbm90IGZpbmQgc3RhY2sgXCIke3N0YWNrTmFtZX1cIiB0aGF0IHdhcyBzdG9wcGVkYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBzdGFja0V4ZWN1dG9yLnN0YWNrLmRlcGVuZGVuY2llcy5mb3JFYWNoKChkZXBlbmRhbnQpID0+IHtcbiAgICAgICAgdGhpcy5zdG9wQWxsU3RhY2tzVGhhdENhbk5vdFJ1bldpdGhvdXQoZGVwZW5kYW50KTtcblxuICAgICAgICBjb25zdCBkZXBlbmRhbnRTdGFjayA9IHRoaXMuc3RhY2tzVG9SdW4uZmluZChcbiAgICAgICAgICAocykgPT4gcy5zdGFjay5uYW1lID09PSBkZXBlbmRhbnRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFkZXBlbmRhbnRTdGFjaykge1xuICAgICAgICAgIHRocm93IEVycm9ycy5JbnRlcm5hbChcbiAgICAgICAgICAgIGBDb3VsZCBub3QgZmluZCBzdGFjayBcIiR7ZGVwZW5kYW50fVwiIHRoYXQgd2FzIHN0b3BwZWRgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcGVuZGFudFN0YWNrLnN0b3AoKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5zdGFja3NUb1J1biA9IHN0YWNrc1RvUnVuLm1hcCgoc3RhY2spID0+XG4gICAgICB0aGlzLmdldFN0YWNrRXhlY3V0b3Ioc3RhY2ssIG9wdHMpXG4gICAgKTtcbiAgICBjb25zdCBuZXh0ID0gb3B0cy5pZ25vcmVNaXNzaW5nU3RhY2tEZXBlbmRlbmNpZXNcbiAgICAgID8gKCkgPT5cbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgICB0aGlzLnN0YWNrc1RvUnVuLmZpbHRlcigoc3RhY2spID0+IHN0YWNrLmN1cnJlbnRTdGF0ZSAhPT0gXCJkb25lXCIpWzBdXG4gICAgICAgICAgKVxuICAgICAgOiAoKSA9PiBnZXRTdGFja1dpdGhOb1VubWV0RGVwZW5kYW50cyh0aGlzLnN0YWNrc1RvUnVuKTtcblxuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZShcImRlc3Ryb3lcIiwgbmV4dCwgb3B0cyk7XG5cbiAgICBjb25zdCB1bnByb2Nlc3NlZFN0YWNrcyA9IHRoaXMuc3RhY2tzVG9SdW4uZmlsdGVyKFxuICAgICAgKGV4ZWN1dG9yKSA9PiBleGVjdXRvci5pc1BlbmRpbmdcbiAgICApO1xuICAgIGlmICh1bnByb2Nlc3NlZFN0YWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBFcnJvcnMuRXh0ZXJuYWwoXG4gICAgICAgIGBTb21lIHN0YWNrcyBmYWlsZWQgdG8gZGVzdHJveTogJHt1bnByb2Nlc3NlZFN0YWNrc1xuICAgICAgICAgIC5tYXAoKHMpID0+IHMuc3RhY2submFtZSlcbiAgICAgICAgICAuam9pbihcIiwgXCIpfS4gUGxlYXNlIGNoZWNrIHRoZSBsb2dzIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucHJvamVjdFRlbGVtZXRyeShcImRlc3Ryb3lcIiwge1xuICAgICAgICBzdGFja01ldGFkYXRhOiBzdGFja3NUb1J1bi5tYXAoKHN0YWNrKSA9PlxuICAgICAgICAgIEpTT04ucGFyc2Uoc3RhY2suY29udGVudClbXCIvL1wiXVxuICAgICAgICAgICAgPyBKU09OLnBhcnNlKHN0YWNrLmNvbnRlbnQpW1wiLy9cIl0ubWV0YWRhdGFcbiAgICAgICAgICAgIDoge31cbiAgICAgICAgKSxcbiAgICAgICAgZmFpbGVkU3RhY2tzOiB1bnByb2Nlc3NlZFN0YWNrcy5tYXAoKHN0YWNrKSA9PiBzdGFjay5lcnJvciksXG4gICAgICAgIHJlcXVpcmVkUHJvdmlkZXJzOiBzdGFja3NUb1J1bi5tYXAoKHN0YWNrOiBhbnkpID0+XG4gICAgICAgICAgSlNPTi5wYXJzZShzdGFjay5jb250ZW50KVtcInRlcnJhZm9ybVwiXVxuICAgICAgICAgICAgPyBKU09OLnBhcnNlKHN0YWNrLmNvbnRlbnQpW1widGVycmFmb3JtXCJdLnJlcXVpcmVkX3Byb3ZpZGVyc1xuICAgICAgICAgICAgOiB7fVxuICAgICAgICApLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiRmFpbGVkIHRvIHNlbmQgdGVsZW1ldHJ5XCIsIGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwcm9qZWN0VGVsZW1ldHJ5KGNvbW1hbmQ6IHN0cmluZywgcGF5bG9hZDogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY29uZmlnID0gcmVhZENvbmZpZ1N5bmMoKTtcbiAgICBhd2FpdCBzZW5kVGVsZW1ldHJ5KGNvbW1hbmQsIHtcbiAgICAgIC4uLnBheWxvYWQsXG4gICAgICBsYW5ndWFnZTogY29uZmlnLmxhbmd1YWdlLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGZldGNoT3V0cHV0cyhvcHRzOiBGZXRjaE91dHB1dE9wdGlvbnMpIHtcbiAgICBjb25zdCBzdGFja3MgPSBvcHRzLnNraXBTeW50aFxuICAgICAgPyBhd2FpdCB0aGlzLnJlYWRTeW50aGVzaXplZFN0YWNrcygpXG4gICAgICA6IGF3YWl0IHRoaXMuc3ludGgoKTtcblxuICAgIGNvbnN0IHN0YWNrc1RvUnVuID0gZ2V0TXVsdGlwbGVTdGFja3MoXG4gICAgICBzdGFja3MsXG4gICAgICBvcHRzLnN0YWNrTmFtZXMgfHwgW10sXG4gICAgICBcImRlcGxveVwiXG4gICAgKTtcblxuICAgIGlmIChzdGFja3NUb1J1bi5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN0YWNrcyB0byBmZXRjaCBvdXRwdXRzIGZvciBzcGVjaWZpZWRcIik7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFja3NUb1J1biA9IHN0YWNrc1RvUnVuLm1hcCgoc3RhY2spID0+XG4gICAgICAvLyBPcHRpb25zIGFyZSBlbXB0eSwgYmVjYXVzZSBNdWx0aXBsZVN0YWNrT3B0aW9ucyBkb2Vzbid0IGhhdmUgYW55IHJlbGV2YW50XG4gICAgICAvLyBvcHRpb25zIGZvciBgZ2V0U3RhY2tFeGVjdXRvcmAsIGhlbmNlIGRlZmF1bHRzIGFyZSBmaW5lXG4gICAgICB0aGlzLmdldFN0YWNrRXhlY3V0b3Ioc3RhY2ssIHt9KVxuICAgICk7XG5cbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVTdGFja3NUb1J1bkluU2VyaWFsKCk7XG4gICAgY29uc3Qgb3V0cHV0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5zdGFja3NUb1J1bi5tYXAoYXN5bmMgKHMpID0+IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcy5mZXRjaE91dHB1dHMoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBbcy5zdGFjay5uYW1lXTogb3V0cHV0LFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIG91dHB1dHMucmVkdWNlKFxuICAgICAgKGFjYywgY3VycikgPT4gKHsgLi4uYWNjLCAuLi5jdXJyIH0pLFxuICAgICAge31cbiAgICApIGFzIE5lc3RlZFRlcnJhZm9ybU91dHB1dHM7XG4gIH1cblxuICAvLyBTZXJpYWxseSBydW4gdGVycmFmb3JtIGluaXQgdG8gcHJvaGliaXQgdGV4dCBmaWxlIGJ1c3kgZXJyb3JzIGZvciB0aGUgY2FjaGUgZmlsZXNcbiAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplU3RhY2tzVG9SdW5JblNlcmlhbChcbiAgICBub0NvbG9yPzogYm9vbGVhblxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHRoaXMuc3RhY2tzVG9SdW4pIHtcbiAgICAgIGF3YWl0IHN0YWNrLmluaXRhbGl6ZVRlcnJhZm9ybShub0NvbG9yKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==