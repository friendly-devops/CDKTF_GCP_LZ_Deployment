"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dynamicVariableToAst = exports.extractIteratorVariablesFromExpression = exports.convertTerraformExpressionToTs = exports.expressionAst = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const t = __importStar(require("@babel/types"));
const template_1 = __importDefault(require("@babel/template"));
const utils_1 = require("./utils");
const hcl2json_1 = require("@cdktf/hcl2json");
const hcl2json_2 = require("@cdktf/hcl2json");
const functions_1 = require("./function-bindings/functions");
const coerceType_1 = require("./coerceType");
const terraformSchema_1 = require("./terraformSchema");
const references_1 = require("./references");
const variables_1 = require("./variables");
const syntax_tree_1 = require("@cdktf/hcl2json/lib/syntax-tree");
const tfBinaryOperatorsToCdktf = {
    logicalOr: "or",
    logicalAnd: "and",
    greaterThan: "gt",
    greaterThanOrEqual: "gte",
    lessThan: "lt",
    lessThanOrEqual: "lte",
    equal: "eq",
    notEqual: "neq",
    add: "add",
    subtract: "sub",
    multiply: "mul",
    divide: "div",
    modulo: "mod",
};
const tfUnaryOperatorsToCdktf = {
    logicalNot: "not",
    negate: "negate",
};
function traversalPartsToString(traversals, asSuffix = false) {
    let seed = "";
    if (asSuffix && hcl2json_2.TFExpressionSyntaxTree.isNameTraversalPart(traversals[0])) {
        seed = ".";
    }
    return traversals.reduce((acc, part) => {
        if (part.type === "nameTraversal") {
            if (acc === seed) {
                return `${acc}${part.segment}`;
            }
            return `${acc}.${part.segment}`;
        }
        return `${acc}[${part.segment}]`;
    }, seed);
}
function canUseFqn(expression) {
    if (!hcl2json_2.TFExpressionSyntaxTree.isScopeTraversalExpression(expression)) {
        return false;
    }
    const rootSegment = expression.meta.traversal[0].segment;
    return !["var", "local"].includes(rootSegment);
}
function traversalToVariableName(scope, node) {
    if (!hcl2json_2.TFExpressionSyntaxTree.isScopeTraversalExpression(node)) {
        utils_1.logger.error(`Unexpected expression type ${node.type} with value ${node.meta.value} passed to convert to a variable. 
        ${utils_1.leaveCommentText}`);
        return "";
    }
    const segments = node.meta.traversal;
    if (segments.length === 1) {
        return node.meta.fullAccessor;
    }
    const rootSegment = segments[0].segment;
    const resource = rootSegment === "data"
        ? `${segments[0].segment}.${segments[1].segment}`
        : rootSegment;
    const name = rootSegment === "data" ? segments[2].segment : segments[1].segment;
    return (0, variables_1.variableName)(scope, resource, name);
}
function expressionForSerialStringConcatenation(scope, nodes) {
    const reducedNodes = nodes.reduce((acc, node) => {
        const prev = acc[acc.length - 1];
        if (!prev)
            return [node];
        if (t.isStringLiteral(prev) && t.isStringLiteral(node)) {
            acc.pop();
            acc.push(t.stringLiteral(prev.value + node.value));
            return acc;
        }
        acc.push(node);
        return acc;
    }, []);
    return reducedNodes.reduce((acc, node) => {
        if (!acc) {
            return node;
        }
        // wrap access to dynamic blocks in Token.asString() as they return a Lazy
        // for .key and .value which can't be concatenated in languages like Python
        // because JSII currently has no support for the toString() method in
        // languages other than TypeScript: https://github.com/aws/jsii/issues/380
        // example: dynamic_iterator0.key / dynamic_iterator0.value
        if (t.isMemberExpression(node) &&
            t.isIdentifier(node.object) &&
            Object.values(scope.scopedVariables || {}).includes(node.object.name) &&
            t.isIdentifier(node.property) &&
            ["key", "value"].includes(node.property.name)) {
            node = (0, coerceType_1.coerceType)(scope, node, "dynamic", "string");
        }
        return t.binaryExpression("+", acc, node);
    });
}
function getTfResourcePathFromNode(node) {
    const segments = node.meta.traversal;
    let resource = segments[0].segment;
    let result = [];
    let attributes = [];
    if (segments[0].segment === "data") {
        result.push(segments[0].segment);
        resource = segments[1].segment;
        attributes = segments.slice(3); // we want to skip the variable name
    }
    else {
        attributes = segments.slice(2); // we want to skip the variable name
    }
    const [provider, ...resourceNameFragments] = resource.split("_");
    // Hack: This happens in the case of `external` provider
    // where the data source does not have a provider name prefix
    if (resourceNameFragments.length === 0) {
        resourceNameFragments.push(provider);
    }
    result.push(provider);
    result.push(resourceNameFragments.join("_"));
    result = [
        ...result,
        ...attributes.map((seg) => {
            if (hcl2json_2.TFExpressionSyntaxTree.isIndexTraversalPart(seg)) {
                return `[${seg.segment}]`;
            }
            return seg.segment;
        }),
    ];
    return result.join(".");
}
function convertLiteralValueExpressionToTs(_scope, node) {
    const literalType = node.meta.type;
    if (literalType === "number") {
        return t.numericLiteral(Number(node.meta.value));
    }
    if (literalType === "bool") {
        return t.booleanLiteral(node.meta.value === "true" ? true : false);
    }
    return t.stringLiteral(node.meta.value);
}
function convertScopeTraversalExpressionToTs(scope, node) {
    var _a;
    const hasReference = (0, references_1.containsReference)(node);
    const segments = node.meta.traversal;
    if (segments[0].segment === "each" && scope.forEachIteratorName) {
        return dynamicVariableToAst(scope, node, scope.forEachIteratorName);
    }
    if (segments[0].segment === "count" && scope.countIteratorName) {
        return dynamicVariableToAst(scope, node, scope.countIteratorName, "count");
    }
    if (segments[0].segment === "self") {
        scope.importables.push({
            constructName: "TerraformSelf",
            provider: "cdktf",
        });
        return t.callExpression(t.memberExpression(t.identifier("TerraformSelf"), t.identifier("getAny")), [t.stringLiteral(traversalPartsToString(segments.slice(1)))]);
    }
    // setting.value, setting.value[1].id
    const dynamicBlock = (_a = scope.scopedVariables) === null || _a === void 0 ? void 0 : _a[segments[0].segment];
    if (dynamicBlock) {
        if (dynamicBlock === "dynamic-block") {
            return dynamicVariableToAst(scope, node, dynamicBlock, traversalPartsToString(segments));
        }
        return dynamicVariableToAst(scope, node, dynamicBlock, segments[0].segment);
    }
    // This may be a variable reference that we don't understand yet, so we wrap it in a template string
    // for Terraform to handle
    let varIdentifier = t.stringLiteral(`\${${node.meta.fullAccessor}}`);
    if (hasReference) {
        varIdentifier = t.identifier((0, utils_1.camelCase)(traversalToVariableName(scope, node)));
    }
    if (["var", "local"].includes(segments[0].segment)) {
        const variableAccessor = segments[0].segment === "var"
            ? t.memberExpression(varIdentifier, t.identifier("value"))
            : varIdentifier;
        if (segments.length > 2) {
            scope.importables.push({
                constructName: "Fn",
                provider: "cdktf",
            });
            const callee = t.memberExpression(t.identifier("Fn"), t.identifier("lookupNested"));
            return t.callExpression(callee, [
                variableAccessor,
                t.arrayExpression(segments.slice(2).map((s) => t.stringLiteral(s.segment))),
            ]);
        }
        return variableAccessor;
    }
    if (!hasReference || scope.withinOverrideExpression) {
        return varIdentifier;
    }
    const rootSegment = segments[0].segment;
    const attributeIndex = rootSegment === "data" ? 3 : 2;
    const attributeSegments = segments.slice(attributeIndex);
    const numericAccessorIndex = attributeSegments.findIndex((seg) => hcl2json_2.TFExpressionSyntaxTree.isIndexTraversalPart(seg));
    let minAccessorIndex = numericAccessorIndex;
    let mapAccessorIndex = -1;
    if (numericAccessorIndex === -1) {
        // only do this if we have to, if we already have a
        // numeric accessor, we don't have to do this additional work
        const resourcePath = getTfResourcePathFromNode(node);
        let usingSubPathType = false;
        let parts = resourcePath.split(".").filter((p) => p !== "");
        const minParts = attributeIndex; // we need to stop before data.aws.resource_name or aws.resource_name
        const originalParts = parts.length;
        let hasMapAccessor = false;
        while (parts.length >= minParts) {
            const type = (0, terraformSchema_1.getTypeAtPath)(scope.providerSchema, parts.join("."));
            if (type !== null) {
                if (Array.isArray(type) && type[0] === "map" && usingSubPathType) {
                    hasMapAccessor = true;
                    break;
                }
            }
            parts.pop();
            usingSubPathType = true;
        }
        if (hasMapAccessor) {
            mapAccessorIndex = originalParts - parts.length - 1;
            minAccessorIndex = mapAccessorIndex;
        }
    }
    const needsPropertyAccess = minAccessorIndex >= 0;
    const refSegments = needsPropertyAccess
        ? attributeSegments.slice(0, minAccessorIndex)
        : attributeSegments;
    const nonRefSegments = needsPropertyAccess
        ? attributeSegments.slice(minAccessorIndex)
        : [];
    const ref = refSegments.reduce((acc, seg, index) => t.memberExpression(acc, t.identifier(index === 0 && rootSegment === "module"
        ? (0, utils_1.camelCase)(seg.segment + "Output")
        : (0, utils_1.camelCase)(seg.segment))), varIdentifier);
    if (nonRefSegments.length === 0) {
        return ref;
    }
    scope.importables.push({
        constructName: "Fn",
        provider: "cdktf",
    });
    const callee = t.memberExpression(t.identifier("Fn"), t.identifier("lookupNested"));
    return t.callExpression(callee, [
        ref,
        t.arrayExpression(nonRefSegments.map((s) => t.stringLiteral(s.segment))),
    ]);
}
function convertUnaryOpExpressionToTs(scope, node) {
    const operand = convertTFExpressionAstToTs(scope, hcl2json_2.TFExpressionSyntaxTree.getChildWithValue(node, node.meta.valueExpression));
    let fnName = node.meta.operator;
    if (tfUnaryOperatorsToCdktf[fnName]) {
        fnName = tfUnaryOperatorsToCdktf[fnName];
    }
    else {
        throw new Error(`Cannot convert unknown operator ${node.meta.operator}`);
    }
    scope.importables.push({
        constructName: "Op",
        provider: "cdktf",
    });
    const fn = t.memberExpression(t.identifier("Op"), t.identifier(fnName));
    return t.callExpression(fn, [operand]);
}
function convertBinaryOpExpressionToTs(scope, node) {
    const left = convertTFExpressionAstToTs(scope, hcl2json_2.TFExpressionSyntaxTree.getChildWithValue(node, node.meta.lhsExpression));
    const right = convertTFExpressionAstToTs(scope, hcl2json_2.TFExpressionSyntaxTree.getChildWithValue(node, node.meta.rhsExpression));
    let fnName = node.meta.operator;
    if (tfBinaryOperatorsToCdktf[fnName]) {
        fnName = tfBinaryOperatorsToCdktf[fnName];
    }
    else {
        throw new Error(`Cannot convert unknown operator ${node.meta.operator}`);
    }
    scope.importables.push({
        constructName: "Op",
        provider: "cdktf",
    });
    const fn = t.memberExpression(t.identifier("Op"), t.identifier(fnName));
    return t.callExpression(fn, [left, right]);
}
function convertTemplateExpressionToTs(scope, node) {
    const parts = node.children.map((child) => ({
        node: child,
        expr: convertTFExpressionAstToTs(scope, child),
    }));
    const lastPart = parts[parts.length - 1];
    if (t.isStringLiteral(lastPart.expr) && lastPart.expr.value === "\n") {
        // This is a bit of a hack, but the trailing newline we add due to
        // heredocs looks ugly and unnecessary in the generated code, so we
        // try to remove it
        parts.pop();
    }
    if (parts.length === 0) {
        return t.stringLiteral(node.meta.value);
    }
    if (parts.length === 1) {
        return parts[0].expr;
    }
    let isScopedTraversal = false;
    let expressions = [];
    for (const { node, expr } of parts) {
        if (hcl2json_2.TFExpressionSyntaxTree.isScopeTraversalExpression(node) &&
            !t.isStringLiteral(expr) &&
            !t.isCallExpression(expr)) {
            expressions.push(t.stringLiteral("${"));
            isScopedTraversal = true;
        }
        else if (
        // we should ideally be doing type coercion more
        // carefully here, because it may not always be needed
        t.isCallExpression(expr)) {
            scope.importables.push({
                constructName: "Token",
                provider: "cdktf",
            });
            expressions.push(template_1.default.expression(`Token.asString(%%expr%%)`)({
                expr,
            }));
            continue;
        }
        else {
            if (isScopedTraversal) {
                expressions.push(t.stringLiteral("}"));
                isScopedTraversal = false;
            }
        }
        expressions.push(expr);
    }
    if (isScopedTraversal) {
        expressions.push(t.stringLiteral("}"));
    }
    return expressionForSerialStringConcatenation(scope, expressions);
}
function convertObjectExpressionToTs(scope, node) {
    return t.objectExpression(Object.entries(node.meta.items)
        .map(([key, value]) => {
        const valueChild = (0, syntax_tree_1.getChildWithValue)(node, value);
        if (!valueChild) {
            utils_1.logger.error(`Unable to value for object key '${key}': ${value}`);
            return null;
        }
        return t.objectProperty(t.identifier(key), convertTFExpressionAstToTs(scope, valueChild));
    })
        .filter((s) => s !== null));
}
function convertFunctionCallExpressionToTs(scope, node) {
    const functionName = node.meta.name;
    const mapping = functions_1.functionsMap[functionName];
    if (!mapping) {
        utils_1.logger.error(`Unknown function ${functionName} encountered. ${utils_1.leaveCommentText}`);
        const argumentExpressions = node.children.map((child) => convertTFExpressionAstToTs(scope, child));
        return t.callExpression(t.identifier(functionName), argumentExpressions);
    }
    let transformedNode = mapping.transformer
        ? mapping.transformer(node)
        : node;
    const argumentExpressions = transformedNode.children.map((child) => convertTFExpressionAstToTs(scope, child));
    scope.importables.push({
        constructName: "Fn",
        provider: "cdktf",
    });
    const callee = t.memberExpression(t.identifier("Fn"), t.identifier(mapping.name));
    if (mapping.parameters.length > 0 &&
        mapping.parameters[mapping.parameters.length - 1].variadic) {
        const lastParameterType = mapping.parameters[mapping.parameters.length - 1].type;
        const nonVariadicArguments = argumentExpressions.slice(0, mapping.parameters.length - 1);
        const fnCallArguments = [
            ...nonVariadicArguments.map((argExpr, index) => (0, coerceType_1.coerceType)(scope, argExpr, (0, coerceType_1.findExpressionType)(scope, argExpr), mapping.parameters[index].type)),
            t.arrayExpression(argumentExpressions
                .slice(mapping.parameters.length - 1)
                .map((argExpr) => (0, coerceType_1.coerceType)(scope, argExpr, (0, coerceType_1.findExpressionType)(scope, argExpr), lastParameterType))),
        ];
        return t.callExpression(callee, fnCallArguments);
    }
    return t.callExpression(callee, argumentExpressions.map((argExpr, index) => (0, coerceType_1.coerceType)(scope, argExpr, (0, coerceType_1.findExpressionType)(scope, argExpr), mapping.parameters[index].type)));
}
function convertIndexExpressionToTs(scope, node) {
    const collectionExpressionChild = hcl2json_2.TFExpressionSyntaxTree.getChildWithValue(node, node.meta.collectionExpression);
    const keyExpressionChild = hcl2json_2.TFExpressionSyntaxTree.getChildWithValue(node, node.meta.keyExpression);
    const collectionExpression = convertTFExpressionAstToTs(scope, collectionExpressionChild);
    const keyExpression = convertTFExpressionAstToTs(scope, keyExpressionChild);
    scope.importables.push({
        constructName: "Fn",
        provider: "cdktf",
    });
    const callee = t.memberExpression(t.identifier("Fn"), t.identifier("lookupNested"));
    return t.callExpression(callee, [
        collectionExpression,
        t.arrayExpression([keyExpression]),
    ]);
}
function convertSplatExpressionToTs(scope, node) {
    const sourceExpressionChild = hcl2json_2.TFExpressionSyntaxTree.getChildWithValue(node, node.meta.sourceExpression);
    let sourceExpression = convertTFExpressionAstToTs(scope, sourceExpressionChild);
    // We don't convert the relative expression because everything after the splat is going to be
    // a string
    let relativeExpression = node.meta.eachExpression.startsWith(node.meta.anonSymbolExpression)
        ? node.meta.eachExpression.slice(node.meta.anonSymbolExpression.length)
        : node.meta.eachExpression;
    const segments = relativeExpression.split(/\.|\[|\]/).filter((s) => s);
    scope.importables.push({
        constructName: "Fn",
        provider: "cdktf",
    });
    const callee = t.memberExpression(t.identifier("Fn"), t.identifier("lookupNested"));
    return t.callExpression(callee, [
        sourceExpression,
        t.arrayExpression([
            // we don't need to use the anonSymbolExpression here because
            // it only changes between .* and [*] which we don't care about
            t.stringLiteral("*"),
            ...segments.map(t.stringLiteral),
        ]),
    ]);
}
function convertConditionalExpressionToTs(scope, node) {
    const conditionChild = hcl2json_2.TFExpressionSyntaxTree.getChildWithValue(node, node.meta.conditionExpression);
    let condition = convertTFExpressionAstToTs(scope, conditionChild);
    if (t.isIdentifier(condition) && canUseFqn(conditionChild)) {
        // We have a resource or data source here, which we would need to
        // reference using fqn
        condition = t.memberExpression(condition, t.identifier("fqn"));
    }
    const trueExpression = convertTFExpressionAstToTs(scope, hcl2json_2.TFExpressionSyntaxTree.getChildWithValue(node, node.meta.trueExpression));
    const falseExpression = convertTFExpressionAstToTs(scope, hcl2json_2.TFExpressionSyntaxTree.getChildWithValue(node, node.meta.falseExpression));
    scope.importables.push({
        constructName: "conditional",
        provider: "cdktf",
    });
    return t.callExpression(t.identifier("conditional"), [
        condition,
        trueExpression,
        falseExpression,
    ]);
}
function convertTupleExpressionToTs(scope, node) {
    const expressions = node.children.map((child) => convertTFExpressionAstToTs(scope, child));
    return t.arrayExpression(expressions);
}
function convertRelativeTraversalExpressionToTs(scope, node) {
    const segments = node.meta.traversal;
    // The left hand side / source of a relative traversal is not a proper
    // object / resource / data thing that is being referenced
    const source = convertTFExpressionAstToTs(scope, hcl2json_2.TFExpressionSyntaxTree.getChildWithValue(node, node.meta.sourceExpression));
    scope.importables.push({
        constructName: "Fn",
        provider: "cdktf",
    });
    const callee = t.memberExpression(t.identifier("Fn"), t.identifier("lookupNested"));
    return t.callExpression(callee, [
        source,
        t.arrayExpression(segments.map((s) => t.stringLiteral(s.segment))),
    ]);
}
function convertForExpressionToTs(scope, node) {
    const collectionChild = hcl2json_2.TFExpressionSyntaxTree.getChildWithValue(node, node.meta.collectionExpression);
    let collectionExpression = convertTFExpressionAstToTs(scope, collectionChild);
    if (t.isIdentifier(collectionExpression) && canUseFqn(collectionChild)) {
        // We have a resource or data source here, which we would need to
        // reference using fqn
        collectionExpression = t.memberExpression(collectionExpression, t.identifier("fqn"));
    }
    const collectionRequiresWrapping = !t.isStringLiteral(collectionExpression);
    const expressions = [];
    const conditionBody = node.meta.keyVar
        ? `${node.meta.keyVar}, ${node.meta.valVar}`
        : node.meta.valVar;
    const openBrace = node.meta.openRangeValue;
    const closeBrace = node.meta.closeRangeValue;
    const grouped = node.meta.groupedValue ? "..." : "";
    const valueExpression = `${node.meta.valueExpression}${grouped}`;
    const prefix = `\${${openBrace} for ${conditionBody} in `;
    const keyValue = node.meta.keyExpression
        ? ` : ${node.meta.keyExpression} => ${valueExpression}`
        : ` : ${valueExpression}`;
    const conditional = node.meta.conditionalExpression;
    const suffix = `${keyValue}${conditional ? ` if ${conditional}` : ""}${closeBrace}}`;
    expressions.push(t.stringLiteral(prefix));
    if (collectionRequiresWrapping) {
        expressions.push(t.stringLiteral("${"));
    }
    expressions.push(collectionExpression);
    if (collectionRequiresWrapping) {
        expressions.push(t.stringLiteral("}"));
    }
    expressions.push(t.stringLiteral(suffix));
    return expressionForSerialStringConcatenation(scope, expressions);
}
function convertTFExpressionAstToTs(scope, node) {
    if (hcl2json_2.TFExpressionSyntaxTree.isLiteralValueExpression(node)) {
        return convertLiteralValueExpressionToTs(scope, node);
    }
    if (hcl2json_2.TFExpressionSyntaxTree.isScopeTraversalExpression(node)) {
        return convertScopeTraversalExpressionToTs(scope, node);
    }
    if (hcl2json_2.TFExpressionSyntaxTree.isUnaryOpExpression(node)) {
        return convertUnaryOpExpressionToTs(scope, node);
    }
    if (hcl2json_2.TFExpressionSyntaxTree.isBinaryOpExpression(node)) {
        return convertBinaryOpExpressionToTs(scope, node);
    }
    if (hcl2json_2.TFExpressionSyntaxTree.isTemplateExpression(node) || hcl2json_2.TFExpressionSyntaxTree.isTemplateWrapExpression(node)) {
        return convertTemplateExpressionToTs(scope, node);
    }
    if (hcl2json_2.TFExpressionSyntaxTree.isObjectExpression(node)) {
        return convertObjectExpressionToTs(scope, node);
    }
    if (hcl2json_2.TFExpressionSyntaxTree.isFunctionCallExpression(node)) {
        return convertFunctionCallExpressionToTs(scope, node);
    }
    if (hcl2json_2.TFExpressionSyntaxTree.isIndexExpression(node)) {
        return convertIndexExpressionToTs(scope, node);
    }
    if (hcl2json_2.TFExpressionSyntaxTree.isSplatExpression(node)) {
        return convertSplatExpressionToTs(scope, node);
    }
    if (hcl2json_2.TFExpressionSyntaxTree.isConditionalExpression(node)) {
        return convertConditionalExpressionToTs(scope, node);
    }
    if (hcl2json_2.TFExpressionSyntaxTree.isTupleExpression(node)) {
        return convertTupleExpressionToTs(scope, node);
    }
    if (hcl2json_2.TFExpressionSyntaxTree.isRelativeTraversalExpression(node)) {
        return convertRelativeTraversalExpressionToTs(scope, node);
    }
    if (hcl2json_2.TFExpressionSyntaxTree.isForExpression(node)) {
        return convertForExpressionToTs(scope, node);
    }
    return t.stringLiteral("");
}
async function expressionAst(input) {
    const { wrap, wrapOffset } = (0, hcl2json_2.wrapTerraformExpression)(input);
    const ast = await (0, hcl2json_1.getExpressionAst)("main.tf", wrap);
    if (!ast) {
        throw new Error(`Unable to parse terraform expression: ${input}`);
    }
    if (wrapOffset != 0 && hcl2json_2.TFExpressionSyntaxTree.isTemplateWrapExpression(ast)) {
        return ast.children[0];
    }
    return ast;
}
exports.expressionAst = expressionAst;
async function convertTerraformExpressionToTs(scope, input, targetType) {
    utils_1.logger.debug(`convertTerraformExpressionToTs(${input})`);
    const tsExpression = convertTFExpressionAstToTs(scope, await expressionAst(input));
    return (0, coerceType_1.coerceType)(scope, tsExpression, (0, coerceType_1.findExpressionType)(scope, tsExpression), targetType());
}
exports.convertTerraformExpressionToTs = convertTerraformExpressionToTs;
async function extractIteratorVariablesFromExpression(input) {
    const possibleVariableSpots = await (0, hcl2json_1.getReferencesInExpression)("main.tf", input);
    return possibleVariableSpots
        .filter((spot) => spot.value.startsWith("each."))
        .map((spot) => ({
        start: spot.startPosition,
        end: spot.endPosition,
        value: spot.value,
    }));
}
exports.extractIteratorVariablesFromExpression = extractIteratorVariablesFromExpression;
function dynamicVariableToAst(scope, node, iteratorName, block = "each") {
    if (iteratorName === "dynamic-block") {
        return expressionForSerialStringConcatenation(scope, [
            t.stringLiteral("${"),
            t.stringLiteral(block),
            t.stringLiteral("}"),
        ]);
    }
    if (node.meta.value === `${block}.key`) {
        return t.memberExpression(t.identifier(iteratorName), t.identifier("key"));
    }
    if (node.meta.value === `${block}.value`) {
        return t.memberExpression(t.identifier(iteratorName), t.identifier("value"));
    }
    if (block === "count" && node.meta.value === `${block}.index`) {
        return t.memberExpression(t.identifier(iteratorName), t.identifier("index"));
    }
    const segments = node.meta.traversal;
    if (segments.length > 2 &&
        segments[0].segment === block &&
        segments[1].segment === "value") {
        const segmentsAfterEachValue = segments.slice(2);
        scope.importables.push({
            constructName: "Fn",
            provider: "cdktf",
        });
        const callee = t.memberExpression(t.identifier("Fn"), t.identifier("lookupNested"));
        return t.callExpression(callee, [
            t.memberExpression(t.identifier(iteratorName), t.identifier("value")),
            t.arrayExpression(segmentsAfterEachValue.map((part) => {
                if (part.type === "nameTraversal") {
                    return t.stringLiteral(part.segment);
                }
                else {
                    return t.stringLiteral(`[${part.segment}]`);
                }
            })),
        ]);
    }
    throw new Error(`Can not create AST for iterator variable of '${node.meta.value}'`);
}
exports.dynamicVariableToAst = dynamicVariableToAst;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwcmVzc2lvbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJleHByZXNzaW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMsZ0RBQWtDO0FBQ2xDLCtEQUF1QztBQUN2QyxtQ0FBOEQ7QUFNOUQsOENBQThFO0FBQzlFLDhDQUd5QjtBQUN6Qiw2REFBNkQ7QUFDN0QsNkNBQThEO0FBRTlELHVEQUFrRDtBQUNsRCw2Q0FBaUQ7QUFDakQsMkNBQTJDO0FBQzNDLGlFQUFvRTtBQUVwRSxNQUFNLHdCQUF3QixHQUFHO0lBQy9CLFNBQVMsRUFBRSxJQUFJO0lBQ2YsVUFBVSxFQUFFLEtBQUs7SUFDakIsV0FBVyxFQUFFLElBQUk7SUFDakIsa0JBQWtCLEVBQUUsS0FBSztJQUN6QixRQUFRLEVBQUUsSUFBSTtJQUNkLGVBQWUsRUFBRSxLQUFLO0lBQ3RCLEtBQUssRUFBRSxJQUFJO0lBQ1gsUUFBUSxFQUFFLEtBQUs7SUFDZixHQUFHLEVBQUUsS0FBSztJQUNWLFFBQVEsRUFBRSxLQUFLO0lBQ2YsUUFBUSxFQUFFLEtBQUs7SUFDZixNQUFNLEVBQUUsS0FBSztJQUNiLE1BQU0sRUFBRSxLQUFLO0NBQ2QsQ0FBQztBQUVGLE1BQU0sdUJBQXVCLEdBQUc7SUFDOUIsVUFBVSxFQUFFLEtBQUs7SUFDakIsTUFBTSxFQUFFLFFBQVE7Q0FDakIsQ0FBQztBQUtGLFNBQVMsc0JBQXNCLENBQzdCLFVBQXdDLEVBQ3hDLFFBQVEsR0FBRyxLQUFLO0lBRWhCLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNkLElBQUksUUFBUSxJQUFJLGlDQUFHLENBQUMsbUJBQW1CLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDdEQsSUFBSSxHQUFHLEdBQUcsQ0FBQztLQUNaO0lBQ0QsT0FBTyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsR0FB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Q0FBQyxPQUFPLENBQUMsQ0FBQztZQUNyRSxDQUFDLENBQUMsZUFBZSxDQUNmLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO2dCQUNsQyxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssZUFBZSxFQUFFO29CQUNqQyxPQUFPLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2lCQUN0QztxQkFBTTtvQkFDTCxPQUFPLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQztpQkFDN0M7WUFDSCxDQUFDLENBQUMsQ0FDSDtTQUNGLENBQUMsQ0FBQztLQUNKO0lBRUQsTUFBTSxJQUFJLEtBQUssQ0FDYixnREFBZ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FDbkUsQ0FBQztBQUNKLENBQUM7QUEvREQsb0RBK0RDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluY1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcbmltcG9ydCAqIGFzIHQgZnJvbSBcIkBiYWJlbC90eXBlc1wiO1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gXCJAYmFiZWwvdGVtcGxhdGVcIjtcbmltcG9ydCB7IGNhbWVsQ2FzZSwgbGVhdmVDb21tZW50VGV4dCwgbG9nZ2VyIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7XG4gIEl0ZXJhdG9yVmFyaWFibGVSZWZlcmVuY2UsXG4gIFByb2dyYW1TY29wZSxcbiAgUmVzb3VyY2VTY29wZSxcbn0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGdldFJlZmVyZW5jZXNJbkV4cHJlc3Npb24sIGdldEV4cHJlc3Npb25Bc3QgfSBmcm9tIFwiQGNka3RmL2hjbDJqc29uXCI7XG5pbXBvcnQge1xuICBURkV4cHJlc3Npb25TeW50YXhUcmVlIGFzIHRleCxcbiAgd3JhcFRlcnJhZm9ybUV4cHJlc3Npb24sXG59IGZyb20gXCJAY2RrdGYvaGNsMmpzb25cIjtcbmltcG9ydCB7IGZ1bmN0aW9uc01hcCB9IGZyb20gXCIuL2Z1bmN0aW9uLWJpbmRpbmdzL2Z1bmN0aW9uc1wiO1xuaW1wb3J0IHsgY29lcmNlVHlwZSwgZmluZEV4cHJlc3Npb25UeXBlIH0gZnJvbSBcIi4vY29lcmNlVHlwZVwiO1xuaW1wb3J0IHsgQXR0cmlidXRlVHlwZSB9IGZyb20gXCJAY2RrdGYvY29tbW9uc1wiO1xuaW1wb3J0IHsgZ2V0VHlwZUF0UGF0aCB9IGZyb20gXCIuL3RlcnJhZm9ybVNjaGVtYVwiO1xuaW1wb3J0IHsgY29udGFpbnNSZWZlcmVuY2UgfSBmcm9tIFwiLi9yZWZlcmVuY2VzXCI7XG5pbXBvcnQgeyB2YXJpYWJsZU5hbWUgfSBmcm9tIFwiLi92YXJpYWJsZXNcIjtcbmltcG9ydCB7IGdldENoaWxkV2l0aFZhbHVlIH0gZnJvbSBcIkBjZGt0Zi9oY2wyanNvbi9saWIvc3ludGF4LXRyZWVcIjtcblxuY29uc3QgdGZCaW5hcnlPcGVyYXRvcnNUb0Nka3RmID0ge1xuICBsb2dpY2FsT3I6IFwib3JcIixcbiAgbG9naWNhbEFuZDogXCJhbmRcIixcbiAgZ3JlYXRlclRoYW46IFwiZ3RcIixcbiAgZ3JlYXRlclRoYW5PckVxdWFsOiBcImd0ZVwiLFxuICBsZXNzVGhhbjogXCJsdFwiLFxuICBsZXNzVGhhbk9yRXF1YWw6IFwibHRlXCIsXG4gIGVxdWFsOiBcImVxXCIsXG4gIG5vdEVxdWFsOiBcIm5lcVwiLFxuICBhZGQ6IFwiYWRkXCIsXG4gIHN1YnRyYWN0OiBcInN1YlwiLFxuICBtdWx0aXBseTogXCJtdWxcIixcbiAgZGl2aWRlOiBcImRpdlwiLFxuICBtb2R1bG86IFwibW9kXCIsXG59O1xuXG5jb25zdCB0ZlVuYXJ5T3BlcmF0b3JzVG9DZGt0ZiA9IHtcbiAgbG9naWNhbE5vdDogXCJub3RcIixcbiAgbmVnYXRlOiBcIm5lZ2F0ZVwiLFxufTtcblxudHlwZSBzdXBwb3J0ZWRCaW5hcnlPcGVyYXRvcnMgPSBrZXlvZiB0eXBlb2YgdGZCaW5hcnlPcGVyYXRvcnNUb0Nka3RmO1xudHlwZSBzdXBwb3J0ZWRVbmFyeU9wZXJhdG9ycyA9IGtleW9mIHR5cGVvZiB0ZlVuYXJ5T3BlcmF0b3JzVG9DZGt0ZjtcblxuZnVuY3Rpb24gdHJhdmVyc2FsUGFydHNUb1N0cmluZyhcbiAgdHJhdmVyc2FsczogdGV4LlRlcnJhZm9ybVRyYXZlcnNhbFBhcnRbXSxcbiAgYXNTdWZmaXggPSBmYWxzZVxuKSB7XG4gIGxldCBzZWVkID0gXCJcIjtcbiAgaWYgKGFzU3VmZml4ICYmIHRleC5pc05hbWVUcmF2ZXJzYWxQYXJ0KHRyYXZlcnNhbHNbMF0pKSB7XG4gICAgc2VlZCA9IFwiLlwiO1xuICB9XG4gIHJldHVybiB0cmF2ZXJzYWxzLnJlZHVjZSgoYWNjLCBwYXJ0KSA9PiB7XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gXCJuYW1lVHJhdmVyc2FsXCIpIHtcbiAgICAgIGlmIChhY2MgPT09IHNlZWQpIHtcbiAgICAgICAgcmV0dXJuIGAke2FjY30ke3BhcnQuc2VnbWVudH1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGAke2FjY30uJHtwYXJ0LnNlZ21lbnR9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke2FjY31bJHtwYXJ0LnNlZ21lbnR9XWA7XG4gIH0sIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjYW5Vc2VGcW4oZXhwcmVzc2lvbjogdGV4LkV4cHJlc3Npb25UeXBlKSB7XG4gIGlmICghdGV4LmlzU2NvcGVUcmF2ZXJzYWxFeHByZXNzaW9uKGV4cHJlc3Npb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgcm9vdFNlZ21lbnQgPSBleHByZXNzaW9uLm1ldGEudHJhdmVyc2FsWzBdLnNlZ21lbnQ7XG5cbiAgcmV0dXJuICFbXCJ2YXJcIiwgXCJsb2NhbFwiXS5pbmNsdWRlcyhyb290U2VnbWVudCk7XG59XG5cbmZ1bmN0aW9uIHRyYXZlcnNhbFRvVmFyaWFibGVOYW1lKFxuICBzY29wZTogUHJvZ3JhbVNjb3BlLFxuICBub2RlOiB0ZXguRXhwcmVzc2lvblR5cGVcbikge1xuICBpZiAoIXRleC5pc1Njb3BlVHJhdmVyc2FsRXhwcmVzc2lvbihub2RlKSkge1xuICAgIGxvZ2dlci5lcnJvcihcbiAgICAgIGBVbmV4cGVjdGVkIGV4cHJlc3Npb24gdHlwZSAke25vZGUudHlwZX0gd2l0aCB2YWx1ZSAke25vZGUubWV0YS52YWx1ZX0gcGFzc2VkIHRvIGNvbnZlcnQgdG8gYSB2YXJpYWJsZS4gXG4gICAgICAgICR7bGVhdmVDb21tZW50VGV4dH1gXG4gICAgKTtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIGNvbnN0IHNlZ21lbnRzID0gbm9kZS5tZXRhLnRyYXZlcnNhbDtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBub2RlLm1ldGEuZnVsbEFjY2Vzc29yO1xuICB9XG4gIGNvbnN0IHJvb3RTZWdtZW50ID0gc2VnbWVudHNbMF0uc2VnbWVudDtcbiAgY29uc3QgcmVzb3VyY2UgPVxuICAgIHJvb3RTZWdtZW50ID09PSBcImRhdGFcIlxuICAgICAgPyBgJHtzZWdtZW50c1swXS5zZWdtZW50fS4ke3NlZ21lbnRzWzFdLnNlZ21lbnR9YFxuICAgICAgOiByb290U2VnbWVudDtcbiAgY29uc3QgbmFtZSA9XG4gICAgcm9vdFNlZ21lbnQgPT09IFwiZGF0YVwiID8gc2VnbWVudHNbMl0uc2VnbWVudCA6IHNlZ21lbnRzWzFdLnNlZ21lbnQ7XG5cbiAgcmV0dXJuIHZhcmlhYmxlTmFtZShzY29wZSwgcmVzb3VyY2UsIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBleHByZXNzaW9uRm9yU2VyaWFsU3RyaW5nQ29uY2F0ZW5hdGlvbihcbiAgc2NvcGU6IFJlc291cmNlU2NvcGUsXG4gIG5vZGVzOiB0LkV4cHJlc3Npb25bXVxuKSB7XG4gIGNvbnN0IHJlZHVjZWROb2RlcyA9IG5vZGVzLnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG4gICAgY29uc3QgcHJldiA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFwcmV2KSByZXR1cm4gW25vZGVdO1xuXG4gICAgaWYgKHQuaXNTdHJpbmdMaXRlcmFsKHByZXYpICYmIHQuaXNTdHJpbmdMaXRlcmFsKG5vZGUpKSB7XG4gICAgICBhY2MucG9wKCk7XG4gICAgICBhY2MucHVzaCh0LnN0cmluZ0xpdGVyYWwocHJldi52YWx1ZSArIG5vZGUudmFsdWUpKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuXG4gICAgYWNjLnB1c2gobm9kZSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgW10gYXMgdC5FeHByZXNzaW9uW10pO1xuXG4gIHJldHVybiByZWR1Y2VkTm9kZXMucmVkdWNlKFxuICAgIChhY2M6IHQuRXhwcmVzc2lvbiB8IHVuZGVmaW5lZCwgbm9kZTogdC5FeHByZXNzaW9uKSA9PiB7XG4gICAgICBpZiAoIWFjYykge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgLy8gd3JhcCBhY2Nlc3MgdG8gZHluYW1pYyBibG9ja3MgaW4gVG9rZW4uYXNTdHJpbmcoKSBhcyB0aGV5IHJldHVybiBhIExhenlcbiAgICAgIC8vIGZvciAua2V5IGFuZCAudmFsdWUgd2hpY2ggY2FuJ3QgYmUgY29uY2F0ZW5hdGVkIGluIGxhbmd1YWdlcyBsaWtlIFB5dGhvblxuICAgICAgLy8gYmVjYXVzZSBKU0lJIGN1cnJlbnRseSBoYXMgbm8gc3VwcG9ydCBmb3IgdGhlIHRvU3RyaW5nKCkgbWV0aG9kIGluXG4gICAgICAvLyBsYW5ndWFnZXMgb3RoZXIgdGhhbiBUeXBlU2NyaXB0OiBodHRwczovL2dpdGh1Yi5jb20vYXdzL2pzaWkvaXNzdWVzLzM4MFxuICAgICAgLy8gZXhhbXBsZTogZHluYW1pY19pdGVyYXRvcjAua2V5IC8gZHluYW1pY19pdGVyYXRvcjAudmFsdWVcbiAgICAgIGlmIChcbiAgICAgICAgdC5pc01lbWJlckV4cHJlc3Npb24obm9kZSkgJiZcbiAgICAgICAgdC5pc0lkZW50aWZpZXIobm9kZS5vYmplY3QpICYmXG4gICAgICAgIE9iamVjdC52YWx1ZXMoc2NvcGUuc2NvcGVkVmFyaWFibGVzIHx8IHt9KS5pbmNsdWRlcyhub2RlLm9iamVjdC5uYW1lKSAmJlxuICAgICAgICB0LmlzSWRlbnRpZmllcihub2RlLnByb3BlcnR5KSAmJlxuICAgICAgICBbXCJrZXlcIiwgXCJ2YWx1ZVwiXS5pbmNsdWRlcyhub2RlLnByb3BlcnR5Lm5hbWUpXG4gICAgICApIHtcbiAgICAgICAgbm9kZSA9IGNvZXJjZVR5cGUoc2NvcGUsIG5vZGUsIFwiZHluYW1pY1wiLCBcInN0cmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQuYmluYXJ5RXhwcmVzc2lvbihcIitcIiwgYWNjIGFzIHQuRXhwcmVzc2lvbiwgbm9kZSk7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRUZlJlc291cmNlUGF0aEZyb21Ob2RlKG5vZGU6IHRleC5TY29wZVRyYXZlcnNhbEV4cHJlc3Npb24pIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBub2RlLm1ldGEudHJhdmVyc2FsO1xuICBsZXQgcmVzb3VyY2UgPSBzZWdtZW50c1swXS5zZWdtZW50O1xuICBsZXQgcmVzdWx0ID0gW107XG4gIGxldCBhdHRyaWJ1dGVzID0gW107XG5cbiAgaWYgKHNlZ21lbnRzWzBdLnNlZ21lbnQgPT09IFwiZGF0YVwiKSB7XG4gICAgcmVzdWx0LnB1c2goc2VnbWVudHNbMF0uc2VnbWVudCk7XG4gICAgcmVzb3VyY2UgPSBzZWdtZW50c1sxXS5zZWdtZW50O1xuICAgIGF0dHJpYnV0ZXMgPSBzZWdtZW50cy5zbGljZSgzKTsgLy8gd2Ugd2FudCB0byBza2lwIHRoZSB2YXJpYWJsZSBuYW1lXG4gIH0gZWxzZSB7XG4gICAgYXR0cmlidXRlcyA9IHNlZ21lbnRzLnNsaWNlKDIpOyAvLyB3ZSB3YW50IHRvIHNraXAgdGhlIHZhcmlhYmxlIG5hbWVcbiAgfVxuXG4gIGNvbnN0IFtwcm92aWRlciwgLi4ucmVzb3VyY2VOYW1lRnJhZ21lbnRzXSA9IHJlc291cmNlLnNwbGl0KFwiX1wiKTtcblxuICAvLyBIYWNrOiBUaGlzIGhhcHBlbnMgaW4gdGhlIGNhc2Ugb2YgYGV4dGVybmFsYCBwcm92aWRlclxuICAvLyB3aGVyZSB0aGUgZGF0YSBzb3VyY2UgZG9lcyBub3QgaGF2ZSBhIHByb3ZpZGVyIG5hbWUgcHJlZml4XG4gIGlmIChyZXNvdXJjZU5hbWVGcmFnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmVzb3VyY2VOYW1lRnJhZ21lbnRzLnB1c2gocHJvdmlkZXIpO1xuICB9XG5cbiAgcmVzdWx0LnB1c2gocHJvdmlkZXIpO1xuICByZXN1bHQucHVzaChyZXNvdXJjZU5hbWVGcmFnbWVudHMuam9pbihcIl9cIikpO1xuICByZXN1bHQgPSBbXG4gICAgLi4ucmVzdWx0LFxuICAgIC4uLmF0dHJpYnV0ZXMubWFwKChzZWcpID0+IHtcbiAgICAgIGlmICh0ZXguaXNJbmRleFRyYXZlcnNhbFBhcnQoc2VnKSkge1xuICAgICAgICByZXR1cm4gYFske3NlZy5zZWdtZW50fV1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlZy5zZWdtZW50O1xuICAgIH0pLFxuICBdO1xuXG4gIHJldHVybiByZXN1bHQuam9pbihcIi5cIik7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRMaXRlcmFsVmFsdWVFeHByZXNzaW9uVG9UcyhcbiAgX3Njb3BlOiBSZXNvdXJjZVNjb3BlLFxuICBub2RlOiB0ZXguTGl0ZXJhbFZhbHVlRXhwcmVzc2lvblxuKSB7XG4gIGNvbnN0IGxpdGVyYWxUeXBlID0gbm9kZS5tZXRhLnR5cGU7XG4gIGlmIChsaXRlcmFsVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB0Lm51bWVyaWNMaXRlcmFsKE51bWJlcihub2RlLm1ldGEudmFsdWUpKTtcbiAgfVxuICBpZiAobGl0ZXJhbFR5cGUgPT09IFwiYm9vbFwiKSB7XG4gICAgcmV0dXJuIHQuYm9vbGVhbkxpdGVyYWwobm9kZS5tZXRhLnZhbHVlID09PSBcInRydWVcIiA/IHRydWUgOiBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gdC5zdHJpbmdMaXRlcmFsKG5vZGUubWV0YS52YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRTY29wZVRyYXZlcnNhbEV4cHJlc3Npb25Ub1RzKFxuICBzY29wZTogUmVzb3VyY2VTY29wZSxcbiAgbm9kZTogdGV4LlNjb3BlVHJhdmVyc2FsRXhwcmVzc2lvblxuKSB7XG4gIGNvbnN0IGhhc1JlZmVyZW5jZSA9IGNvbnRhaW5zUmVmZXJlbmNlKG5vZGUpO1xuXG4gIGNvbnN0IHNlZ21lbnRzID0gbm9kZS5tZXRhLnRyYXZlcnNhbDtcblxuICBpZiAoc2VnbWVudHNbMF0uc2VnbWVudCA9PT0gXCJlYWNoXCIgJiYgc2NvcGUuZm9yRWFjaEl0ZXJhdG9yTmFtZSkge1xuICAgIHJldHVybiBkeW5hbWljVmFyaWFibGVUb0FzdChzY29wZSwgbm9kZSwgc2NvcGUuZm9yRWFjaEl0ZXJhdG9yTmFtZSk7XG4gIH1cblxuICBpZiAoc2VnbWVudHNbMF0uc2VnbWVudCA9PT0gXCJjb3VudFwiICYmIHNjb3BlLmNvdW50SXRlcmF0b3JOYW1lKSB7XG4gICAgcmV0dXJuIGR5bmFtaWNWYXJpYWJsZVRvQXN0KHNjb3BlLCBub2RlLCBzY29wZS5jb3VudEl0ZXJhdG9yTmFtZSwgXCJjb3VudFwiKTtcbiAgfVxuXG4gIGlmIChzZWdtZW50c1swXS5zZWdtZW50ID09PSBcInNlbGZcIikge1xuICAgIHNjb3BlLmltcG9ydGFibGVzLnB1c2goe1xuICAgICAgY29uc3RydWN0TmFtZTogXCJUZXJyYWZvcm1TZWxmXCIsXG4gICAgICBwcm92aWRlcjogXCJjZGt0ZlwiLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICB0Lm1lbWJlckV4cHJlc3Npb24odC5pZGVudGlmaWVyKFwiVGVycmFmb3JtU2VsZlwiKSwgdC5pZGVudGlmaWVyKFwiZ2V0QW55XCIpKSxcblxuICAgICAgW3Quc3RyaW5nTGl0ZXJhbCh0cmF2ZXJzYWxQYXJ0c1RvU3RyaW5nKHNlZ21lbnRzLnNsaWNlKDEpKSldXG4gICAgKTtcbiAgfVxuXG4gIC8vIHNldHRpbmcudmFsdWUsIHNldHRpbmcudmFsdWVbMV0uaWRcbiAgY29uc3QgZHluYW1pY0Jsb2NrID0gc2NvcGUuc2NvcGVkVmFyaWFibGVzPy5bc2VnbWVudHNbMF0uc2VnbWVudF07XG4gIGlmIChkeW5hbWljQmxvY2spIHtcbiAgICBpZiAoZHluYW1pY0Jsb2NrID09PSBcImR5bmFtaWMtYmxvY2tcIikge1xuICAgICAgcmV0dXJuIGR5bmFtaWNWYXJpYWJsZVRvQXN0KFxuICAgICAgICBzY29wZSxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgZHluYW1pY0Jsb2NrLFxuICAgICAgICB0cmF2ZXJzYWxQYXJ0c1RvU3RyaW5nKHNlZ21lbnRzKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGR5bmFtaWNWYXJpYWJsZVRvQXN0KHNjb3BlLCBub2RlLCBkeW5hbWljQmxvY2ssIHNlZ21lbnRzWzBdLnNlZ21lbnQpO1xuICB9XG5cbiAgLy8gVGhpcyBtYXkgYmUgYSB2YXJpYWJsZSByZWZlcmVuY2UgdGhhdCB3ZSBkb24ndCB1bmRlcnN0YW5kIHlldCwgc28gd2Ugd3JhcCBpdCBpbiBhIHRlbXBsYXRlIHN0cmluZ1xuICAvLyBmb3IgVGVycmFmb3JtIHRvIGhhbmRsZVxuICBsZXQgdmFySWRlbnRpZmllcjogdC5FeHByZXNzaW9uID0gdC5zdHJpbmdMaXRlcmFsKFxuICAgIGBcXCR7JHtub2RlLm1ldGEuZnVsbEFjY2Vzc29yfX1gXG4gICk7XG5cbiAgaWYgKGhhc1JlZmVyZW5jZSkge1xuICAgIHZhcklkZW50aWZpZXIgPSB0LmlkZW50aWZpZXIoXG4gICAgICBjYW1lbENhc2UodHJhdmVyc2FsVG9WYXJpYWJsZU5hbWUoc2NvcGUsIG5vZGUpKVxuICAgICk7XG4gIH1cblxuICBpZiAoW1widmFyXCIsIFwibG9jYWxcIl0uaW5jbHVkZXMoc2VnbWVudHNbMF0uc2VnbWVudCkpIHtcbiAgICBjb25zdCB2YXJpYWJsZUFjY2Vzc29yID1cbiAgICAgIHNlZ21lbnRzWzBdLnNlZ21lbnQgPT09IFwidmFyXCJcbiAgICAgICAgPyB0Lm1lbWJlckV4cHJlc3Npb24odmFySWRlbnRpZmllciwgdC5pZGVudGlmaWVyKFwidmFsdWVcIikpXG4gICAgICAgIDogdmFySWRlbnRpZmllcjtcblxuICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBzY29wZS5pbXBvcnRhYmxlcy5wdXNoKHtcbiAgICAgICAgY29uc3RydWN0TmFtZTogXCJGblwiLFxuICAgICAgICBwcm92aWRlcjogXCJjZGt0ZlwiLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBjYWxsZWUgPSB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgIHQuaWRlbnRpZmllcihcIkZuXCIpLFxuICAgICAgICB0LmlkZW50aWZpZXIoXCJsb29rdXBOZXN0ZWRcIilcbiAgICAgICk7XG4gICAgICByZXR1cm4gdC5jYWxsRXhwcmVzc2lvbihjYWxsZWUsIFtcbiAgICAgICAgdmFyaWFibGVBY2Nlc3NvcixcbiAgICAgICAgdC5hcnJheUV4cHJlc3Npb24oXG4gICAgICAgICAgc2VnbWVudHMuc2xpY2UoMikubWFwKChzKSA9PiB0LnN0cmluZ0xpdGVyYWwocy5zZWdtZW50KSlcbiAgICAgICAgKSxcbiAgICAgIF0pO1xuICAgIH1cblxuICAgIHJldHVybiB2YXJpYWJsZUFjY2Vzc29yO1xuICB9XG5cbiAgaWYgKCFoYXNSZWZlcmVuY2UgfHwgc2NvcGUud2l0aGluT3ZlcnJpZGVFeHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIHZhcklkZW50aWZpZXI7XG4gIH1cblxuICBjb25zdCByb290U2VnbWVudCA9IHNlZ21lbnRzWzBdLnNlZ21lbnQ7XG4gIGNvbnN0IGF0dHJpYnV0ZUluZGV4ID0gcm9vdFNlZ21lbnQgPT09IFwiZGF0YVwiID8gMyA6IDI7XG4gIGNvbnN0IGF0dHJpYnV0ZVNlZ21lbnRzID0gc2VnbWVudHMuc2xpY2UoYXR0cmlidXRlSW5kZXgpO1xuICBjb25zdCBudW1lcmljQWNjZXNzb3JJbmRleCA9IGF0dHJpYnV0ZVNlZ21lbnRzLmZpbmRJbmRleCgoc2VnKSA9PlxuICAgIHRleC5pc0luZGV4VHJhdmVyc2FsUGFydChzZWcpXG4gICk7XG4gIGxldCBtaW5BY2Nlc3NvckluZGV4ID0gbnVtZXJpY0FjY2Vzc29ySW5kZXg7XG4gIGxldCBtYXBBY2Nlc3NvckluZGV4ID0gLTE7XG4gIGlmIChudW1lcmljQWNjZXNzb3JJbmRleCA9PT0gLTEpIHtcbiAgICAvLyBvbmx5IGRvIHRoaXMgaWYgd2UgaGF2ZSB0bywgaWYgd2UgYWxyZWFkeSBoYXZlIGFcbiAgICAvLyBudW1lcmljIGFjY2Vzc29yLCB3ZSBkb24ndCBoYXZlIHRvIGRvIHRoaXMgYWRkaXRpb25hbCB3b3JrXG4gICAgY29uc3QgcmVzb3VyY2VQYXRoID0gZ2V0VGZSZXNvdXJjZVBhdGhGcm9tTm9kZShub2RlKTtcbiAgICBsZXQgdXNpbmdTdWJQYXRoVHlwZSA9IGZhbHNlO1xuICAgIGxldCBwYXJ0cyA9IHJlc291cmNlUGF0aC5zcGxpdChcIi5cIikuZmlsdGVyKChwKSA9PiBwICE9PSBcIlwiKTtcbiAgICBjb25zdCBtaW5QYXJ0cyA9IGF0dHJpYnV0ZUluZGV4OyAvLyB3ZSBuZWVkIHRvIHN0b3AgYmVmb3JlIGRhdGEuYXdzLnJlc291cmNlX25hbWUgb3IgYXdzLnJlc291cmNlX25hbWVcbiAgICBjb25zdCBvcmlnaW5hbFBhcnRzID0gcGFydHMubGVuZ3RoO1xuICAgIGxldCBoYXNNYXBBY2Nlc3NvciA9IGZhbHNlO1xuICAgIHdoaWxlIChwYXJ0cy5sZW5ndGggPj0gbWluUGFydHMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlQXRQYXRoKHNjb3BlLnByb3ZpZGVyU2NoZW1hLCBwYXJ0cy5qb2luKFwiLlwiKSk7XG4gICAgICBpZiAodHlwZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSAmJiB0eXBlWzBdID09PSBcIm1hcFwiICYmIHVzaW5nU3ViUGF0aFR5cGUpIHtcbiAgICAgICAgICBoYXNNYXBBY2Nlc3NvciA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgdXNpbmdTdWJQYXRoVHlwZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGhhc01hcEFjY2Vzc29yKSB7XG4gICAgICBtYXBBY2Nlc3NvckluZGV4ID0gb3JpZ2luYWxQYXJ0cyAtIHBhcnRzLmxlbmd0aCAtIDE7XG4gICAgICBtaW5BY2Nlc3NvckluZGV4ID0gbWFwQWNjZXNzb3JJbmRleDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBuZWVkc1Byb3BlcnR5QWNjZXNzID0gbWluQWNjZXNzb3JJbmRleCA+PSAwO1xuXG4gIGNvbnN0IHJlZlNlZ21lbnRzID0gbmVlZHNQcm9wZXJ0eUFjY2Vzc1xuICAgID8gYXR0cmlidXRlU2VnbWVudHMuc2xpY2UoMCwgbWluQWNjZXNzb3JJbmRleClcbiAgICA6IGF0dHJpYnV0ZVNlZ21lbnRzO1xuICBjb25zdCBub25SZWZTZWdtZW50cyA9IG5lZWRzUHJvcGVydHlBY2Nlc3NcbiAgICA/IGF0dHJpYnV0ZVNlZ21lbnRzLnNsaWNlKG1pbkFjY2Vzc29ySW5kZXgpXG4gICAgOiBbXTtcblxuICBjb25zdCByZWYgPSByZWZTZWdtZW50cy5yZWR1Y2UoXG4gICAgKGFjYzogdC5FeHByZXNzaW9uLCBzZWcsIGluZGV4KSA9PlxuICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICBhY2MsXG4gICAgICAgIHQuaWRlbnRpZmllcihcbiAgICAgICAgICBpbmRleCA9PT0gMCAmJiByb290U2VnbWVudCA9PT0gXCJtb2R1bGVcIlxuICAgICAgICAgICAgPyBjYW1lbENhc2Uoc2VnLnNlZ21lbnQgKyBcIk91dHB1dFwiKVxuICAgICAgICAgICAgOiBjYW1lbENhc2Uoc2VnLnNlZ21lbnQpXG4gICAgICAgIClcbiAgICAgICksXG4gICAgdmFySWRlbnRpZmllclxuICApO1xuXG4gIGlmIChub25SZWZTZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcmVmO1xuICB9XG5cbiAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgY29uc3RydWN0TmFtZTogXCJGblwiLFxuICAgIHByb3ZpZGVyOiBcImNka3RmXCIsXG4gIH0pO1xuICBjb25zdCBjYWxsZWUgPSB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgdC5pZGVudGlmaWVyKFwiRm5cIiksXG4gICAgdC5pZGVudGlmaWVyKFwibG9va3VwTmVzdGVkXCIpXG4gICk7XG4gIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKGNhbGxlZSwgW1xuICAgIHJlZixcbiAgICB0LmFycmF5RXhwcmVzc2lvbihub25SZWZTZWdtZW50cy5tYXAoKHMpID0+IHQuc3RyaW5nTGl0ZXJhbChzLnNlZ21lbnQpKSksXG4gIF0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VW5hcnlPcEV4cHJlc3Npb25Ub1RzKFxuICBzY29wZTogUmVzb3VyY2VTY29wZSxcbiAgbm9kZTogdGV4LlVuYXJ5T3BFeHByZXNzaW9uXG4pIHtcbiAgY29uc3Qgb3BlcmFuZCA9IGNvbnZlcnRURkV4cHJlc3Npb25Bc3RUb1RzKFxuICAgIHNjb3BlLFxuICAgIHRleC5nZXRDaGlsZFdpdGhWYWx1ZShub2RlLCBub2RlLm1ldGEudmFsdWVFeHByZXNzaW9uKSFcbiAgKTtcblxuICBsZXQgZm5OYW1lID0gbm9kZS5tZXRhLm9wZXJhdG9yO1xuICBpZiAodGZVbmFyeU9wZXJhdG9yc1RvQ2RrdGZbZm5OYW1lIGFzIHN1cHBvcnRlZFVuYXJ5T3BlcmF0b3JzXSkge1xuICAgIGZuTmFtZSA9IHRmVW5hcnlPcGVyYXRvcnNUb0Nka3RmW2ZuTmFtZSBhcyBzdXBwb3J0ZWRVbmFyeU9wZXJhdG9yc107XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29udmVydCB1bmtub3duIG9wZXJhdG9yICR7bm9kZS5tZXRhLm9wZXJhdG9yfWApO1xuICB9XG5cbiAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgY29uc3RydWN0TmFtZTogXCJPcFwiLFxuICAgIHByb3ZpZGVyOiBcImNka3RmXCIsXG4gIH0pO1xuXG4gIGNvbnN0IGZuID0gdC5tZW1iZXJFeHByZXNzaW9uKHQuaWRlbnRpZmllcihcIk9wXCIpLCB0LmlkZW50aWZpZXIoZm5OYW1lKSk7XG5cbiAgcmV0dXJuIHQuY2FsbEV4cHJlc3Npb24oZm4sIFtvcGVyYW5kXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRCaW5hcnlPcEV4cHJlc3Npb25Ub1RzKFxuICBzY29wZTogUmVzb3VyY2VTY29wZSxcbiAgbm9kZTogdGV4LkJpbmFyeU9wRXhwcmVzc2lvblxuKSB7XG4gIGNvbnN0IGxlZnQgPSBjb252ZXJ0VEZFeHByZXNzaW9uQXN0VG9UcyhcbiAgICBzY29wZSxcbiAgICB0ZXguZ2V0Q2hpbGRXaXRoVmFsdWUobm9kZSwgbm9kZS5tZXRhLmxoc0V4cHJlc3Npb24pIVxuICApO1xuICBjb25zdCByaWdodCA9IGNvbnZlcnRURkV4cHJlc3Npb25Bc3RUb1RzKFxuICAgIHNjb3BlLFxuICAgIHRleC5nZXRDaGlsZFdpdGhWYWx1ZShub2RlLCBub2RlLm1ldGEucmhzRXhwcmVzc2lvbikhXG4gICk7XG5cbiAgbGV0IGZuTmFtZSA9IG5vZGUubWV0YS5vcGVyYXRvcjtcbiAgaWYgKHRmQmluYXJ5T3BlcmF0b3JzVG9DZGt0Zltmbk5hbWUgYXMgc3VwcG9ydGVkQmluYXJ5T3BlcmF0b3JzXSkge1xuICAgIGZuTmFtZSA9IHRmQmluYXJ5T3BlcmF0b3JzVG9DZGt0Zltmbk5hbWUgYXMgc3VwcG9ydGVkQmluYXJ5T3BlcmF0b3JzXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb252ZXJ0IHVua25vd24gb3BlcmF0b3IgJHtub2RlLm1ldGEub3BlcmF0b3J9YCk7XG4gIH1cblxuICBzY29wZS5pbXBvcnRhYmxlcy5wdXNoKHtcbiAgICBjb25zdHJ1Y3ROYW1lOiBcIk9wXCIsXG4gICAgcHJvdmlkZXI6IFwiY2RrdGZcIixcbiAgfSk7XG5cbiAgY29uc3QgZm4gPSB0Lm1lbWJlckV4cHJlc3Npb24odC5pZGVudGlmaWVyKFwiT3BcIiksIHQuaWRlbnRpZmllcihmbk5hbWUpKTtcbiAgcmV0dXJuIHQuY2FsbEV4cHJlc3Npb24oZm4sIFtsZWZ0LCByaWdodF0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VGVtcGxhdGVFeHByZXNzaW9uVG9UcyhcbiAgc2NvcGU6IFJlc291cmNlU2NvcGUsXG4gIG5vZGU6IHRleC5UZW1wbGF0ZUV4cHJlc3Npb24gfCB0ZXguVGVtcGxhdGVXcmFwRXhwcmVzc2lvblxuKSB7XG4gIGNvbnN0IHBhcnRzID0gbm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiAoe1xuICAgIG5vZGU6IGNoaWxkLFxuICAgIGV4cHI6IGNvbnZlcnRURkV4cHJlc3Npb25Bc3RUb1RzKHNjb3BlLCBjaGlsZCksXG4gIH0pKTtcblxuICBjb25zdCBsYXN0UGFydCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICBpZiAodC5pc1N0cmluZ0xpdGVyYWwobGFzdFBhcnQuZXhwcikgJiYgbGFzdFBhcnQuZXhwci52YWx1ZSA9PT0gXCJcXG5cIikge1xuICAgIC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLCBidXQgdGhlIHRyYWlsaW5nIG5ld2xpbmUgd2UgYWRkIGR1ZSB0b1xuICAgIC8vIGhlcmVkb2NzIGxvb2tzIHVnbHkgYW5kIHVubmVjZXNzYXJ5IGluIHRoZSBnZW5lcmF0ZWQgY29kZSwgc28gd2VcbiAgICAvLyB0cnkgdG8gcmVtb3ZlIGl0XG4gICAgcGFydHMucG9wKCk7XG4gIH1cblxuICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHQuc3RyaW5nTGl0ZXJhbChub2RlLm1ldGEudmFsdWUpO1xuICB9XG5cbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBwYXJ0c1swXS5leHByO1xuICB9XG5cbiAgbGV0IGlzU2NvcGVkVHJhdmVyc2FsID0gZmFsc2U7XG4gIGxldCBleHByZXNzaW9uczogdC5FeHByZXNzaW9uW10gPSBbXTtcbiAgZm9yIChjb25zdCB7IG5vZGUsIGV4cHIgfSBvZiBwYXJ0cykge1xuICAgIGlmIChcbiAgICAgIHRleC5pc1Njb3BlVHJhdmVyc2FsRXhwcmVzc2lvbihub2RlKSAmJlxuICAgICAgIXQuaXNTdHJpbmdMaXRlcmFsKGV4cHIpICYmXG4gICAgICAhdC5pc0NhbGxFeHByZXNzaW9uKGV4cHIpXG4gICAgKSB7XG4gICAgICBleHByZXNzaW9ucy5wdXNoKHQuc3RyaW5nTGl0ZXJhbChcIiR7XCIpKTtcbiAgICAgIGlzU2NvcGVkVHJhdmVyc2FsID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gd2Ugc2hvdWxkIGlkZWFsbHkgYmUgZG9pbmcgdHlwZSBjb2VyY2lvbiBtb3JlXG4gICAgICAvLyBjYXJlZnVsbHkgaGVyZSwgYmVjYXVzZSBpdCBtYXkgbm90IGFsd2F5cyBiZSBuZWVkZWRcbiAgICAgIHQuaXNDYWxsRXhwcmVzc2lvbihleHByKVxuICAgICkge1xuICAgICAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgICAgIGNvbnN0cnVjdE5hbWU6IFwiVG9rZW5cIixcbiAgICAgICAgcHJvdmlkZXI6IFwiY2RrdGZcIixcbiAgICAgIH0pO1xuXG4gICAgICBleHByZXNzaW9ucy5wdXNoKFxuICAgICAgICB0ZW1wbGF0ZS5leHByZXNzaW9uKGBUb2tlbi5hc1N0cmluZyglJWV4cHIlJSlgKSh7XG4gICAgICAgICAgZXhwcixcbiAgICAgICAgfSkgYXMgdC5FeHByZXNzaW9uXG4gICAgICApO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1Njb3BlZFRyYXZlcnNhbCkge1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKHQuc3RyaW5nTGl0ZXJhbChcIn1cIikpO1xuICAgICAgICBpc1Njb3BlZFRyYXZlcnNhbCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBleHByZXNzaW9ucy5wdXNoKGV4cHIpO1xuICB9XG5cbiAgaWYgKGlzU2NvcGVkVHJhdmVyc2FsKSB7XG4gICAgZXhwcmVzc2lvbnMucHVzaCh0LnN0cmluZ0xpdGVyYWwoXCJ9XCIpKTtcbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uRm9yU2VyaWFsU3RyaW5nQ29uY2F0ZW5hdGlvbihzY29wZSwgZXhwcmVzc2lvbnMpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RXhwcmVzc2lvblRvVHMoXG4gIHNjb3BlOiBSZXNvdXJjZVNjb3BlLFxuICBub2RlOiB0ZXguT2JqZWN0RXhwcmVzc2lvblxuKSB7XG4gIHJldHVybiB0Lm9iamVjdEV4cHJlc3Npb24oXG4gICAgT2JqZWN0LmVudHJpZXMobm9kZS5tZXRhLml0ZW1zKVxuICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlQ2hpbGQgPSBnZXRDaGlsZFdpdGhWYWx1ZShub2RlLCB2YWx1ZSk7XG4gICAgICAgIGlmICghdmFsdWVDaGlsZCkge1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihgVW5hYmxlIHRvIHZhbHVlIGZvciBvYmplY3Qga2V5ICcke2tleX0nOiAke3ZhbHVlfWApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQub2JqZWN0UHJvcGVydHkoXG4gICAgICAgICAgdC5pZGVudGlmaWVyKGtleSksXG4gICAgICAgICAgY29udmVydFRGRXhwcmVzc2lvbkFzdFRvVHMoc2NvcGUsIHZhbHVlQ2hpbGQpXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigocykgPT4gcyAhPT0gbnVsbCkgYXMgdC5PYmplY3RQcm9wZXJ0eVtdXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGdW5jdGlvbkNhbGxFeHByZXNzaW9uVG9UcyhcbiAgc2NvcGU6IFJlc291cmNlU2NvcGUsXG4gIG5vZGU6IHRleC5GdW5jdGlvbkNhbGxFeHByZXNzaW9uXG4pIHtcbiAgY29uc3QgZnVuY3Rpb25OYW1lID0gbm9kZS5tZXRhLm5hbWU7XG4gIGNvbnN0IG1hcHBpbmcgPSBmdW5jdGlvbnNNYXBbZnVuY3Rpb25OYW1lXTtcblxuICBpZiAoIW1hcHBpbmcpIHtcbiAgICBsb2dnZXIuZXJyb3IoXG4gICAgICBgVW5rbm93biBmdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0gZW5jb3VudGVyZWQuICR7bGVhdmVDb21tZW50VGV4dH1gXG4gICAgKTtcbiAgICBjb25zdCBhcmd1bWVudEV4cHJlc3Npb25zID0gbm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PlxuICAgICAgY29udmVydFRGRXhwcmVzc2lvbkFzdFRvVHMoc2NvcGUsIGNoaWxkKVxuICAgICk7XG5cbiAgICByZXR1cm4gdC5jYWxsRXhwcmVzc2lvbih0LmlkZW50aWZpZXIoZnVuY3Rpb25OYW1lKSwgYXJndW1lbnRFeHByZXNzaW9ucyk7XG4gIH1cblxuICBsZXQgdHJhbnNmb3JtZWROb2RlOiB0ZXguRnVuY3Rpb25DYWxsRXhwcmVzc2lvbiA9IG1hcHBpbmcudHJhbnNmb3JtZXJcbiAgICA/IG1hcHBpbmcudHJhbnNmb3JtZXIobm9kZSlcbiAgICA6IG5vZGU7XG5cbiAgY29uc3QgYXJndW1lbnRFeHByZXNzaW9ucyA9IHRyYW5zZm9ybWVkTm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PlxuICAgIGNvbnZlcnRURkV4cHJlc3Npb25Bc3RUb1RzKHNjb3BlLCBjaGlsZClcbiAgKTtcblxuICBzY29wZS5pbXBvcnRhYmxlcy5wdXNoKHtcbiAgICBjb25zdHJ1Y3ROYW1lOiBcIkZuXCIsXG4gICAgcHJvdmlkZXI6IFwiY2RrdGZcIixcbiAgfSk7XG5cbiAgY29uc3QgY2FsbGVlID0gdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgIHQuaWRlbnRpZmllcihcIkZuXCIpLFxuICAgIHQuaWRlbnRpZmllcihtYXBwaW5nLm5hbWUpXG4gICk7XG5cbiAgaWYgKFxuICAgIG1hcHBpbmcucGFyYW1ldGVycy5sZW5ndGggPiAwICYmXG4gICAgbWFwcGluZy5wYXJhbWV0ZXJzW21hcHBpbmcucGFyYW1ldGVycy5sZW5ndGggLSAxXS52YXJpYWRpY1xuICApIHtcbiAgICBjb25zdCBsYXN0UGFyYW1ldGVyVHlwZSA9XG4gICAgICBtYXBwaW5nLnBhcmFtZXRlcnNbbWFwcGluZy5wYXJhbWV0ZXJzLmxlbmd0aCAtIDFdLnR5cGU7XG4gICAgY29uc3Qgbm9uVmFyaWFkaWNBcmd1bWVudHMgPSBhcmd1bWVudEV4cHJlc3Npb25zLnNsaWNlKFxuICAgICAgMCxcbiAgICAgIG1hcHBpbmcucGFyYW1ldGVycy5sZW5ndGggLSAxXG4gICAgKTtcblxuICAgIGNvbnN0IGZuQ2FsbEFyZ3VtZW50cyA9IFtcbiAgICAgIC4uLm5vblZhcmlhZGljQXJndW1lbnRzLm1hcCgoYXJnRXhwciwgaW5kZXgpID0+XG4gICAgICAgIGNvZXJjZVR5cGUoXG4gICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgYXJnRXhwcixcbiAgICAgICAgICBmaW5kRXhwcmVzc2lvblR5cGUoc2NvcGUsIGFyZ0V4cHIpLFxuICAgICAgICAgIG1hcHBpbmcucGFyYW1ldGVyc1tpbmRleF0udHlwZVxuICAgICAgICApXG4gICAgICApLFxuXG4gICAgICB0LmFycmF5RXhwcmVzc2lvbihcbiAgICAgICAgYXJndW1lbnRFeHByZXNzaW9uc1xuICAgICAgICAgIC5zbGljZShtYXBwaW5nLnBhcmFtZXRlcnMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAubWFwKChhcmdFeHByKSA9PlxuICAgICAgICAgICAgY29lcmNlVHlwZShcbiAgICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICAgIGFyZ0V4cHIsXG4gICAgICAgICAgICAgIGZpbmRFeHByZXNzaW9uVHlwZShzY29wZSwgYXJnRXhwciksXG4gICAgICAgICAgICAgIGxhc3RQYXJhbWV0ZXJUeXBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgKSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIHQuY2FsbEV4cHJlc3Npb24oY2FsbGVlLCBmbkNhbGxBcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIHQuY2FsbEV4cHJlc3Npb24oXG4gICAgY2FsbGVlLFxuICAgIGFyZ3VtZW50RXhwcmVzc2lvbnMubWFwKChhcmdFeHByLCBpbmRleCkgPT5cbiAgICAgIGNvZXJjZVR5cGUoXG4gICAgICAgIHNjb3BlLFxuICAgICAgICBhcmdFeHByLFxuICAgICAgICBmaW5kRXhwcmVzc2lvblR5cGUoc2NvcGUsIGFyZ0V4cHIpLFxuICAgICAgICBtYXBwaW5nLnBhcmFtZXRlcnNbaW5kZXhdLnR5cGVcbiAgICAgIClcbiAgICApXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRJbmRleEV4cHJlc3Npb25Ub1RzKFxuICBzY29wZTogUmVzb3VyY2VTY29wZSxcbiAgbm9kZTogdGV4LkluZGV4RXhwcmVzc2lvblxuKSB7XG4gIGNvbnN0IGNvbGxlY3Rpb25FeHByZXNzaW9uQ2hpbGQgPSB0ZXguZ2V0Q2hpbGRXaXRoVmFsdWUoXG4gICAgbm9kZSxcbiAgICBub2RlLm1ldGEuY29sbGVjdGlvbkV4cHJlc3Npb25cbiAgKTtcbiAgY29uc3Qga2V5RXhwcmVzc2lvbkNoaWxkID0gdGV4LmdldENoaWxkV2l0aFZhbHVlKFxuICAgIG5vZGUsXG4gICAgbm9kZS5tZXRhLmtleUV4cHJlc3Npb25cbiAgKTtcblxuICBjb25zdCBjb2xsZWN0aW9uRXhwcmVzc2lvbiA9IGNvbnZlcnRURkV4cHJlc3Npb25Bc3RUb1RzKFxuICAgIHNjb3BlLFxuICAgIGNvbGxlY3Rpb25FeHByZXNzaW9uQ2hpbGQhXG4gICk7XG4gIGNvbnN0IGtleUV4cHJlc3Npb24gPSBjb252ZXJ0VEZFeHByZXNzaW9uQXN0VG9UcyhzY29wZSwga2V5RXhwcmVzc2lvbkNoaWxkISk7XG5cbiAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgY29uc3RydWN0TmFtZTogXCJGblwiLFxuICAgIHByb3ZpZGVyOiBcImNka3RmXCIsXG4gIH0pO1xuICBjb25zdCBjYWxsZWUgPSB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgdC5pZGVudGlmaWVyKFwiRm5cIiksXG4gICAgdC5pZGVudGlmaWVyKFwibG9va3VwTmVzdGVkXCIpXG4gICk7XG4gIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKGNhbGxlZSwgW1xuICAgIGNvbGxlY3Rpb25FeHByZXNzaW9uLFxuICAgIHQuYXJyYXlFeHByZXNzaW9uKFtrZXlFeHByZXNzaW9uXSksXG4gIF0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0U3BsYXRFeHByZXNzaW9uVG9UcyhcbiAgc2NvcGU6IFJlc291cmNlU2NvcGUsXG4gIG5vZGU6IHRleC5TcGxhdEV4cHJlc3Npb25cbikge1xuICBjb25zdCBzb3VyY2VFeHByZXNzaW9uQ2hpbGQgPSB0ZXguZ2V0Q2hpbGRXaXRoVmFsdWUoXG4gICAgbm9kZSxcbiAgICBub2RlLm1ldGEuc291cmNlRXhwcmVzc2lvblxuICApITtcbiAgbGV0IHNvdXJjZUV4cHJlc3Npb24gPSBjb252ZXJ0VEZFeHByZXNzaW9uQXN0VG9UcyhcbiAgICBzY29wZSxcbiAgICBzb3VyY2VFeHByZXNzaW9uQ2hpbGRcbiAgKTtcblxuICAvLyBXZSBkb24ndCBjb252ZXJ0IHRoZSByZWxhdGl2ZSBleHByZXNzaW9uIGJlY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgc3BsYXQgaXMgZ29pbmcgdG8gYmVcbiAgLy8gYSBzdHJpbmdcbiAgbGV0IHJlbGF0aXZlRXhwcmVzc2lvbiA9IG5vZGUubWV0YS5lYWNoRXhwcmVzc2lvbi5zdGFydHNXaXRoKFxuICAgIG5vZGUubWV0YS5hbm9uU3ltYm9sRXhwcmVzc2lvblxuICApXG4gICAgPyBub2RlLm1ldGEuZWFjaEV4cHJlc3Npb24uc2xpY2Uobm9kZS5tZXRhLmFub25TeW1ib2xFeHByZXNzaW9uLmxlbmd0aClcbiAgICA6IG5vZGUubWV0YS5lYWNoRXhwcmVzc2lvbjtcblxuICBjb25zdCBzZWdtZW50cyA9IHJlbGF0aXZlRXhwcmVzc2lvbi5zcGxpdCgvXFwufFxcW3xcXF0vKS5maWx0ZXIoKHMpID0+IHMpO1xuICBzY29wZS5pbXBvcnRhYmxlcy5wdXNoKHtcbiAgICBjb25zdHJ1Y3ROYW1lOiBcIkZuXCIsXG4gICAgcHJvdmlkZXI6IFwiY2RrdGZcIixcbiAgfSk7XG4gIGNvbnN0IGNhbGxlZSA9IHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICB0LmlkZW50aWZpZXIoXCJGblwiKSxcbiAgICB0LmlkZW50aWZpZXIoXCJsb29rdXBOZXN0ZWRcIilcbiAgKTtcblxuICByZXR1cm4gdC5jYWxsRXhwcmVzc2lvbihjYWxsZWUsIFtcbiAgICBzb3VyY2VFeHByZXNzaW9uLFxuICAgIHQuYXJyYXlFeHByZXNzaW9uKFtcbiAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gdXNlIHRoZSBhbm9uU3ltYm9sRXhwcmVzc2lvbiBoZXJlIGJlY2F1c2VcbiAgICAgIC8vIGl0IG9ubHkgY2hhbmdlcyBiZXR3ZWVuIC4qIGFuZCBbKl0gd2hpY2ggd2UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgdC5zdHJpbmdMaXRlcmFsKFwiKlwiKSxcbiAgICAgIC4uLnNlZ21lbnRzLm1hcCh0LnN0cmluZ0xpdGVyYWwpLFxuICAgIF0pLFxuICBdKTtcbn1cblxuZnVuY3Rpb24gY29udmVydENvbmRpdGlvbmFsRXhwcmVzc2lvblRvVHMoXG4gIHNjb3BlOiBSZXNvdXJjZVNjb3BlLFxuICBub2RlOiB0ZXguQ29uZGl0aW9uYWxFeHByZXNzaW9uXG4pIHtcbiAgY29uc3QgY29uZGl0aW9uQ2hpbGQgPSB0ZXguZ2V0Q2hpbGRXaXRoVmFsdWUoXG4gICAgbm9kZSxcbiAgICBub2RlLm1ldGEuY29uZGl0aW9uRXhwcmVzc2lvblxuICApITtcbiAgbGV0IGNvbmRpdGlvbiA9IGNvbnZlcnRURkV4cHJlc3Npb25Bc3RUb1RzKHNjb3BlLCBjb25kaXRpb25DaGlsZCk7XG4gIGlmICh0LmlzSWRlbnRpZmllcihjb25kaXRpb24pICYmIGNhblVzZUZxbihjb25kaXRpb25DaGlsZCkpIHtcbiAgICAvLyBXZSBoYXZlIGEgcmVzb3VyY2Ugb3IgZGF0YSBzb3VyY2UgaGVyZSwgd2hpY2ggd2Ugd291bGQgbmVlZCB0b1xuICAgIC8vIHJlZmVyZW5jZSB1c2luZyBmcW5cbiAgICBjb25kaXRpb24gPSB0Lm1lbWJlckV4cHJlc3Npb24oY29uZGl0aW9uLCB0LmlkZW50aWZpZXIoXCJmcW5cIikpO1xuICB9XG5cbiAgY29uc3QgdHJ1ZUV4cHJlc3Npb24gPSBjb252ZXJ0VEZFeHByZXNzaW9uQXN0VG9UcyhcbiAgICBzY29wZSxcbiAgICB0ZXguZ2V0Q2hpbGRXaXRoVmFsdWUobm9kZSwgbm9kZS5tZXRhLnRydWVFeHByZXNzaW9uKSFcbiAgKTtcblxuICBjb25zdCBmYWxzZUV4cHJlc3Npb24gPSBjb252ZXJ0VEZFeHByZXNzaW9uQXN0VG9UcyhcbiAgICBzY29wZSxcbiAgICB0ZXguZ2V0Q2hpbGRXaXRoVmFsdWUobm9kZSwgbm9kZS5tZXRhLmZhbHNlRXhwcmVzc2lvbikhXG4gICk7XG5cbiAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgY29uc3RydWN0TmFtZTogXCJjb25kaXRpb25hbFwiLFxuICAgIHByb3ZpZGVyOiBcImNka3RmXCIsXG4gIH0pO1xuXG4gIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKHQuaWRlbnRpZmllcihcImNvbmRpdGlvbmFsXCIpLCBbXG4gICAgY29uZGl0aW9uLFxuICAgIHRydWVFeHByZXNzaW9uLFxuICAgIGZhbHNlRXhwcmVzc2lvbixcbiAgXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUdXBsZUV4cHJlc3Npb25Ub1RzKFxuICBzY29wZTogUmVzb3VyY2VTY29wZSxcbiAgbm9kZTogdGV4LlR1cGxlRXhwcmVzc2lvblxuKSB7XG4gIGNvbnN0IGV4cHJlc3Npb25zID0gbm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PlxuICAgIGNvbnZlcnRURkV4cHJlc3Npb25Bc3RUb1RzKHNjb3BlLCBjaGlsZClcbiAgKTtcblxuICByZXR1cm4gdC5hcnJheUV4cHJlc3Npb24oZXhwcmVzc2lvbnMpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UmVsYXRpdmVUcmF2ZXJzYWxFeHByZXNzaW9uVG9UcyhcbiAgc2NvcGU6IFJlc291cmNlU2NvcGUsXG4gIG5vZGU6IHRleC5SZWxhdGl2ZVRyYXZlcnNhbEV4cHJlc3Npb25cbikge1xuICBjb25zdCBzZWdtZW50cyA9IG5vZGUubWV0YS50cmF2ZXJzYWw7XG5cbiAgLy8gVGhlIGxlZnQgaGFuZCBzaWRlIC8gc291cmNlIG9mIGEgcmVsYXRpdmUgdHJhdmVyc2FsIGlzIG5vdCBhIHByb3BlclxuICAvLyBvYmplY3QgLyByZXNvdXJjZSAvIGRhdGEgdGhpbmcgdGhhdCBpcyBiZWluZyByZWZlcmVuY2VkXG4gIGNvbnN0IHNvdXJjZSA9IGNvbnZlcnRURkV4cHJlc3Npb25Bc3RUb1RzKFxuICAgIHNjb3BlLFxuICAgIHRleC5nZXRDaGlsZFdpdGhWYWx1ZShub2RlLCBub2RlLm1ldGEuc291cmNlRXhwcmVzc2lvbikhXG4gICk7XG5cbiAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgY29uc3RydWN0TmFtZTogXCJGblwiLFxuICAgIHByb3ZpZGVyOiBcImNka3RmXCIsXG4gIH0pO1xuICBjb25zdCBjYWxsZWUgPSB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgdC5pZGVudGlmaWVyKFwiRm5cIiksXG4gICAgdC5pZGVudGlmaWVyKFwibG9va3VwTmVzdGVkXCIpXG4gICk7XG5cbiAgcmV0dXJuIHQuY2FsbEV4cHJlc3Npb24oY2FsbGVlLCBbXG4gICAgc291cmNlLFxuICAgIHQuYXJyYXlFeHByZXNzaW9uKHNlZ21lbnRzLm1hcCgocykgPT4gdC5zdHJpbmdMaXRlcmFsKHMuc2VnbWVudCkpKSxcbiAgXSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGb3JFeHByZXNzaW9uVG9UcyhcbiAgc2NvcGU6IFJlc291cmNlU2NvcGUsXG4gIG5vZGU6IHRleC5Gb3JFeHByZXNzaW9uXG4pIHtcbiAgY29uc3QgY29sbGVjdGlvbkNoaWxkID0gdGV4LmdldENoaWxkV2l0aFZhbHVlKFxuICAgIG5vZGUsXG4gICAgbm9kZS5tZXRhLmNvbGxlY3Rpb25FeHByZXNzaW9uXG4gICkhO1xuXG4gIGxldCBjb2xsZWN0aW9uRXhwcmVzc2lvbiA9IGNvbnZlcnRURkV4cHJlc3Npb25Bc3RUb1RzKHNjb3BlLCBjb2xsZWN0aW9uQ2hpbGQpO1xuXG4gIGlmICh0LmlzSWRlbnRpZmllcihjb2xsZWN0aW9uRXhwcmVzc2lvbikgJiYgY2FuVXNlRnFuKGNvbGxlY3Rpb25DaGlsZCkpIHtcbiAgICAvLyBXZSBoYXZlIGEgcmVzb3VyY2Ugb3IgZGF0YSBzb3VyY2UgaGVyZSwgd2hpY2ggd2Ugd291bGQgbmVlZCB0b1xuICAgIC8vIHJlZmVyZW5jZSB1c2luZyBmcW5cbiAgICBjb2xsZWN0aW9uRXhwcmVzc2lvbiA9IHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgIGNvbGxlY3Rpb25FeHByZXNzaW9uLFxuICAgICAgdC5pZGVudGlmaWVyKFwiZnFuXCIpXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGNvbGxlY3Rpb25SZXF1aXJlc1dyYXBwaW5nID0gIXQuaXNTdHJpbmdMaXRlcmFsKGNvbGxlY3Rpb25FeHByZXNzaW9uKTtcbiAgY29uc3QgZXhwcmVzc2lvbnMgPSBbXTtcbiAgY29uc3QgY29uZGl0aW9uQm9keSA9IG5vZGUubWV0YS5rZXlWYXJcbiAgICA/IGAke25vZGUubWV0YS5rZXlWYXJ9LCAke25vZGUubWV0YS52YWxWYXJ9YFxuICAgIDogbm9kZS5tZXRhLnZhbFZhcjtcblxuICBjb25zdCBvcGVuQnJhY2UgPSBub2RlLm1ldGEub3BlblJhbmdlVmFsdWU7XG4gIGNvbnN0IGNsb3NlQnJhY2UgPSBub2RlLm1ldGEuY2xvc2VSYW5nZVZhbHVlO1xuICBjb25zdCBncm91cGVkID0gbm9kZS5tZXRhLmdyb3VwZWRWYWx1ZSA/IFwiLi4uXCIgOiBcIlwiO1xuICBjb25zdCB2YWx1ZUV4cHJlc3Npb24gPSBgJHtub2RlLm1ldGEudmFsdWVFeHByZXNzaW9ufSR7Z3JvdXBlZH1gO1xuXG4gIGNvbnN0IHByZWZpeCA9IGBcXCR7JHtvcGVuQnJhY2V9IGZvciAke2NvbmRpdGlvbkJvZHl9IGluIGA7XG4gIGNvbnN0IGtleVZhbHVlID0gbm9kZS5tZXRhLmtleUV4cHJlc3Npb25cbiAgICA/IGAgOiAke25vZGUubWV0YS5rZXlFeHByZXNzaW9ufSA9PiAke3ZhbHVlRXhwcmVzc2lvbn1gXG4gICAgOiBgIDogJHt2YWx1ZUV4cHJlc3Npb259YDtcbiAgY29uc3QgY29uZGl0aW9uYWwgPSBub2RlLm1ldGEuY29uZGl0aW9uYWxFeHByZXNzaW9uO1xuICBjb25zdCBzdWZmaXggPSBgJHtrZXlWYWx1ZX0ke1xuICAgIGNvbmRpdGlvbmFsID8gYCBpZiAke2NvbmRpdGlvbmFsfWAgOiBcIlwiXG4gIH0ke2Nsb3NlQnJhY2V9fWA7XG5cbiAgZXhwcmVzc2lvbnMucHVzaCh0LnN0cmluZ0xpdGVyYWwocHJlZml4KSk7XG4gIGlmIChjb2xsZWN0aW9uUmVxdWlyZXNXcmFwcGluZykge1xuICAgIGV4cHJlc3Npb25zLnB1c2godC5zdHJpbmdMaXRlcmFsKFwiJHtcIikpO1xuICB9XG4gIGV4cHJlc3Npb25zLnB1c2goY29sbGVjdGlvbkV4cHJlc3Npb24pO1xuICBpZiAoY29sbGVjdGlvblJlcXVpcmVzV3JhcHBpbmcpIHtcbiAgICBleHByZXNzaW9ucy5wdXNoKHQuc3RyaW5nTGl0ZXJhbChcIn1cIikpO1xuICB9XG4gIGV4cHJlc3Npb25zLnB1c2godC5zdHJpbmdMaXRlcmFsKHN1ZmZpeCkpO1xuXG4gIHJldHVybiBleHByZXNzaW9uRm9yU2VyaWFsU3RyaW5nQ29uY2F0ZW5hdGlvbihzY29wZSwgZXhwcmVzc2lvbnMpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VEZFeHByZXNzaW9uQXN0VG9UcyhcbiAgc2NvcGU6IFJlc291cmNlU2NvcGUsXG4gIG5vZGU6IHRleC5FeHByZXNzaW9uVHlwZVxuKTogdC5FeHByZXNzaW9uIHtcbiAgaWYgKHRleC5pc0xpdGVyYWxWYWx1ZUV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gY29udmVydExpdGVyYWxWYWx1ZUV4cHJlc3Npb25Ub1RzKHNjb3BlLCBub2RlKTtcbiAgfVxuXG4gIGlmICh0ZXguaXNTY29wZVRyYXZlcnNhbEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gY29udmVydFNjb3BlVHJhdmVyc2FsRXhwcmVzc2lvblRvVHMoc2NvcGUsIG5vZGUpO1xuICB9XG5cbiAgaWYgKHRleC5pc1VuYXJ5T3BFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRVbmFyeU9wRXhwcmVzc2lvblRvVHMoc2NvcGUsIG5vZGUpO1xuICB9XG5cbiAgaWYgKHRleC5pc0JpbmFyeU9wRXhwcmVzc2lvbihub2RlKSkge1xuICAgIHJldHVybiBjb252ZXJ0QmluYXJ5T3BFeHByZXNzaW9uVG9UcyhzY29wZSwgbm9kZSk7XG4gIH1cblxuICBpZiAodGV4LmlzVGVtcGxhdGVFeHByZXNzaW9uKG5vZGUpIHx8IHRleC5pc1RlbXBsYXRlV3JhcEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gY29udmVydFRlbXBsYXRlRXhwcmVzc2lvblRvVHMoc2NvcGUsIG5vZGUpO1xuICB9XG5cbiAgaWYgKHRleC5pc09iamVjdEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gY29udmVydE9iamVjdEV4cHJlc3Npb25Ub1RzKHNjb3BlLCBub2RlKTtcbiAgfVxuXG4gIGlmICh0ZXguaXNGdW5jdGlvbkNhbGxFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRGdW5jdGlvbkNhbGxFeHByZXNzaW9uVG9UcyhzY29wZSwgbm9kZSk7XG4gIH1cblxuICBpZiAodGV4LmlzSW5kZXhFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRJbmRleEV4cHJlc3Npb25Ub1RzKHNjb3BlLCBub2RlKTtcbiAgfVxuXG4gIGlmICh0ZXguaXNTcGxhdEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gY29udmVydFNwbGF0RXhwcmVzc2lvblRvVHMoc2NvcGUsIG5vZGUpO1xuICB9XG5cbiAgaWYgKHRleC5pc0NvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlKSkge1xuICAgIHJldHVybiBjb252ZXJ0Q29uZGl0aW9uYWxFeHByZXNzaW9uVG9UcyhzY29wZSwgbm9kZSk7XG4gIH1cblxuICBpZiAodGV4LmlzVHVwbGVFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRUdXBsZUV4cHJlc3Npb25Ub1RzKHNjb3BlLCBub2RlKTtcbiAgfVxuXG4gIGlmICh0ZXguaXNSZWxhdGl2ZVRyYXZlcnNhbEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gY29udmVydFJlbGF0aXZlVHJhdmVyc2FsRXhwcmVzc2lvblRvVHMoc2NvcGUsIG5vZGUpO1xuICB9XG5cbiAgaWYgKHRleC5pc0ZvckV4cHJlc3Npb24obm9kZSkpIHtcbiAgICByZXR1cm4gY29udmVydEZvckV4cHJlc3Npb25Ub1RzKHNjb3BlLCBub2RlKTtcbiAgfVxuXG4gIHJldHVybiB0LnN0cmluZ0xpdGVyYWwoXCJcIik7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHByZXNzaW9uQXN0KFxuICBpbnB1dDogc3RyaW5nXG4pOiBQcm9taXNlPHRleC5FeHByZXNzaW9uVHlwZT4ge1xuICBjb25zdCB7IHdyYXAsIHdyYXBPZmZzZXQgfSA9IHdyYXBUZXJyYWZvcm1FeHByZXNzaW9uKGlucHV0KTtcbiAgY29uc3QgYXN0ID0gYXdhaXQgZ2V0RXhwcmVzc2lvbkFzdChcIm1haW4udGZcIiwgd3JhcCk7XG5cbiAgaWYgKCFhc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSB0ZXJyYWZvcm0gZXhwcmVzc2lvbjogJHtpbnB1dH1gKTtcbiAgfVxuXG4gIGlmICh3cmFwT2Zmc2V0ICE9IDAgJiYgdGV4LmlzVGVtcGxhdGVXcmFwRXhwcmVzc2lvbihhc3QpKSB7XG4gICAgcmV0dXJuIGFzdC5jaGlsZHJlblswXTtcbiAgfVxuXG4gIHJldHVybiBhc3Q7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0VGVycmFmb3JtRXhwcmVzc2lvblRvVHMoXG4gIHNjb3BlOiBSZXNvdXJjZVNjb3BlLFxuICBpbnB1dDogc3RyaW5nLFxuICB0YXJnZXRUeXBlOiAoKSA9PiBBdHRyaWJ1dGVUeXBlXG4pOiBQcm9taXNlPHQuRXhwcmVzc2lvbj4ge1xuICBsb2dnZXIuZGVidWcoYGNvbnZlcnRUZXJyYWZvcm1FeHByZXNzaW9uVG9Ucygke2lucHV0fSlgKTtcbiAgY29uc3QgdHNFeHByZXNzaW9uID0gY29udmVydFRGRXhwcmVzc2lvbkFzdFRvVHMoXG4gICAgc2NvcGUsXG4gICAgYXdhaXQgZXhwcmVzc2lvbkFzdChpbnB1dClcbiAgKTtcblxuICByZXR1cm4gY29lcmNlVHlwZShcbiAgICBzY29wZSxcbiAgICB0c0V4cHJlc3Npb24sXG4gICAgZmluZEV4cHJlc3Npb25UeXBlKHNjb3BlLCB0c0V4cHJlc3Npb24pLFxuICAgIHRhcmdldFR5cGUoKVxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEl0ZXJhdG9yVmFyaWFibGVzRnJvbUV4cHJlc3Npb24oXG4gIGlucHV0OiBzdHJpbmdcbik6IFByb21pc2U8SXRlcmF0b3JWYXJpYWJsZVJlZmVyZW5jZVtdPiB7XG4gIGNvbnN0IHBvc3NpYmxlVmFyaWFibGVTcG90cyA9IGF3YWl0IGdldFJlZmVyZW5jZXNJbkV4cHJlc3Npb24oXG4gICAgXCJtYWluLnRmXCIsXG4gICAgaW5wdXRcbiAgKTtcblxuICByZXR1cm4gcG9zc2libGVWYXJpYWJsZVNwb3RzXG4gICAgLmZpbHRlcigoc3BvdCkgPT4gc3BvdC52YWx1ZS5zdGFydHNXaXRoKFwiZWFjaC5cIikpXG4gICAgLm1hcCgoc3BvdCkgPT4gKHtcbiAgICAgIHN0YXJ0OiBzcG90LnN0YXJ0UG9zaXRpb24sXG4gICAgICBlbmQ6IHNwb3QuZW5kUG9zaXRpb24sXG4gICAgICB2YWx1ZTogc3BvdC52YWx1ZSxcbiAgICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkeW5hbWljVmFyaWFibGVUb0FzdChcbiAgc2NvcGU6IFByb2dyYW1TY29wZSxcbiAgbm9kZTogdGV4LlNjb3BlVHJhdmVyc2FsRXhwcmVzc2lvbixcbiAgaXRlcmF0b3JOYW1lOiBzdHJpbmcsXG4gIGJsb2NrOiBzdHJpbmcgPSBcImVhY2hcIlxuKTogdC5FeHByZXNzaW9uIHtcbiAgaWYgKGl0ZXJhdG9yTmFtZSA9PT0gXCJkeW5hbWljLWJsb2NrXCIpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbkZvclNlcmlhbFN0cmluZ0NvbmNhdGVuYXRpb24oc2NvcGUsIFtcbiAgICAgIHQuc3RyaW5nTGl0ZXJhbChcIiR7XCIpLFxuICAgICAgdC5zdHJpbmdMaXRlcmFsKGJsb2NrKSxcbiAgICAgIHQuc3RyaW5nTGl0ZXJhbChcIn1cIiksXG4gICAgXSk7XG4gIH1cbiAgaWYgKG5vZGUubWV0YS52YWx1ZSA9PT0gYCR7YmxvY2t9LmtleWApIHtcbiAgICByZXR1cm4gdC5tZW1iZXJFeHByZXNzaW9uKHQuaWRlbnRpZmllcihpdGVyYXRvck5hbWUpLCB0LmlkZW50aWZpZXIoXCJrZXlcIikpO1xuICB9XG4gIGlmIChub2RlLm1ldGEudmFsdWUgPT09IGAke2Jsb2NrfS52YWx1ZWApIHtcbiAgICByZXR1cm4gdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgdC5pZGVudGlmaWVyKGl0ZXJhdG9yTmFtZSksXG4gICAgICB0LmlkZW50aWZpZXIoXCJ2YWx1ZVwiKVxuICAgICk7XG4gIH1cblxuICBpZiAoYmxvY2sgPT09IFwiY291bnRcIiAmJiBub2RlLm1ldGEudmFsdWUgPT09IGAke2Jsb2NrfS5pbmRleGApIHtcbiAgICByZXR1cm4gdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgdC5pZGVudGlmaWVyKGl0ZXJhdG9yTmFtZSksXG4gICAgICB0LmlkZW50aWZpZXIoXCJpbmRleFwiKVxuICAgICk7XG4gIH1cblxuICBjb25zdCBzZWdtZW50cyA9IG5vZGUubWV0YS50cmF2ZXJzYWw7XG5cbiAgaWYgKFxuICAgIHNlZ21lbnRzLmxlbmd0aCA+IDIgJiZcbiAgICBzZWdtZW50c1swXS5zZWdtZW50ID09PSBibG9jayAmJlxuICAgIHNlZ21lbnRzWzFdLnNlZ21lbnQgPT09IFwidmFsdWVcIlxuICApIHtcbiAgICBjb25zdCBzZWdtZW50c0FmdGVyRWFjaFZhbHVlID0gc2VnbWVudHMuc2xpY2UoMik7XG4gICAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgICBjb25zdHJ1Y3ROYW1lOiBcIkZuXCIsXG4gICAgICBwcm92aWRlcjogXCJjZGt0ZlwiLFxuICAgIH0pO1xuICAgIGNvbnN0IGNhbGxlZSA9IHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgIHQuaWRlbnRpZmllcihcIkZuXCIpLFxuICAgICAgdC5pZGVudGlmaWVyKFwibG9va3VwTmVzdGVkXCIpXG4gICAgKTtcbiAgICByZXR1cm4gdC5jYWxsRXhwcmVzc2lvbihjYWxsZWUsIFtcbiAgICAgIHQubWVtYmVyRXhwcmVzc2lvbih0LmlkZW50aWZpZXIoaXRlcmF0b3JOYW1lKSwgdC5pZGVudGlmaWVyKFwidmFsdWVcIikpLFxuICAgICAgdC5hcnJheUV4cHJlc3Npb24oXG4gICAgICAgIHNlZ21lbnRzQWZ0ZXJFYWNoVmFsdWUubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJuYW1lVHJhdmVyc2FsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0LnN0cmluZ0xpdGVyYWwocGFydC5zZWdtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHQuc3RyaW5nTGl0ZXJhbChgWyR7cGFydC5zZWdtZW50fV1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgIF0pO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBDYW4gbm90IGNyZWF0ZSBBU1QgZm9yIGl0ZXJhdG9yIHZhcmlhYmxlIG9mICcke25vZGUubWV0YS52YWx1ZX0nYFxuICApO1xufVxuIl19