"use strict";
/**
 * Copyright (c) HashiCorp, Inc.
 * SPDX-License-Identifier: MPL-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRequiredAttributes = exports.fillWithConfigAccessors = void 0;
const terraformSchema_1 = require("./terraformSchema");
const t = __importStar(require("@babel/types"));
const utils_1 = require("./utils");
function getConfigFieldName(topLevelConfig, name) {
    const sanitizedName = (0, utils_1.camelCase)(name);
    return deduplicateName(Object.keys(topLevelConfig), sanitizedName);
}
function deduplicateName(existingNames, name) {
    let newName = name;
    let i = 1;
    while (existingNames.includes(newName)) {
        newName = `${name}${i}`;
        i++;
    }
    return newName;
}
function fillWithConfigAccessors(scope, config, path) {
    if (Array.isArray(config)) {
        return config.map((c) => fillWithConfigAccessors(scope, c, `${path}.[]`));
    }
    if (typeof config === "object" && config !== null) {
        const mutated = Object.entries(config).reduce((acc, [key, value]) => ({
            ...acc,
            [key]: fillWithConfigAccessors(scope, value, `${path}.${key}`),
        }), {});
        // Get type of this part of the config
        const attributeType = (0, terraformSchema_1.getTypeAtPath)(scope.providerSchema, path);
        const requiredAttributes = getRequiredAttributes(attributeType);
        // Add accessors for all required attributes that are missing
        requiredAttributes.forEach((key) => {
            const value = mutated[key];
            const isNotDirectlyAccessible = value === undefined;
            const isReplacedByAst = (t.isNode(mutated) && t.isExpression(mutated)) ||
                t.isExpression(value);
            const isEmptyArray = Array.isArray(value) && value.length === 0;
            // If this was already replaced by an AST node, we don't need to do anything
            // We assume all fields are filled in by the AST
            if (isReplacedByAst) {
                return;
            }
            if (isNotDirectlyAccessible || isEmptyArray) {
                const fieldName = getConfigFieldName(scope.topLevelConfig, key);
                mutated[key] = t.memberExpression(t.identifier("config"), t.identifier(fieldName));
                scope.topLevelConfig[fieldName] = `${path}.${key}`;
            }
        });
        return mutated;
    }
    else {
        return config;
    }
}
exports.fillWithConfigAccessors = fillWithConfigAccessors;
function getRequiredAttributes(attributeType) {
    if (!attributeType) {
        return [];
    }
    if (typeof attributeType !== "object" ||
        Array.isArray(attributeType) ||
        attributeType === null ||
        attributeType === undefined ||
        !("block" in attributeType)) {
        return [];
    }
    const requiredAttributes = Object.entries(attributeType.block.attributes || {}).reduce((acc, [key, value]) => (value.required ? [...acc, key] : acc), []);
    // Logic taken from (and should be shared with) provider generator resource parser: attributeForBlockType
    const requiredBlockTypes = Object.entries(attributeType.block.block_types || {}).reduce((acc, [key, value]) => {
        if (value.nesting_mode === "single" &&
            !Object.values(value.block.attributes || {}).some((x) => !x.required)) {
            return [...acc, key];
        }
        if (value.nesting_mode === "map") {
            return acc;
        }
        if ((value.nesting_mode === "list" || value.nesting_mode === "set") &&
            value.min_items === undefined
            ? false
            : value.min_items > 0) {
            return [...acc, key];
        }
        return acc;
    }, []);
    return [...requiredAttributes, ...requiredBlockTypes].sort();
}
exports.getRequiredAttributes = getRequiredAttributes;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFydGlhbENvZGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwYXJ0aWFsQ29kZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7OztHQUdHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVILHVEQUFrRDtBQUVsRCxnREFBa0M7QUFDbEMsbUNBQW9DO0FBRXBDLFNBQVMsa0JBQWtCLENBQ3pCLGNBQXVDLEVBQ3ZDLElBQVk7SUFFWixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEMsT0FBTyxlQUFlLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxhQUFhLENBQUMsQ0FBQztBQUNyRSxDQUFDO0FBRUQsU0FBUyxlQUFlLENBQUMsYUFBdUIsRUFBRSxJQUFZO0lBQzVELElBQUksT0FBTyxHQUFHLElBQUksQ0FBQztJQUNuQixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDVixPQUFPLGFBQWEsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDdEMsT0FBTyxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ3hCLENBQUMsRUFBRSxDQUFDO0tBQ0w7SUFDRCxPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDO0FBRUQsU0FBZ0IsdUJBQXVCLENBQ3JDLEtBQW9CLEVBQ3BCLE1BQThCLEVBQzlCLElBQVk7SUFFWixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDekIsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEdBQUcsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDO0tBQzNFO0lBRUQsSUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLElBQUksTUFBTSxLQUFLLElBQUksRUFBRTtRQUNqRCxNQUFNLE9BQU8sR0FBRyxN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LGFBQWEsQ0FBQyxLQUFLLENBQUMsV0FBVyxJQUFJLEVBQUUsQ0FDdEMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRTtRQUM3QixJQUNFLEtBQUssQ0FBQyxZQUFZLEtBQUssUUFBUTtZQUMvQixDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxVQUFVLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFDckU7WUFDQSxPQUFPLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDdEI7UUFDRCxJQUFJLEtBQUssQ0FBQyxZQUFZLEtBQUssS0FBSyxFQUFFO1lBQ2hDLE9BQU8sR0FBRyxDQUFDO1NBQ1o7UUFFRCxJQUNFLENBQUMsS0FBSyxDQUFDLFlBQVksS0FBSyxNQUFNLElBQUksS0FBSyxDQUFDLFlBQVksS0FBSyxLQUFLLENBQUM7WUFDL0QsS0FBSyxDQUFDLFNBQVMsS0FBSyxTQUFTO1lBQzNCLENBQUMsQ0FBQyxLQUFLO1lBQ1AsQ0FBQyxDQUFFLEtBQWEsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxFQUNoQztZQUNBLE9BQU8sQ0FBQyxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztTQUN0QjtRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQyxFQUFFLEVBQWMsQ0FBQyxDQUFDO0lBQ25CLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixFQUFFLEdBQUcsa0JBQWtCLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUMvRCxDQUFDO0FBakRELHNEQWlEQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNUEwtMi4wXG4gKi9cblxuaW1wb3J0IHsgZ2V0VHlwZUF0UGF0aCB9IGZyb20gXCIuL3RlcnJhZm9ybVNjaGVtYVwiO1xuaW1wb3J0IHsgUmVzb3VyY2VTY29wZSwgVGVycmFmb3JtUmVzb3VyY2VCbG9jayB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgKiBhcyB0IGZyb20gXCJAYmFiZWwvdHlwZXNcIjtcbmltcG9ydCB7IGNhbWVsQ2FzZSB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmZ1bmN0aW9uIGdldENvbmZpZ0ZpZWxkTmFtZShcbiAgdG9wTGV2ZWxDb25maWc6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBuYW1lOiBzdHJpbmdcbikge1xuICBjb25zdCBzYW5pdGl6ZWROYW1lID0gY2FtZWxDYXNlKG5hbWUpO1xuICByZXR1cm4gZGVkdXBsaWNhdGVOYW1lKE9iamVjdC5rZXlzKHRvcExldmVsQ29uZmlnKSwgc2FuaXRpemVkTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGRlZHVwbGljYXRlTmFtZShleGlzdGluZ05hbWVzOiBzdHJpbmdbXSwgbmFtZTogc3RyaW5nKSB7XG4gIGxldCBuZXdOYW1lID0gbmFtZTtcbiAgbGV0IGkgPSAxO1xuICB3aGlsZSAoZXhpc3RpbmdOYW1lcy5pbmNsdWRlcyhuZXdOYW1lKSkge1xuICAgIG5ld05hbWUgPSBgJHtuYW1lfSR7aX1gO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gbmV3TmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGxXaXRoQ29uZmlnQWNjZXNzb3JzKFxuICBzY29wZTogUmVzb3VyY2VTY29wZSxcbiAgY29uZmlnOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrLFxuICBwYXRoOiBzdHJpbmdcbik6IGFueSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICByZXR1cm4gY29uZmlnLm1hcCgoYykgPT4gZmlsbFdpdGhDb25maWdBY2Nlc3NvcnMoc2NvcGUsIGMsIGAke3BhdGh9LltdYCkpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb25maWcgPT09IFwib2JqZWN0XCIgJiYgY29uZmlnICE9PSBudWxsKSB7XG4gICAgY29uc3QgbXV0YXRlZCA9IE9iamVjdC5lbnRyaWVzKGNvbmZpZykucmVkdWNlKFxuICAgICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PiAoe1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFtrZXldOiBmaWxsV2l0aENvbmZpZ0FjY2Vzc29ycyhzY29wZSwgdmFsdWUsIGAke3BhdGh9LiR7a2V5fWApLFxuICAgICAgfSksXG4gICAgICB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrPlxuICAgICk7XG5cbiAgICAvLyBHZXQgdHlwZSBvZiB0aGlzIHBhcnQgb2YgdGhlIGNvbmZpZ1xuICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGUgPSBnZXRUeXBlQXRQYXRoKHNjb3BlLnByb3ZpZGVyU2NoZW1hLCBwYXRoKTtcbiAgICBjb25zdCByZXF1aXJlZEF0dHJpYnV0ZXMgPSBnZXRSZXF1aXJlZEF0dHJpYnV0ZXMoYXR0cmlidXRlVHlwZSk7XG5cbiAgICAvLyBBZGQgYWNjZXNzb3JzIGZvciBhbGwgcmVxdWlyZWQgYXR0cmlidXRlcyB0aGF0IGFyZSBtaXNzaW5nXG4gICAgcmVxdWlyZWRBdHRyaWJ1dGVzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBtdXRhdGVkW2tleV07XG4gICAgICBjb25zdCBpc05vdERpcmVjdGx5QWNjZXNzaWJsZSA9IHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBpc1JlcGxhY2VkQnlBc3QgPVxuICAgICAgICAodC5pc05vZGUobXV0YXRlZCkgJiYgdC5pc0V4cHJlc3Npb24obXV0YXRlZCkpIHx8XG4gICAgICAgIHQuaXNFeHByZXNzaW9uKHZhbHVlIGFzIGFueSk7XG4gICAgICBjb25zdCBpc0VtcHR5QXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDA7XG5cbiAgICAgIC8vIElmIHRoaXMgd2FzIGFscmVhZHkgcmVwbGFjZWQgYnkgYW4gQVNUIG5vZGUsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICAgIC8vIFdlIGFzc3VtZSBhbGwgZmllbGRzIGFyZSBmaWxsZWQgaW4gYnkgdGhlIEFTVFxuICAgICAgaWYgKGlzUmVwbGFjZWRCeUFzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05vdERpcmVjdGx5QWNjZXNzaWJsZSB8fCBpc0VtcHR5QXJyYXkpIHtcbiAgICAgICAgY29uc3QgZmllbGROYW1lID0gZ2V0Q29uZmlnRmllbGROYW1lKHNjb3BlLnRvcExldmVsQ29uZmlnLCBrZXkpO1xuICAgICAgICBtdXRhdGVkW2tleV0gPSB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgdC5pZGVudGlmaWVyKFwiY29uZmlnXCIpLFxuICAgICAgICAgIHQuaWRlbnRpZmllcihmaWVsZE5hbWUpXG4gICAgICAgICk7XG4gICAgICAgIHNjb3BlLnRvcExldmVsQ29uZmlnW2ZpZWxkTmFtZV0gPSBgJHtwYXRofS4ke2tleX1gO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG11dGF0ZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuXG50eXBlIEtleSA9IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXF1aXJlZEF0dHJpYnV0ZXMoXG4gIGF0dHJpYnV0ZVR5cGU6IFJldHVyblR5cGU8dHlwZW9mIGdldFR5cGVBdFBhdGg+XG4pOiBLZXlbXSB7XG4gIGlmICghYXR0cmlidXRlVHlwZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoXG4gICAgdHlwZW9mIGF0dHJpYnV0ZVR5cGUgIT09IFwib2JqZWN0XCIgfHxcbiAgICBBcnJheS5pc0FycmF5KGF0dHJpYnV0ZVR5cGUpIHx8XG4gICAgYXR0cmlidXRlVHlwZSA9PT0gbnVsbCB8fFxuICAgIGF0dHJpYnV0ZVR5cGUgPT09IHVuZGVmaW5lZCB8fFxuICAgICEoXCJibG9ja1wiIGluIGF0dHJpYnV0ZVR5cGUpXG4gICkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHJlcXVpcmVkQXR0cmlidXRlcyA9IE9iamVjdC5lbnRyaWVzKFxuICAgIGF0dHJpYnV0ZVR5cGUuYmxvY2suYXR0cmlidXRlcyB8fCB7fVxuICApLnJlZHVjZShcbiAgICAoYWNjLCBba2V5LCB2YWx1ZV0pID0+ICh2YWx1ZS5yZXF1aXJlZCA/IFsuLi5hY2MsIGtleV0gOiBhY2MpLFxuICAgIFtdIGFzIHN0cmluZ1tdXG4gICk7XG5cbiAgLy8gTG9naWMgdGFrZW4gZnJvbSAoYW5kIHNob3VsZCBiZSBzaGFyZWQgd2l0aCkgcHJvdmlkZXIgZ2VuZXJhdG9yIHJlc291cmNlIHBhcnNlcjogYXR0cmlidXRlRm9yQmxvY2tUeXBlXG4gIGNvbnN0IHJlcXVpcmVkQmxvY2tUeXBlcyA9IE9iamVjdC5lbnRyaWVzKFxuICAgIGF0dHJpYnV0ZVR5cGUuYmxvY2suYmxvY2tfdHlwZXMgfHwge31cbiAgKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUubmVzdGluZ19tb2RlID09PSBcInNpbmdsZVwiICYmXG4gICAgICAhT2JqZWN0LnZhbHVlcyh2YWx1ZS5ibG9jay5hdHRyaWJ1dGVzIHx8IHt9KS5zb21lKCh4KSA9PiAheC5yZXF1aXJlZClcbiAgICApIHtcbiAgICAgIHJldHVybiBbLi4uYWNjLCBrZXldO1xuICAgIH1cbiAgICBpZiAodmFsdWUubmVzdGluZ19tb2RlID09PSBcIm1hcFwiKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICh2YWx1ZS5uZXN0aW5nX21vZGUgPT09IFwibGlzdFwiIHx8IHZhbHVlLm5lc3RpbmdfbW9kZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgIHZhbHVlLm1pbl9pdGVtcyA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZmFsc2VcbiAgICAgICAgOiAodmFsdWUgYXMgYW55KS5taW5faXRlbXMgPiAwXG4gICAgKSB7XG4gICAgICByZXR1cm4gWy4uLmFjYywga2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSBhcyBzdHJpbmdbXSk7XG4gIHJldHVybiBbLi4ucmVxdWlyZWRBdHRyaWJ1dGVzLCAuLi5yZXF1aXJlZEJsb2NrVHlwZXNdLnNvcnQoKTtcbn1cbiJdfQ==