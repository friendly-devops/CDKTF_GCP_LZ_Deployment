"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateConfigType = exports.buildImports = exports.providerConstructImports = exports.wrapCodeInConstructor = exports.addImportForCodeContainer = exports.gen = exports.moduleImports = exports.providerImports = exports.constructsImport = exports.cdktfImport = exports.provider = exports.imports = exports.modules = exports.local = exports.variable = exports.variableTypeToAst = exports.output = exports.resource = exports.backendToExpression = exports.valueToTs = exports.attributeNameToCdktfName = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const generator_1 = __importDefault(require("@babel/generator"));
const template_1 = __importDefault(require("@babel/template"));
const t = __importStar(require("@babel/types"));
const prettier_1 = __importDefault(require("prettier"));
const utils_1 = require("./utils");
const expressions_1 = require("./expressions");
const references_1 = require("./references");
const provider_generator_1 = require("@cdktf/provider-generator");
const terraformSchema_1 = require("./terraformSchema");
const commons_1 = require("@cdktf/commons");
const hcl2json_1 = require("@cdktf/hcl2json");
const dynamic_blocks_1 = require("./dynamic-blocks");
const variables_1 = require("./variables");
const util_1 = require("cdktf/lib/util");
const partialCode_1 = require("./partialCode");
function getReference(graph, id) {
    utils_1.logger.debug(`Finding reference for ${id}`);
    const neighbors = graph.outNeighbors(id);
    if (neighbors.length > 0) {
        utils_1.logger.debug(`Found neighbors ${neighbors} for ${id}`);
        const edge = graph.directedEdge(id, neighbors[0]);
        if (edge) {
            utils_1.logger.debug(`Found first edge ${edge} for ${id}`);
            utils_1.logger.debug(`Returning reference ${graph.getEdgeAttribute(edge, "ref")}`);
            return graph.getEdgeAttribute(edge, "ref");
        }
        else {
            utils_1.logger.debug(`Found no edge for ${id}`);
            return undefined;
        }
    }
    else {
        return undefined;
    }
}
function attributeNameToCdktfName(name) {
    return (0, provider_generator_1.escapeAttributeName)((0, utils_1.camelCase)(name));
}
exports.attributeNameToCdktfName = attributeNameToCdktfName;
const valueToTs = async (scope, item, path, isModule = false) => {
    switch (typeof item) {
        case "string":
            if ((await (0, references_1.findUsedReferences)(scope.nodeIds, item)).some((ref) => path.startsWith(ref.referencee.id))) {
                return t.stringLiteral(item);
            }
            return await (0, expressions_1.convertTerraformExpressionToTs)(scope, `"${item}"`, () => (0, terraformSchema_1.getDesiredType)(scope, path));
        case "boolean":
            return await (0, expressions_1.convertTerraformExpressionToTs)(scope, `${item}`, () => (0, terraformSchema_1.getDesiredType)(scope, path));
        case "number":
            return await (0, expressions_1.convertTerraformExpressionToTs)(scope, `${item}`, () => (0, terraformSchema_1.getDesiredType)(scope, path));
        case "object":
            if (item === undefined || item === null) {
                return t.nullLiteral();
            }
            // For iterators and dynamic blocks we put the correct TS expression in the config ahead of time
            if (t.isNode(item) && t.isExpression(item)) {
                return item;
            }
            const attributeType = (0, terraformSchema_1.getTypeAtPath)(scope.providerSchema, path);
            function shouldRemoveArrayBasedOnType(attributeType) {
                if (!attributeType) {
                    return false; // The default assumption is we need the array
                }
                // maps and object don't need to be wrapped in an array
                if (Array.isArray(attributeType) &&
                    (attributeType[0] === "map" || attributeType[0] === "object")) {
                    return true;
                }
                // If it's a block type with max_items = 1 we don't need to wrap it in an array
                if (typeof attributeType === "object" &&
                    "max_items" in attributeType &&
                    attributeType.max_items === 1) {
                    return true;
                }
                return false;
            }
            const unwrappedItem = Array.isArray(item) &&
                (shouldRemoveArrayBasedOnType(attributeType) ||
                    path.endsWith("lifecycle") ||
                    path.endsWith("connection"))
                ? item[0]
                : item;
            if (Array.isArray(unwrappedItem)) {
                return t.arrayExpression(await Promise.all(unwrappedItem.map((i) => (0, exports.valueToTs)(scope, i, `${path}.[]`))));
            }
            return t.objectExpression((await Promise.all(Object.entries(unwrappedItem).map(async ([key, value]) => {
                if (value === undefined) {
                    return undefined;
                }
                if (key === "dynamic") {
                    const { for_each, ...others } = value;
                    const dynamicRef = Object.keys(others)[0];
                    return t.objectProperty(t.identifier(scope.withinOverrideExpression
                        ? dynamicRef
                        : (0, provider_generator_1.escapeAttributeName)((0, utils_1.camelCase)(dynamicRef))), t.arrayExpression());
                }
                const itemPath = `${path}.${key}`;
                const itemAttributeType = (0, terraformSchema_1.getTypeAtPath)(scope.providerSchema, itemPath);
                const typeMetadata = (0, terraformSchema_1.getTypeAtPath)(scope.providerSchema, itemPath);
                const isSingleItemBlock = typeMetadata &&
                    typeof typeMetadata === "object" &&
                    typeMetadata.hasOwnProperty("max_items")
                    ? typeMetadata.max_items === 1
                    : false;
                const shouldBeArray = typeof value === "object" &&
                    !Array.isArray(value) &&
                    !(t.isNode(value) && t.isExpression(value)) &&
                    !isSingleItemBlock &&
                    // Map type attributes must not be wrapped in arrays
                    !(0, terraformSchema_1.isMapAttribute)(itemAttributeType) &&
                    key !== "tags" &&
                    key !== "forEach" &&
                    key !== "lifecycle";
                const keepKeyName = !isModule &&
                    key !== "depends_on" &&
                    !path.includes("lifecycle") &&
                    (key === "for_each" ||
                        !typeMetadata ||
                        (0, terraformSchema_1.isMapAttribute)(attributeType)) &&
                    !(path.startsWith("var.") && path.includes("validation"));
                return t.objectProperty(t.stringLiteral(keepKeyName ? key : attributeNameToCdktfName(key)), shouldBeArray
                    ? t.arrayExpression([await (0, exports.valueToTs)(scope, value, itemPath)])
                    : await (0, exports.valueToTs)(scope, value, itemPath));
            }))).filter((expr) => expr !== undefined));
    }
    throw new Error("Unsupported type " + item);
};
exports.valueToTs = valueToTs;
async function backendToExpression(scope, tf) {
    return (await Promise.all(Object.entries(tf || {}).map(async ([type, [config]]) => {
        const backendIdentifier = (0, utils_1.pascalCase)(`${type}Backend`);
        scope.importables.push({
            constructName: backendIdentifier,
            provider: "cdktf",
        });
        return t.expressionStatement(t.newExpression(t.identifier(backendIdentifier), [
            t.thisExpression(),
            t.objectExpression((await Promise.all(Object.entries(config).map(async ([property, value]) => t.objectProperty(t.identifier((0, utils_1.camelCase)(property)), await (0, exports.valueToTs)(scope, value, "path-for-backends-can-be-ignored"))))).reduce((carry, item) => [...carry, item], [])),
        ]));
    }))).reduce((carry, item) => [...carry, item], []);
}
exports.backendToExpression = backendToExpression;
function addOverrideExpression(variable, path, value, explanatoryComment) {
    const ast = t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(variable), t.identifier("addOverride")), [t.stringLiteral(path), value]));
    if (explanatoryComment) {
        t.addComment(ast, "leading", explanatoryComment);
    }
    return ast;
}
function addOverrideLogicalIdExpression(variable, logicalId) {
    const ast = t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(variable), t.identifier("overrideLogicalId")), [t.stringLiteral(logicalId)]));
    t.addComment(ast, "leading", "This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.");
    return ast;
}
function getRemoteStateType(item) {
    const backendRecord = item.find((val) => val.backend);
    if (backendRecord) {
        const backend = backendRecord.backend;
        switch (backend) {
            case "remote":
                return "";
            case "etcdv3":
                return "_etcd_v3";
            default:
                return `_${backend}`;
        }
    }
    else {
        return "";
    }
}
function resourceType(provider, name, item) {
    switch (provider) {
        case "data.terraform":
            return `cdktf.data_terraform_${name.join("_")}${getRemoteStateType(item)}`;
        case "null":
            return `NullProvider.${name.join("_")}`;
        default:
            return `${provider}.${name.join("_")}`;
    }
}
function mapConfigPerResourceType(resource, item) {
    // Backends have a slightly different API
    if (resource.startsWith("cdktf.data_terraform_")) {
        return item.config;
    }
    return item;
}
const loopComment = `In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.`;
async function resource(scope, type, key, id, item, graph) {
    const [provider, ...name] = type.split("_");
    const resource = resourceType(provider, name, item);
    if (!provider) {
        throw new Error(`Could not parse resource type '${type}'`);
    }
    let expressions = [];
    const varName = (0, variables_1.variableName)(scope, resource, key);
    const { for_each, count, provisioner, ...config } = item[0];
    const mappedConfig = mapConfigPerResourceType(resource, config);
    let forEachIteratorName;
    if (for_each) {
        forEachIteratorName = (0, variables_1.variableName)(scope, resource, `${key}_for_each_iterator`);
        const referenceAst = await (0, expressions_1.convertTerraformExpressionToTs)(scope, `"${for_each}"`, () => ["list", "dynamic"]);
        scope.importables.push({
            provider: "cdktf",
            constructName: "TerraformIterator",
        });
        const iterator = t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier(forEachIteratorName), t.callExpression(t.memberExpression(t.identifier("TerraformIterator"), t.identifier("fromList")), [referenceAst])),
        ]);
        t.addComment(iterator, "leading", loopComment);
        expressions.push(iterator);
        mappedConfig.forEach = t.identifier(forEachIteratorName);
    }
    let countIteratorName;
    if (count) {
        countIteratorName = (0, variables_1.variableName)(scope, resource, `${key}_count`);
        const referenceAst = await (0, expressions_1.convertTerraformExpressionToTs)(scope, `"${count}"`, () => "number");
        scope.importables.push({
            provider: "cdktf",
            constructName: "TerraformCount",
        });
        const iterator = t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier(countIteratorName), t.callExpression(t.memberExpression(t.identifier("TerraformCount"), t.identifier("of")), [referenceAst])),
        ]);
        t.addComment(iterator, "leading", loopComment);
        mappedConfig.count = t.identifier(countIteratorName);
        expressions.push(iterator);
    }
    const dynBlocks = (0, dynamic_blocks_1.extractDynamicBlocks)(mappedConfig);
    const nestedDynamicBlocks = dynBlocks.filter((block) => (0, dynamic_blocks_1.isNestedDynamicBlock)(dynBlocks, block));
    const dynamicBlocksUsingOverrides = dynBlocks.filter((block) => 
    // nested blocks need overrides
    nestedDynamicBlocks.includes(block) ||
        // blocks that contain nested blocks need them as well
        nestedDynamicBlocks.some((nestedBlock) => nestedBlock.path.startsWith(block.path)));
    // all others can be handled by the CDKTF runtime
    const dynamicBlocksUsingRuntime = dynBlocks.filter((block) => !dynamicBlocksUsingOverrides.includes(block));
    for (const [i, block] of dynamicBlocksUsingRuntime.entries()) {
        const dynamicBlockIteratorName = (0, variables_1.variableName)(scope, resource, `${key}_dynamic_iterator_${i}`);
        const referenceAst = await (0, expressions_1.convertTerraformExpressionToTs)(scope, `"${block.for_each}"`, () => ["list", "dynamic"]);
        scope.importables.push({
            provider: "cdktf",
            constructName: "TerraformIterator",
        });
        const iterator = t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier(dynamicBlockIteratorName), t.callExpression(t.memberExpression(t.identifier("TerraformIterator"), t.identifier("fromList")), [referenceAst])),
        ]);
        t.addComment(iterator, "leading", loopComment);
        expressions.push(iterator);
        const dynamicCallExpression = t.callExpression(t.memberExpression(t.identifier(dynamicBlockIteratorName), t.identifier("dynamic")), [
            await (0, exports.valueToTs)({
                ...scope,
                scopedVariables: {
                    [block.scopedVar]: dynamicBlockIteratorName,
                },
            }, (0, partialCode_1.fillWithConfigAccessors)(scope, Array.isArray(block.content) ? block.content[0] : block.content, block.path.replace(block.scopedVar, "")), block.path.replace(block.scopedVar, ""), false),
        ]);
        const parts = block.path
            .replace(`dynamic.${block.scopedVar}`, "")
            .split(".")
            .filter((p) => p.length > 0);
        const parent = parts.reduce((acc, part) => {
            if (Array.isArray(acc) && !Number.isNaN(parseInt(part, 10))) {
                return acc[parseInt(part, 10)];
            }
            else {
                return acc[part];
            }
        }, mappedConfig);
        parent[block.scopedVar] = dynamicCallExpression;
        delete parent.dynamic;
    }
    const overrideReference = dynamicBlocksUsingOverrides.length
        ? {
            start: 0,
            end: 0,
            referencee: {
                id: `${type}.${key}`,
                full: `${type}.${key}`,
            },
        }
        : undefined;
    if (provisioner) {
        mappedConfig.provisioners = await Promise.all(Object.entries(provisioner).flatMap(([type, p]) => p.map((pp) => (0, exports.valueToTs)(scope, { type, ...pp }, "path-for-provisioners-can-be-ignored"))));
    }
    const importGraphId = `import.${resource.replace(".", "_")}.${key}`;
    const importDefinition = graph.hasNode(importGraphId)
        ? graph.getNodeAttribute(importGraphId, "value")
        : undefined;
    expressions = expressions.concat(await asExpression({ ...scope, forEachIteratorName, countIteratorName }, resource, key, mappedConfig, false, false, getReference(graph, id) || overrideReference, importDefinition));
    // Check for dynamic blocks
    expressions = expressions.concat(await Promise.all(dynamicBlocksUsingOverrides.map(async ({ path, for_each, content }) => {
        // We need to let the expression conversion know all available
        // dynamic block names, so we don't replace them. The "dynamic-block"
        // scoped variable indicates to the expression conversion to use the
        // key name instead of an iterator
        const scopedVariablesInPath = Object.fromEntries(path
            .substring(1) // The path starts with a dot that results in an empty split
            .split(".")
            .filter((p) => !["dynamic", "content"].includes(p) && isNaN(parseInt(p)))
            .map((p) => [p, "dynamic-block"]));
        return addOverrideExpression(varName, path.substring(1), // The path starts with a dot that we don't want
        await (0, exports.valueToTs)({
            ...scope,
            withinOverrideExpression: true,
            scopedVariables: scopedVariablesInPath,
        }, {
            for_each,
            content,
        }, "path-for-dynamic-blocks-can-be-ignored"), loopComment);
    })));
    return expressions;
}
exports.resource = resource;
async function asExpression(scope, type, name, config, isModuleImport, isProvider, reference, imported) {
    const { providers, ...otherOptions } = config;
    const constructId = (0, utils_1.uniqueId)(scope.constructs, name);
    const overrideId = !isProvider && constructId !== name;
    const completeObject = (0, partialCode_1.fillWithConfigAccessors)(scope, otherOptions, type);
    const expression = t.newExpression((0, variables_1.constructAst)(scope, type, isModuleImport), [
        t.thisExpression(),
        t.stringLiteral(constructId),
        await (0, exports.valueToTs)(scope, {
            ...completeObject,
            providers: providers && Object.keys(providers).length
                ? Object.entries(providers).map(([key, value]) => ({
                    moduleAlias: key,
                    provider: value,
                }))
                : undefined,
        }, `${type}`, isModuleImport),
    ]);
    const statements = [];
    const varName = reference
        ? (0, variables_1.referenceToVariableName)(scope, reference)
        : (0, variables_1.variableName)(scope, type, name);
    if (reference || overrideId || imported) {
        statements.push(t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier(varName), expression),
        ]));
    }
    else {
        statements.push(t.expressionStatement(expression));
    }
    if (overrideId) {
        statements.push(addOverrideLogicalIdExpression(varName, name));
    }
    if (imported) {
        // Adds myVar.importFrom("my-arn")
        const importExpression = t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(varName), t.identifier("importFrom")), [t.stringLiteral(imported.id)]));
        if (imported.provider) {
            t.addComment(importExpression, "leading", `This import was configured with a provider. CDKTF does support this, but the cdktf convert command does not yet. Please add the provider reference manually. See https://developer.hashicorp.com/terraform/cdktf/concepts/resources#importing-resources for more information.`);
        }
        statements.push(importExpression);
    }
    return statements;
}
async function output(scope, key, _id, item, _graph) {
    const [{ value, description, sensitive }] = item;
    return asExpression(scope, "cdktf.TerraformOutput", key, {
        value,
        description,
        sensitive,
    }, false, false, undefined, undefined);
}
exports.output = output;
async function variableTypeToAst(scope, type) {
    const addVariableTypeToImports = () => scope.importables.push({
        constructName: "VariableType",
        provider: "cdktf",
    });
    function parsedTypeToAst(type) {
        if (hcl2json_1.TFExpressionSyntaxTree.isScopeTraversalExpression(type)) {
            addVariableTypeToImports();
            switch (type.meta.value) {
                case "string":
                    return t.identifier("VariableType.STRING");
                case "number":
                    return t.identifier("VariableType.NUMBER");
                case "bool":
                    return t.identifier("VariableType.BOOL");
                case "any":
                default:
                    return t.identifier("VariableType.ANY");
            }
        }
        if (hcl2json_1.TFExpressionSyntaxTree.isFunctionCallExpression(type)) {
            addVariableTypeToImports();
            switch (type.meta.name) {
                case "list":
                case "set":
                case "map":
                case "tuple":
                case "object":
                    return t.callExpression(t.identifier(`VariableType.${type.meta.name}`), type.children.map((child) => parsedTypeToAst(child)));
            }
        }
        if (hcl2json_1.TFExpressionSyntaxTree.isObjectExpression(type)) {
            return t.objectExpression(Object.entries(type.meta.items).map(([key, value]) => t.objectProperty(t.stringLiteral(key), 
            // This does not deal with complex types nested within objects
            // If such a type is found it will result in an Any type
            // e.g. { foo: list(string) } will result in { foo: any }
            parsedTypeToAst({
                type: "scopeTraversal",
                meta: { value },
            }))));
        }
        addVariableTypeToImports();
        return t.identifier("VariableType.ANY");
    }
    return parsedTypeToAst(await (0, expressions_1.expressionAst)(type));
}
exports.variableTypeToAst = variableTypeToAst;
async function variable(scope, key, id, item, graph) {
    const [{ type, ...props }] = item;
    if (!getReference(graph, id)) {
        return [];
    }
    return asExpression(scope, id, key, { ...props, type: type ? await variableTypeToAst(scope, type) : undefined }, false, false, getReference(graph, id), undefined);
}
exports.variable = variable;
async function local(scope, key, id, item, graph) {
    utils_1.logger.debug(`Initializing local resource ${key} with id ${id}`);
    if (!getReference(graph, id)) {
        utils_1.logger.debug(`No reference found for ${key}`);
        return [];
    }
    return [
        t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier((0, variables_1.variableName)(scope, "local", key)), await (0, exports.valueToTs)(scope, item, "path-for-local-blocks-can-be-ignored")),
        ]),
    ];
}
exports.local = local;
async function modules(scope, key, id, item, graph) {
    const [{ source, version, ...props }] = item;
    const moduleConstraint = new provider_generator_1.TerraformModuleConstraint(source);
    return asExpression(scope, moduleConstraint.className, key, props, true, false, getReference(graph, id), undefined);
}
exports.modules = modules;
async function imports(scope, _id, item, graph) {
    // Move from ${aws_instance.example} to aws_instance.example
    const target = item.to.startsWith("${") && item.to.endsWith("}")
        ? item.to.substring(2, item.to.length - 1)
        : item.to;
    // Check if the import goes into a module
    if (target.startsWith("module.")) {
        return [
            t.addComment(t.emptyStatement(), "leading", `CDKTF does not support imports into modules yet, please remove the import block importing ${item.id} into ${target} from your configuration`),
        ];
    }
    // We now know that the import goes into a resource, e.g. aws_instance.example
    const [resourceTypeIdentifier, resourceName] = target.split(".");
    if (resourceName.includes("[")) {
        return [
            t.addComment(t.emptyStatement(), "leading", `CDKTF does not support imports into resources with count or for_each yet, please remove the import block importing ${item.id} into ${target} from your configuration`),
        ];
    }
    // Check if we have a existing resource config with the given name
    if (graph.hasNode(target)) {
        // We will handle this case in the resource function
        // so we can skip over it
        return [];
    }
    const [provider, ...resourceTypeNameParts] = resourceTypeIdentifier.split("_");
    const constructId = (0, utils_1.uniqueId)(scope.constructs, (0, utils_1.camelCase)(resourceName));
    const constructClass = (0, variables_1.constructAst)(scope, `${provider}.${resourceTypeNameParts.join("_")}`, false);
    return [
        t.expressionStatement(t.callExpression(t.memberExpression(constructClass, t.identifier("generateConfigForImport")), [
            t.thisExpression(),
            t.stringLiteral(constructId),
            t.stringLiteral(item.id),
        ])),
    ];
}
exports.imports = imports;
async function provider(scope, key, id, item, graph) {
    const { version, ...props } = item;
    const importKey = key === "null" ? "NullProvider" : key;
    return asExpression(scope, `${importKey}.${(0, utils_1.pascalCase)(key)}Provider`, key, props, false, true, getReference(graph, id), undefined);
}
exports.provider = provider;
exports.cdktfImport = (0, template_1.default)(`import * as cdktf from "cdktf"`)();
exports.constructsImport = (0, template_1.default)(`import * as constructs from "constructs"`)();
const providerImports = (providers) => providers.map((providerName) => {
    const parts = providerName.split("/");
    const name = parts.length > 1 ? parts[1] : parts[0];
    const importName = name === "null" ? "NullProvider" : name;
    return (0, template_1.default)(`import * as ${importName} from "./.gen/providers/${name.replace("./", "")}"`)();
});
exports.providerImports = providerImports;
const moduleImports = (modules) => {
    const uniqueModules = new Set();
    Object.values(modules || {}).map(([module]) => uniqueModules.add(module.source));
    const imports = [];
    uniqueModules.forEach((m) => {
        const moduleConstraint = new provider_generator_1.TerraformModuleConstraint(m);
        imports.push(template_1.default.ast(`import * as ${moduleConstraint.className} from "./.gen/modules/${moduleConstraint.fileName}"`));
    });
    return imports;
};
exports.moduleImports = moduleImports;
async function gen(statements) {
    utils_1.logger.debug(`Generating code for ${JSON.stringify(statements, null, 2)}`);
    const code = prettier_1.default.format((0, generator_1.default)(t.program(statements)).code, {
        parser: "babel",
    });
    utils_1.logger.debug(`Generated code:\n${code}`);
    return code;
}
exports.gen = gen;
function addImportForCodeContainer(scope, codeContainer) {
    switch (codeContainer) {
        case "constructs.Construct":
            scope.importables.push({
                provider: "constructs",
                constructName: "Construct",
            });
            break;
        case "cdktf.TerraformStack":
            scope.importables.push({
                provider: "cdktf",
                constructName: "TerraformStack",
            });
            break;
        default:
            throw commons_1.Errors.Internal("Unsupported code container: " + codeContainer);
    }
}
exports.addImportForCodeContainer = addImportForCodeContainer;
function wrapCodeInConstructor(codeContainer, code, className, configTypeName) {
    let baseContainerClass;
    switch (codeContainer) {
        case "constructs.Construct":
            baseContainerClass = t.identifier("Construct");
            break;
        case "cdktf.TerraformStack":
            baseContainerClass = t.identifier("TerraformStack");
            break;
        default:
            throw commons_1.Errors.Internal("Unsupported code container: " + codeContainer);
    }
    if (configTypeName) {
        return template_1.default.statement(`
  class %%className%% extends %%base%% {
    constructor(scope: Construct, name: string, config: ${configTypeName}) {
      super(scope, name);
      %%code%%
    }
  }
`, { syntacticPlaceholders: true, plugins: ["typescript"] })({
            code,
            base: baseContainerClass,
            className: t.identifier(className),
        });
    }
    return template_1.default.statement(`
  class %%className%% extends %%base%% {
    constructor(scope: Construct, name: string) {
      super(scope, name);
      %%code%%
    }
  }
`, { syntacticPlaceholders: true, plugins: ["typescript"] })({
        code,
        base: baseContainerClass,
        className: t.identifier(className),
    });
}
exports.wrapCodeInConstructor = wrapCodeInConstructor;
const providerConstructImports = (importable) => {
    let provider = importable[0].provider;
    let namespace = importable[0].namespace;
    const names = importable.map((i) => i.constructName);
    if (provider === "cdktf" || provider === "constructs") {
        return (0, template_1.default)(`import { ${names.join(", ")} } from "${provider}"`)();
    }
    if (namespace) {
        namespace = (0, util_1.snakeCase)(namespace).replace(/_/g, "-");
    }
    // Special cases to undo provider names that we override
    if (provider === "NullProvider") {
        provider = "null";
    }
    return (0, template_1.default)(`import { ${names.join(", ")} } from "./.gen/providers/${provider}/${namespace}"`)();
};
exports.providerConstructImports = providerConstructImports;
function buildImports(importables) {
    const groupedImportables = importables.reduce((acc, importable) => {
        const ns = importable.namespace || "";
        // Doing some hacky ordering of the imports to make them look a bit nicer
        const prefix = importable.provider === "constructs"
            ? "1"
            : importable.provider === "cdktf"
                ? "2"
                : "3";
        const groupName = `${prefix}.${importable.provider}.${ns}`;
        const fullName = `${importable.provider}.${ns}.${importable.constructName}`;
        if (acc[groupName]) {
            const existsAlready = acc[groupName].some((importable) => `${importable.provider}.${ns}.${importable.constructName}` ===
                fullName);
            if (existsAlready) {
                return acc;
            }
            acc[groupName].push(importable);
            acc[groupName].sort();
        }
        else {
            acc[groupName] = [importable];
        }
        return acc;
    }, {});
    let commentAdded = false;
    const constructImports = Object.keys(groupedImportables)
        .sort()
        .map((groupName) => {
        const importStatement = (0, exports.providerConstructImports)(groupedImportables[groupName]);
        if (groupName.startsWith("3.") && !commentAdded) {
            commentAdded = true;
            t.addComment(importStatement, "leading", `\n* Provider bindings are generated by running \`cdktf get\`.
* See https://cdk.tf/provider-generation for more details.\n`);
        }
        return importStatement;
    });
    return constructImports;
}
exports.buildImports = buildImports;
function generateConfigType(name, config) {
    return t.tsInterfaceDeclaration(t.identifier(name), undefined, undefined, t.tsInterfaceBody(Object.entries(config).map(([key, _value]) => t.tsPropertySignature(t.identifier(key), t.tSTypeAnnotation(t.tsAnyKeyword()) // TODO: Try to make this better than any
    ))));
}
exports.generateConfigType = generateConfigType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImdlbmVyYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DLGlFQUF3QztBQUN4QywrREFBdUM7QUFDdkMsZ0RBQWtDO0FBRWxDLHdEQUFnQztBQVNoQyxtQ0FBa0U7QUFVbEUsK0NBQThFO0FBRTlFLDZDQUFrRDtBQUNsRCxrRUFHbUM7QUFDbkMsdURBSTJCO0FBQzNCLDRDQUEwRTtBQUMxRSw4Q0FBZ0U7QUFDaEUscURBQThFO0FBQzlFLDJDQUlxQjtBQUNyQix5Q0FBMkM7QUFDM0MsK0NBQXdEO0FBRXhELFNBQVMsWUFBWSxDQUFDLEtBQW9CLEVBQUUsRUFBVTtJQUNwRCxjQUFNLENBQUMsS0FBSyxDQUFDLHlCQUF5QixFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQzVDLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7SUFFekMsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUN4QixjQUFNLENBQUMsS0FBSyxDQUFDLG1CQUFtQixTQUFTLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUN2RCxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVsRCxJQUFJLElBQUksRUFBRTtZQUNSLGNBQU0sQ0FBQyxLQUFLLENBQUMsb0JBQW9CLElBQUksUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ25ELGNBQU0sQ0FBQyxLQUFLLENBQ1YsdUJBQXVCLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FDN0QsQ0FBQztZQUNGLE9BQU8sS0FBSyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxL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QUNmLFNBQVMsRUFDVDs2REFDbUQsQ0FDcEQsQ0FBQztTQUNIO1FBQ0QsT0FBTyxlQUFlLENBQUM7SUFDekIsQ0FBQyxDQUFDLENBQUM7SUFFTCxPQUFPLGdCQUFnQixDQUFDO0FBQzFCLENBQUM7QUFwREQsb0NBb0RDO0FBRUQsU0FBZ0Isa0JBQWtCLENBQ2hDLElBQVksRUFDWixNQUFxQztJQUVyQyxPQUFPLENBQUMsQ0FBQyxzQkFBc0IsQ0FDN0IsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFDbEIsU0FBUyxFQUNULFNBQVMsRUFDVCxDQUFDLENBQUMsZUFBZSxDQUNmLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUMzQyxDQUFDLENBQUMsbUJBQW1CLENBQ25CLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQ2pCLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyx5Q0FBeUM7S0FDL0UsQ0FDRixDQUNGLENBQ0YsQ0FBQztBQUNKLENBQUM7QUFqQkQsZ0RBaUJDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluY1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcbmltcG9ydCBnZW5lcmF0ZSBmcm9tIFwiQGJhYmVsL2dlbmVyYXRvclwiO1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gXCJAYmFiZWwvdGVtcGxhdGVcIjtcbmltcG9ydCAqIGFzIHQgZnJvbSBcIkBiYWJlbC90eXBlc1wiO1xuaW1wb3J0IHsgRGlyZWN0ZWRHcmFwaCB9IGZyb20gXCJncmFwaG9sb2d5XCI7XG5pbXBvcnQgcHJldHRpZXIgZnJvbSBcInByZXR0aWVyXCI7XG5cbmltcG9ydCB7XG4gIFRlcnJhZm9ybVJlc291cmNlQmxvY2ssXG4gIFByb2dyYW1TY29wZSxcbiAgUmVzb3VyY2VTY29wZSxcbiAgSW1wb3J0YWJsZUNvbnN0cnVjdCxcbiAgQXR0cmlidXRlUGF0aCxcbn0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IGNhbWVsQ2FzZSwgbG9nZ2VyLCBwYXNjYWxDYXNlLCB1bmlxdWVJZCB9IGZyb20gXCIuL3V0aWxzXCI7XG5pbXBvcnQge1xuICBSZXNvdXJjZSxcbiAgVGVycmFmb3JtQ29uZmlnLFxuICBNb2R1bGUsXG4gIFByb3ZpZGVyLFxuICBWYXJpYWJsZSxcbiAgT3V0cHV0LFxuICBJbXBvcnQsXG59IGZyb20gXCIuL3NjaGVtYVwiO1xuaW1wb3J0IHsgY29udmVydFRlcnJhZm9ybUV4cHJlc3Npb25Ub1RzLCBleHByZXNzaW9uQXN0IH0gZnJvbSBcIi4vZXhwcmVzc2lvbnNcIjtcbmltcG9ydCB7IFJlZmVyZW5jZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBmaW5kVXNlZFJlZmVyZW5jZXMgfSBmcm9tIFwiLi9yZWZlcmVuY2VzXCI7XG5pbXBvcnQge1xuICBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50LFxuICBlc2NhcGVBdHRyaWJ1dGVOYW1lLFxufSBmcm9tIFwiQGNka3RmL3Byb3ZpZGVyLWdlbmVyYXRvclwiO1xuaW1wb3J0IHtcbiAgZ2V0VHlwZUF0UGF0aCxcbiAgaXNNYXBBdHRyaWJ1dGUsXG4gIGdldERlc2lyZWRUeXBlLFxufSBmcm9tIFwiLi90ZXJyYWZvcm1TY2hlbWFcIjtcbmltcG9ydCB7IEVycm9ycywgQXR0cmlidXRlVHlwZSwgQmxvY2tUeXBlLCBTY2hlbWEgfSBmcm9tIFwiQGNka3RmL2NvbW1vbnNcIjtcbmltcG9ydCB7IFRGRXhwcmVzc2lvblN5bnRheFRyZWUgYXMgdGV4IH0gZnJvbSBcIkBjZGt0Zi9oY2wyanNvblwiO1xuaW1wb3J0IHsgZXh0cmFjdER5bmFtaWNCbG9ja3MsIGlzTmVzdGVkRHluYW1pY0Jsb2NrIH0gZnJvbSBcIi4vZHluYW1pYy1ibG9ja3NcIjtcbmltcG9ydCB7XG4gIGNvbnN0cnVjdEFzdCxcbiAgcmVmZXJlbmNlVG9WYXJpYWJsZU5hbWUsXG4gIHZhcmlhYmxlTmFtZSxcbn0gZnJvbSBcIi4vdmFyaWFibGVzXCI7XG5pbXBvcnQgeyBzbmFrZUNhc2UgfSBmcm9tIFwiY2RrdGYvbGliL3V0aWxcIjtcbmltcG9ydCB7IGZpbGxXaXRoQ29uZmlnQWNjZXNzb3JzIH0gZnJvbSBcIi4vcGFydGlhbENvZGVcIjtcblxuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlKGdyYXBoOiBEaXJlY3RlZEdyYXBoLCBpZDogc3RyaW5nKSB7XG4gIGxvZ2dlci5kZWJ1ZyhgRmluZGluZyByZWZlcmVuY2UgZm9yICR7aWR9YCk7XG4gIGNvbnN0IG5laWdoYm9ycyA9IGdyYXBoLm91dE5laWdoYm9ycyhpZCk7XG5cbiAgaWYgKG5laWdoYm9ycy5sZW5ndGggPiAwKSB7XG4gICAgbG9nZ2VyLmRlYnVnKGBGb3VuZCBuZWlnaGJvcnMgJHtuZWlnaGJvcnN9IGZvciAke2lkfWApO1xuICAgIGNvbnN0IGVkZ2UgPSBncmFwaC5kaXJlY3RlZEVkZ2UoaWQsIG5laWdoYm9yc1swXSk7XG5cbiAgICBpZiAoZWRnZSkge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBGb3VuZCBmaXJzdCBlZGdlICR7ZWRnZX0gZm9yICR7aWR9YCk7XG4gICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgIGBSZXR1cm5pbmcgcmVmZXJlbmNlICR7Z3JhcGguZ2V0RWRnZUF0dHJpYnV0ZShlZGdlLCBcInJlZlwiKX1gXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdyYXBoLmdldEVkZ2VBdHRyaWJ1dGUoZWRnZSwgXCJyZWZcIikgYXMgUmVmZXJlbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIuZGVidWcoYEZvdW5kIG5vIGVkZ2UgZm9yICR7aWR9YCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhdHRyaWJ1dGVOYW1lVG9DZGt0Zk5hbWUobmFtZTogc3RyaW5nKSB7XG4gIHJldHVybiBlc2NhcGVBdHRyaWJ1dGVOYW1lKGNhbWVsQ2FzZShuYW1lKSk7XG59XG5cbmV4cG9ydCBjb25zdCB2YWx1ZVRvVHMgPSBhc3luYyAoXG4gIHNjb3BlOiBSZXNvdXJjZVNjb3BlLFxuICBpdGVtOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrLFxuICBwYXRoOiBzdHJpbmcsXG4gIGlzTW9kdWxlID0gZmFsc2Vcbik6IFByb21pc2U8dC5FeHByZXNzaW9uPiA9PiB7XG4gIHN3aXRjaCAodHlwZW9mIGl0ZW0pIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBpZiAoXG4gICAgICAgIChhd2FpdCBmaW5kVXNlZFJlZmVyZW5jZXMoc2NvcGUubm9kZUlkcywgaXRlbSkpLnNvbWUoKHJlZikgPT5cbiAgICAgICAgICBwYXRoLnN0YXJ0c1dpdGgocmVmLnJlZmVyZW5jZWUuaWQpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdC5zdHJpbmdMaXRlcmFsKGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgY29udmVydFRlcnJhZm9ybUV4cHJlc3Npb25Ub1RzKHNjb3BlLCBgXCIke2l0ZW19XCJgLCAoKSA9PlxuICAgICAgICBnZXREZXNpcmVkVHlwZShzY29wZSwgcGF0aClcbiAgICAgICk7XG5cbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIGF3YWl0IGNvbnZlcnRUZXJyYWZvcm1FeHByZXNzaW9uVG9UcyhzY29wZSwgYCR7aXRlbX1gLCAoKSA9PlxuICAgICAgICBnZXREZXNpcmVkVHlwZShzY29wZSwgcGF0aClcbiAgICAgICk7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIGF3YWl0IGNvbnZlcnRUZXJyYWZvcm1FeHByZXNzaW9uVG9UcyhzY29wZSwgYCR7aXRlbX1gLCAoKSA9PlxuICAgICAgICBnZXREZXNpcmVkVHlwZShzY29wZSwgcGF0aClcbiAgICAgICk7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0Lm51bGxMaXRlcmFsKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBpdGVyYXRvcnMgYW5kIGR5bmFtaWMgYmxvY2tzIHdlIHB1dCB0aGUgY29ycmVjdCBUUyBleHByZXNzaW9uIGluIHRoZSBjb25maWcgYWhlYWQgb2YgdGltZVxuICAgICAgaWYgKHQuaXNOb2RlKGl0ZW0pICYmIHQuaXNFeHByZXNzaW9uKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRyaWJ1dGVUeXBlID0gZ2V0VHlwZUF0UGF0aChzY29wZS5wcm92aWRlclNjaGVtYSwgcGF0aCk7XG5cbiAgICAgIGZ1bmN0aW9uIHNob3VsZFJlbW92ZUFycmF5QmFzZWRPblR5cGUoXG4gICAgICAgIGF0dHJpYnV0ZVR5cGU6IFNjaGVtYSB8IEF0dHJpYnV0ZVR5cGUgfCBCbG9ja1R5cGUgfCBudWxsXG4gICAgICApOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBUaGUgZGVmYXVsdCBhc3N1bXB0aW9uIGlzIHdlIG5lZWQgdGhlIGFycmF5XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXBzIGFuZCBvYmplY3QgZG9uJ3QgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgICAgIGlmIChcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGF0dHJpYnV0ZVR5cGUpICYmXG4gICAgICAgICAgKGF0dHJpYnV0ZVR5cGVbMF0gPT09IFwibWFwXCIgfHwgYXR0cmlidXRlVHlwZVswXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCdzIGEgYmxvY2sgdHlwZSB3aXRoIG1heF9pdGVtcyA9IDEgd2UgZG9uJ3QgbmVlZCB0byB3cmFwIGl0IGluIGFuIGFycmF5XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlb2YgYXR0cmlidXRlVHlwZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgIFwibWF4X2l0ZW1zXCIgaW4gYXR0cmlidXRlVHlwZSAmJlxuICAgICAgICAgIGF0dHJpYnV0ZVR5cGUubWF4X2l0ZW1zID09PSAxXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1bndyYXBwZWRJdGVtID1cbiAgICAgICAgQXJyYXkuaXNBcnJheShpdGVtKSAmJlxuICAgICAgICAoc2hvdWxkUmVtb3ZlQXJyYXlCYXNlZE9uVHlwZShhdHRyaWJ1dGVUeXBlKSB8fFxuICAgICAgICAgIHBhdGguZW5kc1dpdGgoXCJsaWZlY3ljbGVcIikgfHxcbiAgICAgICAgICBwYXRoLmVuZHNXaXRoKFwiY29ubmVjdGlvblwiKSlcbiAgICAgICAgICA/IGl0ZW1bMF1cbiAgICAgICAgICA6IGl0ZW07XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHVud3JhcHBlZEl0ZW0pKSB7XG4gICAgICAgIHJldHVybiB0LmFycmF5RXhwcmVzc2lvbihcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIHVud3JhcHBlZEl0ZW0ubWFwKChpKSA9PiB2YWx1ZVRvVHMoc2NvcGUsIGksIGAke3BhdGh9LltdYCkpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdC5vYmplY3RFeHByZXNzaW9uKFxuICAgICAgICAoXG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh1bndyYXBwZWRJdGVtKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcImR5bmFtaWNcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZm9yX2VhY2gsIC4uLm90aGVycyB9ID0gdmFsdWUgYXMgYW55O1xuICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNSZWYgPSBPYmplY3Qua2V5cyhvdGhlcnMpWzBdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0Lm9iamVjdFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgdC5pZGVudGlmaWVyKFxuICAgICAgICAgICAgICAgICAgICBzY29wZS53aXRoaW5PdmVycmlkZUV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICA/IGR5bmFtaWNSZWZcbiAgICAgICAgICAgICAgICAgICAgICA6IGVzY2FwZUF0dHJpYnV0ZU5hbWUoY2FtZWxDYXNlKGR5bmFtaWNSZWYpKVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHQuYXJyYXlFeHByZXNzaW9uKClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgaXRlbVBhdGggPSBgJHtwYXRofS4ke2tleX1gO1xuICAgICAgICAgICAgICBjb25zdCBpdGVtQXR0cmlidXRlVHlwZSA9IGdldFR5cGVBdFBhdGgoXG4gICAgICAgICAgICAgICAgc2NvcGUucHJvdmlkZXJTY2hlbWEsXG4gICAgICAgICAgICAgICAgaXRlbVBhdGhcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBjb25zdCB0eXBlTWV0YWRhdGEgPSBnZXRUeXBlQXRQYXRoKFxuICAgICAgICAgICAgICAgIHNjb3BlLnByb3ZpZGVyU2NoZW1hLFxuICAgICAgICAgICAgICAgIGl0ZW1QYXRoXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgY29uc3QgaXNTaW5nbGVJdGVtQmxvY2sgPVxuICAgICAgICAgICAgICAgIHR5cGVNZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0eXBlTWV0YWRhdGEgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlTWV0YWRhdGEuaGFzT3duUHJvcGVydHkoXCJtYXhfaXRlbXNcIilcbiAgICAgICAgICAgICAgICAgID8gKHR5cGVNZXRhZGF0YSBhcyBhbnkpLm1heF9pdGVtcyA9PT0gMVxuICAgICAgICAgICAgICAgICAgOiBmYWxzZTtcblxuICAgICAgICAgICAgICBjb25zdCBzaG91bGRCZUFycmF5ID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAhKHQuaXNOb2RlKHZhbHVlKSAmJiB0LmlzRXhwcmVzc2lvbih2YWx1ZSkpICYmXG4gICAgICAgICAgICAgICAgIWlzU2luZ2xlSXRlbUJsb2NrICYmXG4gICAgICAgICAgICAgICAgLy8gTWFwIHR5cGUgYXR0cmlidXRlcyBtdXN0IG5vdCBiZSB3cmFwcGVkIGluIGFycmF5c1xuICAgICAgICAgICAgICAgICFpc01hcEF0dHJpYnV0ZShpdGVtQXR0cmlidXRlVHlwZSkgJiZcbiAgICAgICAgICAgICAgICBrZXkgIT09IFwidGFnc1wiICYmXG4gICAgICAgICAgICAgICAga2V5ICE9PSBcImZvckVhY2hcIiAmJlxuICAgICAgICAgICAgICAgIGtleSAhPT0gXCJsaWZlY3ljbGVcIjtcblxuICAgICAgICAgICAgICBjb25zdCBrZWVwS2V5TmFtZTogYm9vbGVhbiA9XG4gICAgICAgICAgICAgICAgIWlzTW9kdWxlICYmXG4gICAgICAgICAgICAgICAga2V5ICE9PSBcImRlcGVuZHNfb25cIiAmJlxuICAgICAgICAgICAgICAgICFwYXRoLmluY2x1ZGVzKFwibGlmZWN5Y2xlXCIpICYmXG4gICAgICAgICAgICAgICAgKGtleSA9PT0gXCJmb3JfZWFjaFwiIHx8XG4gICAgICAgICAgICAgICAgICAhdHlwZU1ldGFkYXRhIHx8XG4gICAgICAgICAgICAgICAgICBpc01hcEF0dHJpYnV0ZShhdHRyaWJ1dGVUeXBlKSkgJiZcbiAgICAgICAgICAgICAgICAhKHBhdGguc3RhcnRzV2l0aChcInZhci5cIikgJiYgcGF0aC5pbmNsdWRlcyhcInZhbGlkYXRpb25cIikpO1xuXG4gICAgICAgICAgICAgIHJldHVybiB0Lm9iamVjdFByb3BlcnR5KFxuICAgICAgICAgICAgICAgIHQuc3RyaW5nTGl0ZXJhbChcbiAgICAgICAgICAgICAgICAgIGtlZXBLZXlOYW1lID8ga2V5IDogYXR0cmlidXRlTmFtZVRvQ2RrdGZOYW1lKGtleSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHNob3VsZEJlQXJyYXlcbiAgICAgICAgICAgICAgICAgID8gdC5hcnJheUV4cHJlc3Npb24oW2F3YWl0IHZhbHVlVG9UcyhzY29wZSwgdmFsdWUsIGl0ZW1QYXRoKV0pXG4gICAgICAgICAgICAgICAgICA6IGF3YWl0IHZhbHVlVG9UcyhzY29wZSwgdmFsdWUsIGl0ZW1QYXRoKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICkuZmlsdGVyKChleHByKSA9PiBleHByICE9PSB1bmRlZmluZWQpIGFzIHQuT2JqZWN0UHJvcGVydHlbXVxuICAgICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIFwiICsgaXRlbSk7XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYmFja2VuZFRvRXhwcmVzc2lvbihcbiAgc2NvcGU6IFByb2dyYW1TY29wZSxcbiAgdGY6IFRlcnJhZm9ybUNvbmZpZ1tcImJhY2tlbmRcIl1cbik6IFByb21pc2U8dC5TdGF0ZW1lbnRbXT4ge1xuICByZXR1cm4gKFxuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgT2JqZWN0LmVudHJpZXModGYgfHwge30pLm1hcChhc3luYyAoW3R5cGUsIFtjb25maWddXSkgPT4ge1xuICAgICAgICBjb25zdCBiYWNrZW5kSWRlbnRpZmllciA9IHBhc2NhbENhc2UoYCR7dHlwZX1CYWNrZW5kYCk7XG4gICAgICAgIHNjb3BlLmltcG9ydGFibGVzLnB1c2goe1xuICAgICAgICAgIGNvbnN0cnVjdE5hbWU6IGJhY2tlbmRJZGVudGlmaWVyLFxuICAgICAgICAgIHByb3ZpZGVyOiBcImNka3RmXCIsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdC5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgICAgICAgIHQubmV3RXhwcmVzc2lvbih0LmlkZW50aWZpZXIoYmFja2VuZElkZW50aWZpZXIpLCBbXG4gICAgICAgICAgICB0LnRoaXNFeHByZXNzaW9uKCksXG4gICAgICAgICAgICB0Lm9iamVjdEV4cHJlc3Npb24oXG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykubWFwKGFzeW5jIChbcHJvcGVydHksIHZhbHVlXSkgPT5cbiAgICAgICAgICAgICAgICAgICAgdC5vYmplY3RQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICB0LmlkZW50aWZpZXIoY2FtZWxDYXNlKHByb3BlcnR5KSksXG4gICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdmFsdWVUb1RzKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicGF0aC1mb3ItYmFja2VuZHMtY2FuLWJlLWlnbm9yZWRcIlxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKS5yZWR1Y2UoXG4gICAgICAgICAgICAgICAgKGNhcnJ5LCBpdGVtKSA9PiBbLi4uY2FycnksIGl0ZW1dLFxuICAgICAgICAgICAgICAgIFtdIGFzIHQuT2JqZWN0UHJvcGVydHlbXVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgIF0pXG4gICAgICAgICk7XG4gICAgICB9KVxuICAgIClcbiAgKS5yZWR1Y2UoKGNhcnJ5LCBpdGVtKSA9PiBbLi4uY2FycnksIGl0ZW1dLCBbXSBhcyB0LlN0YXRlbWVudFtdKTtcbn1cblxuZnVuY3Rpb24gYWRkT3ZlcnJpZGVFeHByZXNzaW9uKFxuICB2YXJpYWJsZTogc3RyaW5nLFxuICBwYXRoOiBzdHJpbmcsXG4gIHZhbHVlOiB0LkV4cHJlc3Npb24sXG4gIGV4cGxhbmF0b3J5Q29tbWVudD86IHN0cmluZ1xuKSB7XG4gIGNvbnN0IGFzdCA9IHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKHQuaWRlbnRpZmllcih2YXJpYWJsZSksIHQuaWRlbnRpZmllcihcImFkZE92ZXJyaWRlXCIpKSxcbiAgICAgIFt0LnN0cmluZ0xpdGVyYWwocGF0aCksIHZhbHVlXVxuICAgIClcbiAgKTtcblxuICBpZiAoZXhwbGFuYXRvcnlDb21tZW50KSB7XG4gICAgdC5hZGRDb21tZW50KGFzdCwgXCJsZWFkaW5nXCIsIGV4cGxhbmF0b3J5Q29tbWVudCk7XG4gIH1cblxuICByZXR1cm4gYXN0O1xufVxuXG5mdW5jdGlvbiBhZGRPdmVycmlkZUxvZ2ljYWxJZEV4cHJlc3Npb24odmFyaWFibGU6IHN0cmluZywgbG9naWNhbElkOiBzdHJpbmcpIHtcbiAgY29uc3QgYXN0ID0gdC5leHByZXNzaW9uU3RhdGVtZW50KFxuICAgIHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgIHQuaWRlbnRpZmllcih2YXJpYWJsZSksXG4gICAgICAgIHQuaWRlbnRpZmllcihcIm92ZXJyaWRlTG9naWNhbElkXCIpXG4gICAgICApLFxuICAgICAgW3Quc3RyaW5nTGl0ZXJhbChsb2dpY2FsSWQpXVxuICAgIClcbiAgKTtcblxuICB0LmFkZENvbW1lbnQoXG4gICAgYXN0LFxuICAgIFwibGVhZGluZ1wiLFxuICAgIFwiVGhpcyBhbGxvd3MgdGhlIFRlcnJhZm9ybSByZXNvdXJjZSBuYW1lIHRvIG1hdGNoIHRoZSBvcmlnaW5hbCBuYW1lLiBZb3UgY2FuIHJlbW92ZSB0aGUgY2FsbCBpZiB5b3UgZG9uJ3QgbmVlZCB0aGVtIHRvIG1hdGNoLlwiXG4gICk7XG5cbiAgcmV0dXJuIGFzdDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVtb3RlU3RhdGVUeXBlKGl0ZW06IFJlc291cmNlKSB7XG4gIGNvbnN0IGJhY2tlbmRSZWNvcmQgPSBpdGVtLmZpbmQoKHZhbCkgPT4gdmFsLmJhY2tlbmQpO1xuICBpZiAoYmFja2VuZFJlY29yZCkge1xuICAgIGNvbnN0IGJhY2tlbmQgPSBiYWNrZW5kUmVjb3JkLmJhY2tlbmQ7XG4gICAgc3dpdGNoIChiYWNrZW5kKSB7XG4gICAgICBjYXNlIFwicmVtb3RlXCI6XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgY2FzZSBcImV0Y2R2M1wiOlxuICAgICAgICByZXR1cm4gXCJfZXRjZF92M1wiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGBfJHtiYWNrZW5kfWA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc291cmNlVHlwZShwcm92aWRlcjogc3RyaW5nLCBuYW1lOiBzdHJpbmdbXSwgaXRlbTogUmVzb3VyY2UpIHtcbiAgc3dpdGNoIChwcm92aWRlcikge1xuICAgIGNhc2UgXCJkYXRhLnRlcnJhZm9ybVwiOlxuICAgICAgcmV0dXJuIGBjZGt0Zi5kYXRhX3RlcnJhZm9ybV8ke25hbWUuam9pbihcIl9cIil9JHtnZXRSZW1vdGVTdGF0ZVR5cGUoXG4gICAgICAgIGl0ZW1cbiAgICAgICl9YDtcbiAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgcmV0dXJuIGBOdWxsUHJvdmlkZXIuJHtuYW1lLmpvaW4oXCJfXCIpfWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBgJHtwcm92aWRlcn0uJHtuYW1lLmpvaW4oXCJfXCIpfWA7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwQ29uZmlnUGVyUmVzb3VyY2VUeXBlKHJlc291cmNlOiBzdHJpbmcsIGl0ZW06IFJlc291cmNlWzBdKSB7XG4gIC8vIEJhY2tlbmRzIGhhdmUgYSBzbGlnaHRseSBkaWZmZXJlbnQgQVBJXG4gIGlmIChyZXNvdXJjZS5zdGFydHNXaXRoKFwiY2RrdGYuZGF0YV90ZXJyYWZvcm1fXCIpKSB7XG4gICAgcmV0dXJuIGl0ZW0uY29uZmlnO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5jb25zdCBsb29wQ29tbWVudCA9IGBJbiBtb3N0IGNhc2VzIGxvb3BzIHNob3VsZCBiZSBoYW5kbGVkIGluIHRoZSBwcm9ncmFtbWluZyBsYW5ndWFnZSBjb250ZXh0IGFuZCBcbm5vdCBpbnNpZGUgb2YgdGhlIFRlcnJhZm9ybSBjb250ZXh0LiBJZiB5b3UgYXJlIGxvb3Bpbmcgb3ZlciBzb21ldGhpbmcgZXh0ZXJuYWwsIGUuZy4gYSB2YXJpYWJsZSBvciBhIGZpbGUgaW5wdXRcbnlvdSBzaG91bGQgY29uc2lkZXIgdXNpbmcgYSBmb3IgbG9vcC4gSWYgeW91IGFyZSBsb29waW5nIG92ZXIgc29tZXRoaW5nIG9ubHkga25vd24gdG8gVGVycmFmb3JtLCBlLmcuIGEgcmVzdWx0IG9mIGEgZGF0YSBzb3VyY2VcbnlvdSBuZWVkIHRvIGtlZXAgdGhpcyBsaWtlIGl0IGlzLmA7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb3VyY2UoXG4gIHNjb3BlOiBQcm9ncmFtU2NvcGUsXG4gIHR5cGU6IHN0cmluZyxcbiAga2V5OiBzdHJpbmcsXG4gIGlkOiBzdHJpbmcsXG4gIGl0ZW06IFJlc291cmNlLFxuICBncmFwaDogRGlyZWN0ZWRHcmFwaFxuKTogUHJvbWlzZTx0LlN0YXRlbWVudFtdPiB7XG4gIGNvbnN0IFtwcm92aWRlciwgLi4ubmFtZV0gPSB0eXBlLnNwbGl0KFwiX1wiKTtcbiAgY29uc3QgcmVzb3VyY2UgPSByZXNvdXJjZVR5cGUocHJvdmlkZXIsIG5hbWUsIGl0ZW0pO1xuXG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSByZXNvdXJjZSB0eXBlICcke3R5cGV9J2ApO1xuICB9XG4gIGxldCBleHByZXNzaW9uczogdC5TdGF0ZW1lbnRbXSA9IFtdO1xuICBjb25zdCB2YXJOYW1lID0gdmFyaWFibGVOYW1lKHNjb3BlLCByZXNvdXJjZSwga2V5KTtcbiAgY29uc3QgeyBmb3JfZWFjaCwgY291bnQsIHByb3Zpc2lvbmVyLCAuLi5jb25maWcgfSA9IGl0ZW1bMF07XG4gIGNvbnN0IG1hcHBlZENvbmZpZyA9IG1hcENvbmZpZ1BlclJlc291cmNlVHlwZShyZXNvdXJjZSwgY29uZmlnKTtcblxuICBsZXQgZm9yRWFjaEl0ZXJhdG9yTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBpZiAoZm9yX2VhY2gpIHtcbiAgICBmb3JFYWNoSXRlcmF0b3JOYW1lID0gdmFyaWFibGVOYW1lKFxuICAgICAgc2NvcGUsXG4gICAgICByZXNvdXJjZSxcbiAgICAgIGAke2tleX1fZm9yX2VhY2hfaXRlcmF0b3JgXG4gICAgKTtcbiAgICBjb25zdCByZWZlcmVuY2VBc3QgPSBhd2FpdCBjb252ZXJ0VGVycmFmb3JtRXhwcmVzc2lvblRvVHMoXG4gICAgICBzY29wZSxcbiAgICAgIGBcIiR7Zm9yX2VhY2h9XCJgLFxuICAgICAgKCkgPT4gW1wibGlzdFwiLCBcImR5bmFtaWNcIl1cbiAgICApO1xuXG4gICAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgICBwcm92aWRlcjogXCJjZGt0ZlwiLFxuICAgICAgY29uc3RydWN0TmFtZTogXCJUZXJyYWZvcm1JdGVyYXRvclwiLFxuICAgIH0pO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJjb25zdFwiLCBbXG4gICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihcbiAgICAgICAgdC5pZGVudGlmaWVyKGZvckVhY2hJdGVyYXRvck5hbWUpLFxuICAgICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICAgIHQuaWRlbnRpZmllcihcIlRlcnJhZm9ybUl0ZXJhdG9yXCIpLFxuICAgICAgICAgICAgdC5pZGVudGlmaWVyKFwiZnJvbUxpc3RcIilcbiAgICAgICAgICApLFxuXG4gICAgICAgICAgW3JlZmVyZW5jZUFzdF1cbiAgICAgICAgKVxuICAgICAgKSxcbiAgICBdKTtcbiAgICB0LmFkZENvbW1lbnQoaXRlcmF0b3IsIFwibGVhZGluZ1wiLCBsb29wQ29tbWVudCk7XG4gICAgZXhwcmVzc2lvbnMucHVzaChpdGVyYXRvcik7XG5cbiAgICBtYXBwZWRDb25maWcuZm9yRWFjaCA9IHQuaWRlbnRpZmllcihmb3JFYWNoSXRlcmF0b3JOYW1lKTtcbiAgfVxuXG4gIGxldCBjb3VudEl0ZXJhdG9yTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBpZiAoY291bnQpIHtcbiAgICBjb3VudEl0ZXJhdG9yTmFtZSA9IHZhcmlhYmxlTmFtZShzY29wZSwgcmVzb3VyY2UsIGAke2tleX1fY291bnRgKTtcbiAgICBjb25zdCByZWZlcmVuY2VBc3QgPSBhd2FpdCBjb252ZXJ0VGVycmFmb3JtRXhwcmVzc2lvblRvVHMoXG4gICAgICBzY29wZSxcbiAgICAgIGBcIiR7Y291bnR9XCJgLFxuICAgICAgKCkgPT4gXCJudW1iZXJcIlxuICAgICk7XG5cbiAgICBzY29wZS5pbXBvcnRhYmxlcy5wdXNoKHtcbiAgICAgIHByb3ZpZGVyOiBcImNka3RmXCIsXG4gICAgICBjb25zdHJ1Y3ROYW1lOiBcIlRlcnJhZm9ybUNvdW50XCIsXG4gICAgfSk7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHQudmFyaWFibGVEZWNsYXJhdGlvbihcImNvbnN0XCIsIFtcbiAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKFxuICAgICAgICB0LmlkZW50aWZpZXIoY291bnRJdGVyYXRvck5hbWUpLFxuICAgICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgICAgIHQuaWRlbnRpZmllcihcIlRlcnJhZm9ybUNvdW50XCIpLFxuICAgICAgICAgICAgdC5pZGVudGlmaWVyKFwib2ZcIilcbiAgICAgICAgICApLFxuICAgICAgICAgIFtyZWZlcmVuY2VBc3RdXG4gICAgICAgIClcbiAgICAgICksXG4gICAgXSk7XG4gICAgdC5hZGRDb21tZW50KGl0ZXJhdG9yLCBcImxlYWRpbmdcIiwgbG9vcENvbW1lbnQpO1xuICAgIG1hcHBlZENvbmZpZy5jb3VudCA9IHQuaWRlbnRpZmllcihjb3VudEl0ZXJhdG9yTmFtZSk7XG4gICAgZXhwcmVzc2lvbnMucHVzaChpdGVyYXRvcik7XG4gIH1cblxuICBjb25zdCBkeW5CbG9ja3MgPSBleHRyYWN0RHluYW1pY0Jsb2NrcyhtYXBwZWRDb25maWcpO1xuICBjb25zdCBuZXN0ZWREeW5hbWljQmxvY2tzID0gZHluQmxvY2tzLmZpbHRlcigoYmxvY2spID0+XG4gICAgaXNOZXN0ZWREeW5hbWljQmxvY2soZHluQmxvY2tzLCBibG9jaylcbiAgKTtcbiAgY29uc3QgZHluYW1pY0Jsb2Nrc1VzaW5nT3ZlcnJpZGVzID0gZHluQmxvY2tzLmZpbHRlcihcbiAgICAoYmxvY2spID0+XG4gICAgICAvLyBuZXN0ZWQgYmxvY2tzIG5lZWQgb3ZlcnJpZGVzXG4gICAgICBuZXN0ZWREeW5hbWljQmxvY2tzLmluY2x1ZGVzKGJsb2NrKSB8fFxuICAgICAgLy8gYmxvY2tzIHRoYXQgY29udGFpbiBuZXN0ZWQgYmxvY2tzIG5lZWQgdGhlbSBhcyB3ZWxsXG4gICAgICBuZXN0ZWREeW5hbWljQmxvY2tzLnNvbWUoKG5lc3RlZEJsb2NrKSA9PlxuICAgICAgICBuZXN0ZWRCbG9jay5wYXRoLnN0YXJ0c1dpdGgoYmxvY2sucGF0aClcbiAgICAgIClcbiAgKTtcbiAgLy8gYWxsIG90aGVycyBjYW4gYmUgaGFuZGxlZCBieSB0aGUgQ0RLVEYgcnVudGltZVxuICBjb25zdCBkeW5hbWljQmxvY2tzVXNpbmdSdW50aW1lID0gZHluQmxvY2tzLmZpbHRlcihcbiAgICAoYmxvY2spID0+ICFkeW5hbWljQmxvY2tzVXNpbmdPdmVycmlkZXMuaW5jbHVkZXMoYmxvY2spXG4gICk7XG5cbiAgZm9yIChjb25zdCBbaSwgYmxvY2tdIG9mIGR5bmFtaWNCbG9ja3NVc2luZ1J1bnRpbWUuZW50cmllcygpKSB7XG4gICAgY29uc3QgZHluYW1pY0Jsb2NrSXRlcmF0b3JOYW1lID0gdmFyaWFibGVOYW1lKFxuICAgICAgc2NvcGUsXG4gICAgICByZXNvdXJjZSxcbiAgICAgIGAke2tleX1fZHluYW1pY19pdGVyYXRvcl8ke2l9YFxuICAgICk7XG5cbiAgICBjb25zdCByZWZlcmVuY2VBc3QgPSBhd2FpdCBjb252ZXJ0VGVycmFmb3JtRXhwcmVzc2lvblRvVHMoXG4gICAgICBzY29wZSxcbiAgICAgIGBcIiR7YmxvY2suZm9yX2VhY2h9XCJgLFxuICAgICAgKCkgPT4gW1wibGlzdFwiLCBcImR5bmFtaWNcIl1cbiAgICApO1xuXG4gICAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgICBwcm92aWRlcjogXCJjZGt0ZlwiLFxuICAgICAgY29uc3RydWN0TmFtZTogXCJUZXJyYWZvcm1JdGVyYXRvclwiLFxuICAgIH0pO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJjb25zdFwiLCBbXG4gICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcihcbiAgICAgICAgdC5pZGVudGlmaWVyKGR5bmFtaWNCbG9ja0l0ZXJhdG9yTmFtZSksXG4gICAgICAgIHQuY2FsbEV4cHJlc3Npb24oXG4gICAgICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICAgICAgdC5pZGVudGlmaWVyKFwiVGVycmFmb3JtSXRlcmF0b3JcIiksXG4gICAgICAgICAgICB0LmlkZW50aWZpZXIoXCJmcm9tTGlzdFwiKVxuICAgICAgICAgICksXG4gICAgICAgICAgW3JlZmVyZW5jZUFzdF1cbiAgICAgICAgKVxuICAgICAgKSxcbiAgICBdKTtcbiAgICB0LmFkZENvbW1lbnQoaXRlcmF0b3IsIFwibGVhZGluZ1wiLCBsb29wQ29tbWVudCk7XG4gICAgZXhwcmVzc2lvbnMucHVzaChpdGVyYXRvcik7XG4gICAgY29uc3QgZHluYW1pY0NhbGxFeHByZXNzaW9uID0gdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgIHQubWVtYmVyRXhwcmVzc2lvbihcbiAgICAgICAgdC5pZGVudGlmaWVyKGR5bmFtaWNCbG9ja0l0ZXJhdG9yTmFtZSksXG4gICAgICAgIHQuaWRlbnRpZmllcihcImR5bmFtaWNcIilcbiAgICAgICksXG4gICAgICBbXG4gICAgICAgIGF3YWl0IHZhbHVlVG9UcyhcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5zY29wZSxcbiAgICAgICAgICAgIHNjb3BlZFZhcmlhYmxlczoge1xuICAgICAgICAgICAgICBbYmxvY2suc2NvcGVkVmFyXTogZHluYW1pY0Jsb2NrSXRlcmF0b3JOYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbGxXaXRoQ29uZmlnQWNjZXNzb3JzKFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGJsb2NrLmNvbnRlbnQpID8gYmxvY2suY29udGVudFswXSA6IGJsb2NrLmNvbnRlbnQsXG4gICAgICAgICAgICBibG9jay5wYXRoLnJlcGxhY2UoYmxvY2suc2NvcGVkVmFyLCBcIlwiKVxuICAgICAgICAgICksXG4gICAgICAgICAgYmxvY2sucGF0aC5yZXBsYWNlKGJsb2NrLnNjb3BlZFZhciwgXCJcIiksXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKSxcbiAgICAgIF1cbiAgICApO1xuXG4gICAgY29uc3QgcGFydHMgPSBibG9jay5wYXRoXG4gICAgICAucmVwbGFjZShgZHluYW1pYy4ke2Jsb2NrLnNjb3BlZFZhcn1gLCBcIlwiKVxuICAgICAgLnNwbGl0KFwiLlwiKVxuICAgICAgLmZpbHRlcigocCkgPT4gcC5sZW5ndGggPiAwKTtcblxuICAgIGNvbnN0IHBhcmVudCA9IHBhcnRzLnJlZHVjZSgoYWNjLCBwYXJ0KSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhY2MpICYmICFOdW1iZXIuaXNOYU4ocGFyc2VJbnQocGFydCwgMTApKSkge1xuICAgICAgICByZXR1cm4gYWNjW3BhcnNlSW50KHBhcnQsIDEwKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYWNjW3BhcnRdO1xuICAgICAgfVxuICAgIH0sIG1hcHBlZENvbmZpZyk7XG4gICAgcGFyZW50W2Jsb2NrLnNjb3BlZFZhcl0gPSBkeW5hbWljQ2FsbEV4cHJlc3Npb247XG4gICAgZGVsZXRlIHBhcmVudC5keW5hbWljO1xuICB9XG5cbiAgY29uc3Qgb3ZlcnJpZGVSZWZlcmVuY2UgPSBkeW5hbWljQmxvY2tzVXNpbmdPdmVycmlkZXMubGVuZ3RoXG4gICAgPyB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IDAsXG4gICAgICAgIHJlZmVyZW5jZWU6IHtcbiAgICAgICAgICBpZDogYCR7dHlwZX0uJHtrZXl9YCxcbiAgICAgICAgICBmdWxsOiBgJHt0eXBlfS4ke2tleX1gLFxuICAgICAgICB9LFxuICAgICAgfVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGlmIChwcm92aXNpb25lcikge1xuICAgIG1hcHBlZENvbmZpZy5wcm92aXNpb25lcnMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC5lbnRyaWVzKHByb3Zpc2lvbmVyKS5mbGF0TWFwKChbdHlwZSwgcF06IFtzdHJpbmcsIGFueV0pID0+XG4gICAgICAgIHAubWFwKChwcDogUmVjb3JkPHN0cmluZywgYW55PikgPT5cbiAgICAgICAgICB2YWx1ZVRvVHMoXG4gICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgIHsgdHlwZSwgLi4ucHAgfSxcbiAgICAgICAgICAgIFwicGF0aC1mb3ItcHJvdmlzaW9uZXJzLWNhbi1iZS1pZ25vcmVkXCJcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgY29uc3QgaW1wb3J0R3JhcGhJZCA9IGBpbXBvcnQuJHtyZXNvdXJjZS5yZXBsYWNlKFwiLlwiLCBcIl9cIil9LiR7a2V5fWA7XG4gIGNvbnN0IGltcG9ydERlZmluaXRpb246IEltcG9ydCB8IHVuZGVmaW5lZCA9IGdyYXBoLmhhc05vZGUoaW1wb3J0R3JhcGhJZClcbiAgICA/IGdyYXBoLmdldE5vZGVBdHRyaWJ1dGUoaW1wb3J0R3JhcGhJZCwgXCJ2YWx1ZVwiKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMuY29uY2F0KFxuICAgIGF3YWl0IGFzRXhwcmVzc2lvbihcbiAgICAgIHsgLi4uc2NvcGUsIGZvckVhY2hJdGVyYXRvck5hbWUsIGNvdW50SXRlcmF0b3JOYW1lIH0sXG4gICAgICByZXNvdXJjZSxcbiAgICAgIGtleSxcbiAgICAgIG1hcHBlZENvbmZpZyxcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2UsXG4gICAgICBnZXRSZWZlcmVuY2UoZ3JhcGgsIGlkKSB8fCBvdmVycmlkZVJlZmVyZW5jZSxcbiAgICAgIGltcG9ydERlZmluaXRpb25cbiAgICApXG4gICk7XG5cbiAgLy8gQ2hlY2sgZm9yIGR5bmFtaWMgYmxvY2tzXG4gIGV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMuY29uY2F0KFxuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgZHluYW1pY0Jsb2Nrc1VzaW5nT3ZlcnJpZGVzLm1hcChhc3luYyAoeyBwYXRoLCBmb3JfZWFjaCwgY29udGVudCB9KSA9PiB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gbGV0IHRoZSBleHByZXNzaW9uIGNvbnZlcnNpb24ga25vdyBhbGwgYXZhaWxhYmxlXG4gICAgICAgIC8vIGR5bmFtaWMgYmxvY2sgbmFtZXMsIHNvIHdlIGRvbid0IHJlcGxhY2UgdGhlbS4gVGhlIFwiZHluYW1pYy1ibG9ja1wiXG4gICAgICAgIC8vIHNjb3BlZCB2YXJpYWJsZSBpbmRpY2F0ZXMgdG8gdGhlIGV4cHJlc3Npb24gY29udmVyc2lvbiB0byB1c2UgdGhlXG4gICAgICAgIC8vIGtleSBuYW1lIGluc3RlYWQgb2YgYW4gaXRlcmF0b3JcbiAgICAgICAgY29uc3Qgc2NvcGVkVmFyaWFibGVzSW5QYXRoID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIHBhdGhcbiAgICAgICAgICAgIC5zdWJzdHJpbmcoMSkgLy8gVGhlIHBhdGggc3RhcnRzIHdpdGggYSBkb3QgdGhhdCByZXN1bHRzIGluIGFuIGVtcHR5IHNwbGl0XG4gICAgICAgICAgICAuc3BsaXQoXCIuXCIpXG4gICAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAgICAgICAocCkgPT4gIVtcImR5bmFtaWNcIiwgXCJjb250ZW50XCJdLmluY2x1ZGVzKHApICYmIGlzTmFOKHBhcnNlSW50KHApKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLm1hcCgocCkgPT4gW3AsIFwiZHluYW1pYy1ibG9ja1wiXSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gYWRkT3ZlcnJpZGVFeHByZXNzaW9uKFxuICAgICAgICAgIHZhck5hbWUsXG4gICAgICAgICAgcGF0aC5zdWJzdHJpbmcoMSksIC8vIFRoZSBwYXRoIHN0YXJ0cyB3aXRoIGEgZG90IHRoYXQgd2UgZG9uJ3Qgd2FudFxuICAgICAgICAgIGF3YWl0IHZhbHVlVG9UcyhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uc2NvcGUsXG4gICAgICAgICAgICAgIHdpdGhpbk92ZXJyaWRlRXhwcmVzc2lvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgc2NvcGVkVmFyaWFibGVzOiBzY29wZWRWYXJpYWJsZXNJblBhdGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBmb3JfZWFjaCxcbiAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInBhdGgtZm9yLWR5bmFtaWMtYmxvY2tzLWNhbi1iZS1pZ25vcmVkXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIGxvb3BDb21tZW50XG4gICAgICAgICk7XG4gICAgICB9KVxuICAgIClcbiAgKTtcblxuICByZXR1cm4gZXhwcmVzc2lvbnM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFzRXhwcmVzc2lvbihcbiAgc2NvcGU6IFJlc291cmNlU2NvcGUsXG4gIHR5cGU6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBjb25maWc6IFRlcnJhZm9ybVJlc291cmNlQmxvY2ssXG4gIGlzTW9kdWxlSW1wb3J0OiBib29sZWFuLFxuICBpc1Byb3ZpZGVyOiBib29sZWFuLFxuICByZWZlcmVuY2U/OiBSZWZlcmVuY2UsXG4gIGltcG9ydGVkPzogSW1wb3J0XG4pIHtcbiAgY29uc3QgeyBwcm92aWRlcnMsIC4uLm90aGVyT3B0aW9ucyB9ID0gY29uZmlnIGFzIGFueTtcblxuICBjb25zdCBjb25zdHJ1Y3RJZCA9IHVuaXF1ZUlkKHNjb3BlLmNvbnN0cnVjdHMsIG5hbWUpO1xuICBjb25zdCBvdmVycmlkZUlkID0gIWlzUHJvdmlkZXIgJiYgY29uc3RydWN0SWQgIT09IG5hbWU7XG5cbiAgY29uc3QgY29tcGxldGVPYmplY3QgPSBmaWxsV2l0aENvbmZpZ0FjY2Vzc29ycyhzY29wZSwgb3RoZXJPcHRpb25zLCB0eXBlKTtcblxuICBjb25zdCBleHByZXNzaW9uID0gdC5uZXdFeHByZXNzaW9uKFxuICAgIGNvbnN0cnVjdEFzdChzY29wZSwgdHlwZSwgaXNNb2R1bGVJbXBvcnQpLFxuICAgIFtcbiAgICAgIHQudGhpc0V4cHJlc3Npb24oKSxcbiAgICAgIHQuc3RyaW5nTGl0ZXJhbChjb25zdHJ1Y3RJZCksXG5cbiAgICAgIGF3YWl0IHZhbHVlVG9UcyhcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5jb21wbGV0ZU9iamVjdCxcbiAgICAgICAgICBwcm92aWRlcnM6XG4gICAgICAgICAgICBwcm92aWRlcnMgJiYgT2JqZWN0LmtleXMocHJvdmlkZXJzKS5sZW5ndGhcbiAgICAgICAgICAgICAgPyBPYmplY3QuZW50cmllcyhwcm92aWRlcnMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgbW9kdWxlQWxpYXM6IGtleSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIGAke3R5cGV9YCxcbiAgICAgICAgaXNNb2R1bGVJbXBvcnRcbiAgICAgICksXG4gICAgXVxuICApO1xuXG4gIGNvbnN0IHN0YXRlbWVudHMgPSBbXTtcbiAgY29uc3QgdmFyTmFtZSA9IHJlZmVyZW5jZVxuICAgID8gcmVmZXJlbmNlVG9WYXJpYWJsZU5hbWUoc2NvcGUsIHJlZmVyZW5jZSlcbiAgICA6IHZhcmlhYmxlTmFtZShzY29wZSwgdHlwZSwgbmFtZSk7XG5cbiAgaWYgKHJlZmVyZW5jZSB8fCBvdmVycmlkZUlkIHx8IGltcG9ydGVkKSB7XG4gICAgc3RhdGVtZW50cy5wdXNoKFxuICAgICAgdC52YXJpYWJsZURlY2xhcmF0aW9uKFwiY29uc3RcIiwgW1xuICAgICAgICB0LnZhcmlhYmxlRGVjbGFyYXRvcih0LmlkZW50aWZpZXIodmFyTmFtZSksIGV4cHJlc3Npb24pLFxuICAgICAgXSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlbWVudHMucHVzaCh0LmV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcmVzc2lvbikpO1xuICB9XG5cbiAgaWYgKG92ZXJyaWRlSWQpIHtcbiAgICBzdGF0ZW1lbnRzLnB1c2goYWRkT3ZlcnJpZGVMb2dpY2FsSWRFeHByZXNzaW9uKHZhck5hbWUsIG5hbWUpKTtcbiAgfVxuXG4gIGlmIChpbXBvcnRlZCkge1xuICAgIC8vIEFkZHMgbXlWYXIuaW1wb3J0RnJvbShcIm15LWFyblwiKVxuICAgIGNvbnN0IGltcG9ydEV4cHJlc3Npb24gPSB0LmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24odC5pZGVudGlmaWVyKHZhck5hbWUpLCB0LmlkZW50aWZpZXIoXCJpbXBvcnRGcm9tXCIpKSxcbiAgICAgICAgW3Quc3RyaW5nTGl0ZXJhbChpbXBvcnRlZC5pZCldXG4gICAgICApXG4gICAgKTtcblxuICAgIGlmIChpbXBvcnRlZC5wcm92aWRlcikge1xuICAgICAgdC5hZGRDb21tZW50KFxuICAgICAgICBpbXBvcnRFeHByZXNzaW9uLFxuICAgICAgICBcImxlYWRpbmdcIixcbiAgICAgICAgYFRoaXMgaW1wb3J0IHdhcyBjb25maWd1cmVkIHdpdGggYSBwcm92aWRlci4gQ0RLVEYgZG9lcyBzdXBwb3J0IHRoaXMsIGJ1dCB0aGUgY2RrdGYgY29udmVydCBjb21tYW5kIGRvZXMgbm90IHlldC4gUGxlYXNlIGFkZCB0aGUgcHJvdmlkZXIgcmVmZXJlbmNlIG1hbnVhbGx5LiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIuaGFzaGljb3JwLmNvbS90ZXJyYWZvcm0vY2RrdGYvY29uY2VwdHMvcmVzb3VyY2VzI2ltcG9ydGluZy1yZXNvdXJjZXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0ZW1lbnRzLnB1c2goaW1wb3J0RXhwcmVzc2lvbik7XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50cztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG91dHB1dChcbiAgc2NvcGU6IFByb2dyYW1TY29wZSxcbiAga2V5OiBzdHJpbmcsXG4gIF9pZDogc3RyaW5nLFxuICBpdGVtOiBPdXRwdXQsXG4gIF9ncmFwaDogRGlyZWN0ZWRHcmFwaFxuKSB7XG4gIGNvbnN0IFt7IHZhbHVlLCBkZXNjcmlwdGlvbiwgc2Vuc2l0aXZlIH1dID0gaXRlbTtcblxuICByZXR1cm4gYXNFeHByZXNzaW9uKFxuICAgIHNjb3BlLFxuICAgIFwiY2RrdGYuVGVycmFmb3JtT3V0cHV0XCIsXG4gICAga2V5LFxuICAgIHtcbiAgICAgIHZhbHVlLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBzZW5zaXRpdmUsXG4gICAgfSxcbiAgICBmYWxzZSxcbiAgICBmYWxzZSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkXG4gICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YXJpYWJsZVR5cGVUb0FzdChcbiAgc2NvcGU6IFByb2dyYW1TY29wZSxcbiAgdHlwZTogc3RyaW5nXG4pOiBQcm9taXNlPHQuRXhwcmVzc2lvbj4ge1xuICBjb25zdCBhZGRWYXJpYWJsZVR5cGVUb0ltcG9ydHMgPSAoKSA9PlxuICAgIHNjb3BlLmltcG9ydGFibGVzLnB1c2goe1xuICAgICAgY29uc3RydWN0TmFtZTogXCJWYXJpYWJsZVR5cGVcIixcbiAgICAgIHByb3ZpZGVyOiBcImNka3RmXCIsXG4gICAgfSk7XG5cbiAgZnVuY3Rpb24gcGFyc2VkVHlwZVRvQXN0KHR5cGU6IHRleC5FeHByZXNzaW9uVHlwZSk6IHQuRXhwcmVzc2lvbiB7XG4gICAgaWYgKHRleC5pc1Njb3BlVHJhdmVyc2FsRXhwcmVzc2lvbih0eXBlKSkge1xuICAgICAgYWRkVmFyaWFibGVUeXBlVG9JbXBvcnRzKCk7XG4gICAgICBzd2l0Y2ggKHR5cGUubWV0YS52YWx1ZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIHQuaWRlbnRpZmllcihcIlZhcmlhYmxlVHlwZS5TVFJJTkdcIik7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICByZXR1cm4gdC5pZGVudGlmaWVyKFwiVmFyaWFibGVUeXBlLk5VTUJFUlwiKTtcbiAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICByZXR1cm4gdC5pZGVudGlmaWVyKFwiVmFyaWFibGVUeXBlLkJPT0xcIik7XG4gICAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdC5pZGVudGlmaWVyKFwiVmFyaWFibGVUeXBlLkFOWVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGV4LmlzRnVuY3Rpb25DYWxsRXhwcmVzc2lvbih0eXBlKSkge1xuICAgICAgYWRkVmFyaWFibGVUeXBlVG9JbXBvcnRzKCk7XG4gICAgICBzd2l0Y2ggKHR5cGUubWV0YS5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJsaXN0XCI6XG4gICAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICBjYXNlIFwidHVwbGVcIjpcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIHJldHVybiB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgICAgdC5pZGVudGlmaWVyKGBWYXJpYWJsZVR5cGUuJHt0eXBlLm1ldGEubmFtZX1gKSxcbiAgICAgICAgICAgIHR5cGUuY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gcGFyc2VkVHlwZVRvQXN0KGNoaWxkKSlcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0ZXguaXNPYmplY3RFeHByZXNzaW9uKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdC5vYmplY3RFeHByZXNzaW9uKFxuICAgICAgICBPYmplY3QuZW50cmllcyh0eXBlLm1ldGEuaXRlbXMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PlxuICAgICAgICAgIHQub2JqZWN0UHJvcGVydHkoXG4gICAgICAgICAgICB0LnN0cmluZ0xpdGVyYWwoa2V5KSxcbiAgICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgZGVhbCB3aXRoIGNvbXBsZXggdHlwZXMgbmVzdGVkIHdpdGhpbiBvYmplY3RzXG4gICAgICAgICAgICAvLyBJZiBzdWNoIGEgdHlwZSBpcyBmb3VuZCBpdCB3aWxsIHJlc3VsdCBpbiBhbiBBbnkgdHlwZVxuICAgICAgICAgICAgLy8gZS5nLiB7IGZvbzogbGlzdChzdHJpbmcpIH0gd2lsbCByZXN1bHQgaW4geyBmb286IGFueSB9XG4gICAgICAgICAgICBwYXJzZWRUeXBlVG9Bc3Qoe1xuICAgICAgICAgICAgICB0eXBlOiBcInNjb3BlVHJhdmVyc2FsXCIsXG4gICAgICAgICAgICAgIG1ldGE6IHsgdmFsdWUgfSxcbiAgICAgICAgICAgIH0gYXMgYW55KVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBhZGRWYXJpYWJsZVR5cGVUb0ltcG9ydHMoKTtcbiAgICByZXR1cm4gdC5pZGVudGlmaWVyKFwiVmFyaWFibGVUeXBlLkFOWVwiKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZWRUeXBlVG9Bc3QoYXdhaXQgZXhwcmVzc2lvbkFzdCh0eXBlKSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YXJpYWJsZShcbiAgc2NvcGU6IFByb2dyYW1TY29wZSxcbiAga2V5OiBzdHJpbmcsXG4gIGlkOiBzdHJpbmcsXG4gIGl0ZW06IFZhcmlhYmxlLFxuICBncmFwaDogRGlyZWN0ZWRHcmFwaFxuKSB7XG4gIGNvbnN0IFt7IHR5cGUsIC4uLnByb3BzIH1dID0gaXRlbTtcblxuICBpZiAoIWdldFJlZmVyZW5jZShncmFwaCwgaWQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIGFzRXhwcmVzc2lvbihcbiAgICBzY29wZSxcbiAgICBpZCxcbiAgICBrZXksXG4gICAgeyAuLi5wcm9wcywgdHlwZTogdHlwZSA/IGF3YWl0IHZhcmlhYmxlVHlwZVRvQXN0KHNjb3BlLCB0eXBlKSA6IHVuZGVmaW5lZCB9LFxuICAgIGZhbHNlLFxuICAgIGZhbHNlLFxuICAgIGdldFJlZmVyZW5jZShncmFwaCwgaWQpLFxuICAgIHVuZGVmaW5lZFxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9jYWwoXG4gIHNjb3BlOiBQcm9ncmFtU2NvcGUsXG4gIGtleTogc3RyaW5nLFxuICBpZDogc3RyaW5nLFxuICBpdGVtOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrLFxuICBncmFwaDogRGlyZWN0ZWRHcmFwaFxuKTogUHJvbWlzZTx0LlZhcmlhYmxlRGVjbGFyYXRpb25bXT4ge1xuICBsb2dnZXIuZGVidWcoYEluaXRpYWxpemluZyBsb2NhbCByZXNvdXJjZSAke2tleX0gd2l0aCBpZCAke2lkfWApO1xuICBpZiAoIWdldFJlZmVyZW5jZShncmFwaCwgaWQpKSB7XG4gICAgbG9nZ2VyLmRlYnVnKGBObyByZWZlcmVuY2UgZm91bmQgZm9yICR7a2V5fWApO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gW1xuICAgIHQudmFyaWFibGVEZWNsYXJhdGlvbihcImNvbnN0XCIsIFtcbiAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKFxuICAgICAgICB0LmlkZW50aWZpZXIodmFyaWFibGVOYW1lKHNjb3BlLCBcImxvY2FsXCIsIGtleSkpLFxuICAgICAgICBhd2FpdCB2YWx1ZVRvVHMoc2NvcGUsIGl0ZW0sIFwicGF0aC1mb3ItbG9jYWwtYmxvY2tzLWNhbi1iZS1pZ25vcmVkXCIpXG4gICAgICApLFxuICAgIF0pLFxuICBdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbW9kdWxlcyhcbiAgc2NvcGU6IFByb2dyYW1TY29wZSxcbiAga2V5OiBzdHJpbmcsXG4gIGlkOiBzdHJpbmcsXG4gIGl0ZW06IE1vZHVsZSxcbiAgZ3JhcGg6IERpcmVjdGVkR3JhcGhcbikge1xuICBjb25zdCBbeyBzb3VyY2UsIHZlcnNpb24sIC4uLnByb3BzIH1dID0gaXRlbTtcblxuICBjb25zdCBtb2R1bGVDb25zdHJhaW50ID0gbmV3IFRlcnJhZm9ybU1vZHVsZUNvbnN0cmFpbnQoc291cmNlKTtcblxuICByZXR1cm4gYXNFeHByZXNzaW9uKFxuICAgIHNjb3BlLFxuICAgIG1vZHVsZUNvbnN0cmFpbnQuY2xhc3NOYW1lLFxuICAgIGtleSxcbiAgICBwcm9wcyxcbiAgICB0cnVlLFxuICAgIGZhbHNlLFxuICAgIGdldFJlZmVyZW5jZShncmFwaCwgaWQpLFxuICAgIHVuZGVmaW5lZFxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wb3J0cyhcbiAgc2NvcGU6IFByb2dyYW1TY29wZSxcbiAgX2lkOiBzdHJpbmcsXG4gIGl0ZW06IEltcG9ydCxcbiAgZ3JhcGg6IERpcmVjdGVkR3JhcGhcbikge1xuICAvLyBNb3ZlIGZyb20gJHthd3NfaW5zdGFuY2UuZXhhbXBsZX0gdG8gYXdzX2luc3RhbmNlLmV4YW1wbGVcbiAgY29uc3QgdGFyZ2V0ID1cbiAgICBpdGVtLnRvLnN0YXJ0c1dpdGgoXCIke1wiKSAmJiBpdGVtLnRvLmVuZHNXaXRoKFwifVwiKVxuICAgICAgPyBpdGVtLnRvLnN1YnN0cmluZygyLCBpdGVtLnRvLmxlbmd0aCAtIDEpXG4gICAgICA6IGl0ZW0udG87XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIGltcG9ydCBnb2VzIGludG8gYSBtb2R1bGVcbiAgaWYgKHRhcmdldC5zdGFydHNXaXRoKFwibW9kdWxlLlwiKSkge1xuICAgIHJldHVybiBbXG4gICAgICB0LmFkZENvbW1lbnQoXG4gICAgICAgIHQuZW1wdHlTdGF0ZW1lbnQoKSxcbiAgICAgICAgXCJsZWFkaW5nXCIsXG4gICAgICAgIGBDREtURiBkb2VzIG5vdCBzdXBwb3J0IGltcG9ydHMgaW50byBtb2R1bGVzIHlldCwgcGxlYXNlIHJlbW92ZSB0aGUgaW1wb3J0IGJsb2NrIGltcG9ydGluZyAke2l0ZW0uaWR9IGludG8gJHt0YXJnZXR9IGZyb20geW91ciBjb25maWd1cmF0aW9uYFxuICAgICAgKSxcbiAgICBdO1xuICB9XG5cbiAgLy8gV2Ugbm93IGtub3cgdGhhdCB0aGUgaW1wb3J0IGdvZXMgaW50byBhIHJlc291cmNlLCBlLmcuIGF3c19pbnN0YW5jZS5leGFtcGxlXG4gIGNvbnN0IFtyZXNvdXJjZVR5cGVJZGVudGlmaWVyLCByZXNvdXJjZU5hbWVdID0gdGFyZ2V0LnNwbGl0KFwiLlwiKTtcbiAgaWYgKHJlc291cmNlTmFtZS5pbmNsdWRlcyhcIltcIikpIHtcbiAgICByZXR1cm4gW1xuICAgICAgdC5hZGRDb21tZW50KFxuICAgICAgICB0LmVtcHR5U3RhdGVtZW50KCksXG4gICAgICAgIFwibGVhZGluZ1wiLFxuICAgICAgICBgQ0RLVEYgZG9lcyBub3Qgc3VwcG9ydCBpbXBvcnRzIGludG8gcmVzb3VyY2VzIHdpdGggY291bnQgb3IgZm9yX2VhY2ggeWV0LCBwbGVhc2UgcmVtb3ZlIHRoZSBpbXBvcnQgYmxvY2sgaW1wb3J0aW5nICR7aXRlbS5pZH0gaW50byAke3RhcmdldH0gZnJvbSB5b3VyIGNvbmZpZ3VyYXRpb25gXG4gICAgICApLFxuICAgIF07XG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgZXhpc3RpbmcgcmVzb3VyY2UgY29uZmlnIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgaWYgKGdyYXBoLmhhc05vZGUodGFyZ2V0KSkge1xuICAgIC8vIFdlIHdpbGwgaGFuZGxlIHRoaXMgY2FzZSBpbiB0aGUgcmVzb3VyY2UgZnVuY3Rpb25cbiAgICAvLyBzbyB3ZSBjYW4gc2tpcCBvdmVyIGl0XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgW3Byb3ZpZGVyLCAuLi5yZXNvdXJjZVR5cGVOYW1lUGFydHNdID1cbiAgICByZXNvdXJjZVR5cGVJZGVudGlmaWVyLnNwbGl0KFwiX1wiKTtcblxuICBjb25zdCBjb25zdHJ1Y3RJZCA9IHVuaXF1ZUlkKHNjb3BlLmNvbnN0cnVjdHMsIGNhbWVsQ2FzZShyZXNvdXJjZU5hbWUpKTtcbiAgY29uc3QgY29uc3RydWN0Q2xhc3MgPSBjb25zdHJ1Y3RBc3QoXG4gICAgc2NvcGUsXG4gICAgYCR7cHJvdmlkZXJ9LiR7cmVzb3VyY2VUeXBlTmFtZVBhcnRzLmpvaW4oXCJfXCIpfWAsXG4gICAgZmFsc2VcbiAgKTtcbiAgcmV0dXJuIFtcbiAgICB0LmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgY29uc3RydWN0Q2xhc3MsXG4gICAgICAgICAgdC5pZGVudGlmaWVyKFwiZ2VuZXJhdGVDb25maWdGb3JJbXBvcnRcIilcbiAgICAgICAgKSxcbiAgICAgICAgW1xuICAgICAgICAgIHQudGhpc0V4cHJlc3Npb24oKSxcbiAgICAgICAgICB0LnN0cmluZ0xpdGVyYWwoY29uc3RydWN0SWQpLFxuICAgICAgICAgIHQuc3RyaW5nTGl0ZXJhbChpdGVtLmlkKSxcbiAgICAgICAgXVxuICAgICAgKVxuICAgICksXG4gIF07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm92aWRlcihcbiAgc2NvcGU6IFByb2dyYW1TY29wZSxcbiAga2V5OiBzdHJpbmcsXG4gIGlkOiBzdHJpbmcsXG4gIGl0ZW06IFByb3ZpZGVyWzBdLFxuICBncmFwaDogRGlyZWN0ZWRHcmFwaFxuKSB7XG4gIGNvbnN0IHsgdmVyc2lvbiwgLi4ucHJvcHMgfSA9IGl0ZW07XG5cbiAgY29uc3QgaW1wb3J0S2V5ID0ga2V5ID09PSBcIm51bGxcIiA/IFwiTnVsbFByb3ZpZGVyXCIgOiBrZXk7XG5cbiAgcmV0dXJuIGFzRXhwcmVzc2lvbihcbiAgICBzY29wZSxcbiAgICBgJHtpbXBvcnRLZXl9LiR7cGFzY2FsQ2FzZShrZXkpfVByb3ZpZGVyYCxcbiAgICBrZXksXG4gICAgcHJvcHMsXG4gICAgZmFsc2UsXG4gICAgdHJ1ZSxcbiAgICBnZXRSZWZlcmVuY2UoZ3JhcGgsIGlkKSxcbiAgICB1bmRlZmluZWRcbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IGNka3RmSW1wb3J0ID0gdGVtcGxhdGUoXG4gIGBpbXBvcnQgKiBhcyBjZGt0ZiBmcm9tIFwiY2RrdGZcImBcbikoKSBhcyB0LlN0YXRlbWVudDtcblxuZXhwb3J0IGNvbnN0IGNvbnN0cnVjdHNJbXBvcnQgPSB0ZW1wbGF0ZShcbiAgYGltcG9ydCAqIGFzIGNvbnN0cnVjdHMgZnJvbSBcImNvbnN0cnVjdHNcImBcbikoKSBhcyB0LlN0YXRlbWVudDtcblxuZXhwb3J0IGNvbnN0IHByb3ZpZGVySW1wb3J0cyA9IChwcm92aWRlcnM6IHN0cmluZ1tdKSA9PlxuICBwcm92aWRlcnMubWFwKChwcm92aWRlck5hbWUpID0+IHtcbiAgICBjb25zdCBwYXJ0cyA9IHByb3ZpZGVyTmFtZS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgbmFtZSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXSA6IHBhcnRzWzBdO1xuICAgIGNvbnN0IGltcG9ydE5hbWUgPSBuYW1lID09PSBcIm51bGxcIiA/IFwiTnVsbFByb3ZpZGVyXCIgOiBuYW1lO1xuICAgIHJldHVybiB0ZW1wbGF0ZShcbiAgICAgIGBpbXBvcnQgKiBhcyAke2ltcG9ydE5hbWV9IGZyb20gXCIuLy5nZW4vcHJvdmlkZXJzLyR7bmFtZS5yZXBsYWNlKFxuICAgICAgICBcIi4vXCIsXG4gICAgICAgIFwiXCJcbiAgICAgICl9XCJgXG4gICAgKSgpIGFzIHQuU3RhdGVtZW50O1xuICB9KTtcblxuZXhwb3J0IGNvbnN0IG1vZHVsZUltcG9ydHMgPSAobW9kdWxlczogUmVjb3JkPHN0cmluZywgTW9kdWxlPiB8IHVuZGVmaW5lZCkgPT4ge1xuICBjb25zdCB1bmlxdWVNb2R1bGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIE9iamVjdC52YWx1ZXMobW9kdWxlcyB8fCB7fSkubWFwKChbbW9kdWxlXSkgPT5cbiAgICB1bmlxdWVNb2R1bGVzLmFkZChtb2R1bGUuc291cmNlKVxuICApO1xuXG4gIGNvbnN0IGltcG9ydHM6IHQuU3RhdGVtZW50W10gPSBbXTtcbiAgdW5pcXVlTW9kdWxlcy5mb3JFYWNoKChtKSA9PiB7XG4gICAgY29uc3QgbW9kdWxlQ29uc3RyYWludCA9IG5ldyBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50KG0pO1xuICAgIGltcG9ydHMucHVzaChcbiAgICAgIHRlbXBsYXRlLmFzdChcbiAgICAgICAgYGltcG9ydCAqIGFzICR7bW9kdWxlQ29uc3RyYWludC5jbGFzc05hbWV9IGZyb20gXCIuLy5nZW4vbW9kdWxlcy8ke21vZHVsZUNvbnN0cmFpbnQuZmlsZU5hbWV9XCJgXG4gICAgICApIGFzIHQuU3RhdGVtZW50XG4gICAgKTtcbiAgfSk7XG4gIHJldHVybiBpbXBvcnRzO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbihzdGF0ZW1lbnRzOiB0LlN0YXRlbWVudFtdKSB7XG4gIGxvZ2dlci5kZWJ1ZyhgR2VuZXJhdGluZyBjb2RlIGZvciAke0pTT04uc3RyaW5naWZ5KHN0YXRlbWVudHMsIG51bGwsIDIpfWApO1xuICBjb25zdCBjb2RlID0gcHJldHRpZXIuZm9ybWF0KGdlbmVyYXRlKHQucHJvZ3JhbShzdGF0ZW1lbnRzKSBhcyBhbnkpLmNvZGUsIHtcbiAgICBwYXJzZXI6IFwiYmFiZWxcIixcbiAgfSk7XG5cbiAgbG9nZ2VyLmRlYnVnKGBHZW5lcmF0ZWQgY29kZTpcXG4ke2NvZGV9YCk7XG5cbiAgcmV0dXJuIGNvZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRJbXBvcnRGb3JDb2RlQ29udGFpbmVyKFxuICBzY29wZTogUHJvZ3JhbVNjb3BlLFxuICBjb2RlQ29udGFpbmVyOiBzdHJpbmdcbikge1xuICBzd2l0Y2ggKGNvZGVDb250YWluZXIpIHtcbiAgICBjYXNlIFwiY29uc3RydWN0cy5Db25zdHJ1Y3RcIjpcbiAgICAgIHNjb3BlLmltcG9ydGFibGVzLnB1c2goe1xuICAgICAgICBwcm92aWRlcjogXCJjb25zdHJ1Y3RzXCIsXG4gICAgICAgIGNvbnN0cnVjdE5hbWU6IFwiQ29uc3RydWN0XCIsXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImNka3RmLlRlcnJhZm9ybVN0YWNrXCI6XG4gICAgICBzY29wZS5pbXBvcnRhYmxlcy5wdXNoKHtcbiAgICAgICAgcHJvdmlkZXI6IFwiY2RrdGZcIixcbiAgICAgICAgY29uc3RydWN0TmFtZTogXCJUZXJyYWZvcm1TdGFja1wiLFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgRXJyb3JzLkludGVybmFsKFwiVW5zdXBwb3J0ZWQgY29kZSBjb250YWluZXI6IFwiICsgY29kZUNvbnRhaW5lcik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb2RlSW5Db25zdHJ1Y3RvcihcbiAgY29kZUNvbnRhaW5lcjogc3RyaW5nLFxuICBjb2RlOiB0LlN0YXRlbWVudFtdLFxuICBjbGFzc05hbWU6IHN0cmluZyxcbiAgY29uZmlnVHlwZU5hbWU/OiBzdHJpbmdcbik6IHQuU3RhdGVtZW50IHtcbiAgbGV0IGJhc2VDb250YWluZXJDbGFzczogdC5JZGVudGlmaWVyO1xuICBzd2l0Y2ggKGNvZGVDb250YWluZXIpIHtcbiAgICBjYXNlIFwiY29uc3RydWN0cy5Db25zdHJ1Y3RcIjpcbiAgICAgIGJhc2VDb250YWluZXJDbGFzcyA9IHQuaWRlbnRpZmllcihcIkNvbnN0cnVjdFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImNka3RmLlRlcnJhZm9ybVN0YWNrXCI6XG4gICAgICBiYXNlQ29udGFpbmVyQ2xhc3MgPSB0LmlkZW50aWZpZXIoXCJUZXJyYWZvcm1TdGFja1wiKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcnMuSW50ZXJuYWwoXCJVbnN1cHBvcnRlZCBjb2RlIGNvbnRhaW5lcjogXCIgKyBjb2RlQ29udGFpbmVyKTtcbiAgfVxuICBpZiAoY29uZmlnVHlwZU5hbWUpIHtcbiAgICByZXR1cm4gdGVtcGxhdGUuc3RhdGVtZW50KFxuICAgICAgYFxuICBjbGFzcyAlJWNsYXNzTmFtZSUlIGV4dGVuZHMgJSViYXNlJSUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIG5hbWU6IHN0cmluZywgY29uZmlnOiAke2NvbmZpZ1R5cGVOYW1lfSkge1xuICAgICAgc3VwZXIoc2NvcGUsIG5hbWUpO1xuICAgICAgJSVjb2RlJSVcbiAgICB9XG4gIH1cbmAsXG4gICAgICB7IHN5bnRhY3RpY1BsYWNlaG9sZGVyczogdHJ1ZSwgcGx1Z2luczogW1widHlwZXNjcmlwdFwiXSB9XG4gICAgKSh7XG4gICAgICBjb2RlLFxuICAgICAgYmFzZTogYmFzZUNvbnRhaW5lckNsYXNzLFxuICAgICAgY2xhc3NOYW1lOiB0LmlkZW50aWZpZXIoY2xhc3NOYW1lKSxcbiAgICB9KSBhcyB0LlN0YXRlbWVudDtcbiAgfVxuICByZXR1cm4gdGVtcGxhdGUuc3RhdGVtZW50KFxuICAgIGBcbiAgY2xhc3MgJSVjbGFzc05hbWUlJSBleHRlbmRzICUlYmFzZSUlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZTogQ29uc3RydWN0LCBuYW1lOiBzdHJpbmcpIHtcbiAgICAgIHN1cGVyKHNjb3BlLCBuYW1lKTtcbiAgICAgICUlY29kZSUlXG4gICAgfVxuICB9XG5gLFxuICAgIHsgc3ludGFjdGljUGxhY2Vob2xkZXJzOiB0cnVlLCBwbHVnaW5zOiBbXCJ0eXBlc2NyaXB0XCJdIH1cbiAgKSh7XG4gICAgY29kZSxcbiAgICBiYXNlOiBiYXNlQ29udGFpbmVyQ2xhc3MsXG4gICAgY2xhc3NOYW1lOiB0LmlkZW50aWZpZXIoY2xhc3NOYW1lKSxcbiAgfSkgYXMgdC5TdGF0ZW1lbnQ7XG59XG5cbmV4cG9ydCBjb25zdCBwcm92aWRlckNvbnN0cnVjdEltcG9ydHMgPSAoaW1wb3J0YWJsZTogSW1wb3J0YWJsZUNvbnN0cnVjdFtdKSA9PiB7XG4gIGxldCBwcm92aWRlciA9IGltcG9ydGFibGVbMF0ucHJvdmlkZXI7XG4gIGxldCBuYW1lc3BhY2UgPSBpbXBvcnRhYmxlWzBdLm5hbWVzcGFjZTtcbiAgY29uc3QgbmFtZXMgPSBpbXBvcnRhYmxlLm1hcCgoaSkgPT4gaS5jb25zdHJ1Y3ROYW1lKTtcblxuICBpZiAocHJvdmlkZXIgPT09IFwiY2RrdGZcIiB8fCBwcm92aWRlciA9PT0gXCJjb25zdHJ1Y3RzXCIpIHtcbiAgICByZXR1cm4gdGVtcGxhdGUoXG4gICAgICBgaW1wb3J0IHsgJHtuYW1lcy5qb2luKFwiLCBcIil9IH0gZnJvbSBcIiR7cHJvdmlkZXJ9XCJgXG4gICAgKSgpIGFzIHQuU3RhdGVtZW50O1xuICB9XG5cbiAgaWYgKG5hbWVzcGFjZSkge1xuICAgIG5hbWVzcGFjZSA9IHNuYWtlQ2FzZShuYW1lc3BhY2UpLnJlcGxhY2UoL18vZywgXCItXCIpO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBjYXNlcyB0byB1bmRvIHByb3ZpZGVyIG5hbWVzIHRoYXQgd2Ugb3ZlcnJpZGVcbiAgaWYgKHByb3ZpZGVyID09PSBcIk51bGxQcm92aWRlclwiKSB7XG4gICAgcHJvdmlkZXIgPSBcIm51bGxcIjtcbiAgfVxuXG4gIHJldHVybiB0ZW1wbGF0ZShcbiAgICBgaW1wb3J0IHsgJHtuYW1lcy5qb2luKFxuICAgICAgXCIsIFwiXG4gICAgKX0gfSBmcm9tIFwiLi8uZ2VuL3Byb3ZpZGVycy8ke3Byb3ZpZGVyfS8ke25hbWVzcGFjZX1cImBcbiAgKSgpIGFzIHQuU3RhdGVtZW50O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkSW1wb3J0cyhpbXBvcnRhYmxlczogSW1wb3J0YWJsZUNvbnN0cnVjdFtdKSB7XG4gIGNvbnN0IGdyb3VwZWRJbXBvcnRhYmxlcyA9IGltcG9ydGFibGVzLnJlZHVjZSgoYWNjLCBpbXBvcnRhYmxlKSA9PiB7XG4gICAgY29uc3QgbnMgPSBpbXBvcnRhYmxlLm5hbWVzcGFjZSB8fCBcIlwiO1xuICAgIC8vIERvaW5nIHNvbWUgaGFja3kgb3JkZXJpbmcgb2YgdGhlIGltcG9ydHMgdG8gbWFrZSB0aGVtIGxvb2sgYSBiaXQgbmljZXJcbiAgICBjb25zdCBwcmVmaXggPVxuICAgICAgaW1wb3J0YWJsZS5wcm92aWRlciA9PT0gXCJjb25zdHJ1Y3RzXCJcbiAgICAgICAgPyBcIjFcIlxuICAgICAgICA6IGltcG9ydGFibGUucHJvdmlkZXIgPT09IFwiY2RrdGZcIlxuICAgICAgICA/IFwiMlwiXG4gICAgICAgIDogXCIzXCI7XG4gICAgY29uc3QgZ3JvdXBOYW1lID0gYCR7cHJlZml4fS4ke2ltcG9ydGFibGUucHJvdmlkZXJ9LiR7bnN9YDtcbiAgICBjb25zdCBmdWxsTmFtZSA9IGAke2ltcG9ydGFibGUucHJvdmlkZXJ9LiR7bnN9LiR7aW1wb3J0YWJsZS5jb25zdHJ1Y3ROYW1lfWA7XG5cbiAgICBpZiAoYWNjW2dyb3VwTmFtZV0pIHtcbiAgICAgIGNvbnN0IGV4aXN0c0FscmVhZHkgPSBhY2NbZ3JvdXBOYW1lXS5zb21lKFxuICAgICAgICAoaW1wb3J0YWJsZSkgPT5cbiAgICAgICAgICBgJHtpbXBvcnRhYmxlLnByb3ZpZGVyfS4ke25zfS4ke2ltcG9ydGFibGUuY29uc3RydWN0TmFtZX1gID09PVxuICAgICAgICAgIGZ1bGxOYW1lXG4gICAgICApO1xuICAgICAgaWYgKGV4aXN0c0FscmVhZHkpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIGFjY1tncm91cE5hbWVdLnB1c2goaW1wb3J0YWJsZSk7XG4gICAgICBhY2NbZ3JvdXBOYW1lXS5zb3J0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY1tncm91cE5hbWVdID0gW2ltcG9ydGFibGVdO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIEltcG9ydGFibGVDb25zdHJ1Y3RbXT4pO1xuXG4gIGxldCBjb21tZW50QWRkZWQgPSBmYWxzZTtcbiAgY29uc3QgY29uc3RydWN0SW1wb3J0cyA9IE9iamVjdC5rZXlzKGdyb3VwZWRJbXBvcnRhYmxlcylcbiAgICAuc29ydCgpXG4gICAgLm1hcCgoZ3JvdXBOYW1lKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRTdGF0ZW1lbnQgPSBwcm92aWRlckNvbnN0cnVjdEltcG9ydHMoXG4gICAgICAgIGdyb3VwZWRJbXBvcnRhYmxlc1tncm91cE5hbWVdXG4gICAgICApO1xuXG4gICAgICBpZiAoZ3JvdXBOYW1lLnN0YXJ0c1dpdGgoXCIzLlwiKSAmJiAhY29tbWVudEFkZGVkKSB7XG4gICAgICAgIGNvbW1lbnRBZGRlZCA9IHRydWU7XG4gICAgICAgIHQuYWRkQ29tbWVudChcbiAgICAgICAgICBpbXBvcnRTdGF0ZW1lbnQsXG4gICAgICAgICAgXCJsZWFkaW5nXCIsXG4gICAgICAgICAgYFxcbiogUHJvdmlkZXIgYmluZGluZ3MgYXJlIGdlbmVyYXRlZCBieSBydW5uaW5nIFxcYGNka3RmIGdldFxcYC5cbiogU2VlIGh0dHBzOi8vY2RrLnRmL3Byb3ZpZGVyLWdlbmVyYXRpb24gZm9yIG1vcmUgZGV0YWlscy5cXG5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1wb3J0U3RhdGVtZW50O1xuICAgIH0pO1xuXG4gIHJldHVybiBjb25zdHJ1Y3RJbXBvcnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDb25maWdUeXBlKFxuICBuYW1lOiBzdHJpbmcsXG4gIGNvbmZpZzogUmVjb3JkPHN0cmluZywgQXR0cmlidXRlUGF0aD5cbik6IHQuU3RhdGVtZW50IHtcbiAgcmV0dXJuIHQudHNJbnRlcmZhY2VEZWNsYXJhdGlvbihcbiAgICB0LmlkZW50aWZpZXIobmFtZSksXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICB0LnRzSW50ZXJmYWNlQm9keShcbiAgICAgIE9iamVjdC5lbnRyaWVzKGNvbmZpZykubWFwKChba2V5LCBfdmFsdWVdKSA9PlxuICAgICAgICB0LnRzUHJvcGVydHlTaWduYXR1cmUoXG4gICAgICAgICAgdC5pZGVudGlmaWVyKGtleSksXG4gICAgICAgICAgdC50U1R5cGVBbm5vdGF0aW9uKHQudHNBbnlLZXl3b3JkKCkpIC8vIFRPRE86IFRyeSB0byBtYWtlIHRoaXMgYmV0dGVyIHRoYW4gYW55XG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG4gICk7XG59XG4iXX0=