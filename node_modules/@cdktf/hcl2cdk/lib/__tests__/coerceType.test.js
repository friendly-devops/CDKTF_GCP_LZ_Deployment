"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const coerceType_1 = require("../coerceType");
const template_1 = __importDefault(require("@babel/template"));
const generator_1 = __importDefault(require("@babel/generator"));
function expressionify(code) {
    return template_1.default.ast(code).expression;
}
function generateCode(ast) {
    return (0, generator_1.default)(ast).code;
}
const scope = {
    importables: [],
    variables: {
        a_user_defined_variable: {
            resource: "var",
            variableName: "aUserDefinedVariable",
        },
        a_user_defined_local: {
            resource: "var",
            variableName: "aUserDefinedTerraformLocal",
        },
    },
};
describe("coerceType", () => {
    it.each([
        { code: `"hello-world"`, type: "string", targetType: undefined },
        { code: `"hello-world"`, type: "string", targetType: "string" },
    ])("should change nothing for %p ", ({ code, type, targetType }) => {
        expect(generateCode((0, coerceType_1.coerceType)(scope, expressionify(code), type, targetType))).toEqual(code);
    });
    it.each([
        {
            code: `"300"`,
            type: "string",
            targetType: "number",
            expectedCode: `Token.asNumber("300")`,
        },
        {
            code: `300`,
            type: "number",
            targetType: "string",
            expectedCode: `Token.asString(300)`,
        },
        {
            code: `"['foo', 'bar']"`,
            type: "string",
            targetType: ["list", "string"],
            expectedCode: `Token.asList("['foo', 'bar']")`,
        },
        {
            code: `"[1,2,3]"`,
            type: "string",
            targetType: ["list", "number"],
            expectedCode: `Token.asNumberList("[1,2,3]")`,
        },
        {
            code: `"['foo', 'bar']"`,
            type: "string",
            targetType: ["set", "string"],
            expectedCode: `Token.asList("['foo', 'bar']")`,
        },
        {
            code: `"[1,2,3]"`,
            type: "string",
            targetType: ["set", "number"],
            expectedCode: `Token.asNumberList("[1,2,3]")`,
        },
        // We don't have a token function for boolean lists, so we need to take an asAny
        {
            code: `"[true,false,true]"`,
            type: "string",
            targetType: ["list", "bool"],
            expectedCode: `Token.asAny("[true,false,true]")`,
        },
        {
            code: `"{ foo: 'bar' }"`,
            type: "string",
            targetType: ["map", "string"],
            expectedCode: `Token.asStringMap("{ foo: 'bar' }")`,
        },
        {
            code: `"{ foo: 1 }"`,
            type: "string",
            targetType: ["map", "number"],
            expectedCode: `Token.asNumberMap("{ foo: 1 }")`,
        },
        {
            code: `"{ foo: true }"`,
            type: "string",
            targetType: ["map", "bool"],
            expectedCode: `Token.asBooleanMap("{ foo: true }")`,
        },
        {
            code: `"{ foo: {bar: true} }"`,
            type: "string",
            targetType: ["map", ["map", "boolean"]],
            expectedCode: `Token.asAnyMap("{ foo: {bar: true} }")`,
        },
    ])("should use Token functions %p", ({ code, type, targetType, expectedCode }) => {
        expect(generateCode((0, coerceType_1.coerceType)(scope, expressionify(code), type, targetType))).toEqual(expectedCode);
    });
    it.each([
        {
            code: `aUserDefinedVariable.value`,
            type: "dynamic",
            targetType: "string",
            expectedCode: `aUserDefinedVariable.stringValue`,
        },
        {
            code: `aUserDefinedVariable.value`,
            type: "dynamic",
            targetType: "number",
            expectedCode: `aUserDefinedVariable.numberValue`,
        },
        {
            code: `aUserDefinedVariable.value`,
            type: "dynamic",
            targetType: ["list", "string"],
            expectedCode: `aUserDefinedVariable.listValue`,
        },
        {
            code: `aUserDefinedVariable.value`,
            type: "dynamic",
            targetType: "bool",
            expectedCode: `aUserDefinedVariable.booleanValue`,
        },
    ])("should use TerraformVariables accessors %p", ({ code, type, targetType, expectedCode }) => {
        expect(generateCode((0, coerceType_1.coerceType)(scope, expressionify(code), type, targetType))).toEqual(expectedCode);
    });
    it.each([
        {
            code: `aUserDefinedTerraformLocal.value`,
            type: "dynamic",
            targetType: "string",
            expectedCode: `aUserDefinedTerraformLocal.stringValue`,
        },
        {
            code: `aUserDefinedTerraformLocal.value`,
            type: "dynamic",
            targetType: "number",
            expectedCode: `aUserDefinedTerraformLocal.numberValue`,
        },
        {
            code: `aUserDefinedTerraformLocal.value`,
            type: "dynamic",
            targetType: ["list", "string"],
            expectedCode: `aUserDefinedTerraformLocal.listValue`,
        },
        {
            code: `aUserDefinedTerraformLocal.value`,
            type: "dynamic",
            targetType: "bool",
            expectedCode: `aUserDefinedTerraformLocal.booleanValue`,
        },
    ])("should use TerraformLocal accessors %p", ({ code, type, targetType, expectedCode }) => {
        expect(generateCode((0, coerceType_1.coerceType)(scope, expressionify(code), type, targetType))).toEqual(expectedCode);
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29lcmNlVHlwZS50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29lcmNlVHlwZS50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyw4Q0FBMkM7QUFDM0MsK0RBQXVDO0FBQ3ZDLGlFQUF3QztBQUV4QyxTQUFTLGFBQWEsQ0FBQyxJQUFZO0lBQ2pDLE9BQVEsa0JBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFTLENBQUMsVUFBVSxDQUFDO0FBQ2hELENBQUM7QUFDRCxTQUFTLFlBQVksQ0FBQyxHQUFRO0lBQzVCLE9BQU8sSUFBQSxtQkFBUSxFQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUM1QixDQUFDO0FBRUQsTUFBTSxLQUFLLEdBQVE7SUFDakIsV0FBVyxFQUFFLEVBQUU7SUFDZixTQUFTLEVBQUU7UUFDVCx1QkFBdUIsRUFBRTtZQUN2QixRQUFRLEVBQUUsS0FBSztZQUNmLFlBQVksRUFBRSxzQkFBc0I7U0FDckM7UUFDRCxvQkFBb0IsRUFBRTtZQUNwQixRQUFRLEVBQUUsS0FBSztZQUNmLFlBQVksRUFBRSw0QkFBNEI7U0FDM0M7S0FDRjtDQUNGLENBQUM7QUFFRixRQUFRLENBQUMsWUFBWSxFQUFFLEdBQUcsRUFBRTtJQUMxQixFQUFFLENBQUMsSUFBSSxDQUFDO1FBQ04sRUFBRSxJQUFJLEVBQUUsZUFBZSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRTtRQUNoRSxFQUFFLElBQUksRUFBRSxlQUFlLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFO0tBQ2hFLENBQUMsQ0FBQywrQkFBK0IsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFO1FBQ2pFLE1BQU0sQ0FDSixZQUFZLENBQ1YsSUFBQSx1QkFBVSxFQUFDLEtBQUssRUFBRSxh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QUksRUFBRSxTQUFTO1lBQ2YsVUFBVSxFQUFFLE1BQU07WUFDbEIsWUFBWSxFQUFFLHlDQUF5QztTQUN4RDtLQUNGLENBQUMsQ0FDQSx3Q0FBd0MsRUFDeEMsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxFQUFFLEVBQUU7UUFDM0MsTUFBTSxDQUNKLFlBQVksQ0FDVixJQUFBLHVCQUFVLEVBQUMsS0FBSyxFQUFFLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFXLEVBQUUsVUFBaUIsQ0FBQyxDQUN2RSxDQUNGLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzFCLENBQUMsQ0FDRixDQUFDO0FBQ0osQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuaW1wb3J0IHsgY29lcmNlVHlwZSB9IGZyb20gXCIuLi9jb2VyY2VUeXBlXCI7XG5pbXBvcnQgdGVtcGxhdGUgZnJvbSBcIkBiYWJlbC90ZW1wbGF0ZVwiO1xuaW1wb3J0IGdlbmVyYXRlIGZyb20gXCJAYmFiZWwvZ2VuZXJhdG9yXCI7XG5cbmZ1bmN0aW9uIGV4cHJlc3Npb25pZnkoY29kZTogc3RyaW5nKSB7XG4gIHJldHVybiAodGVtcGxhdGUuYXN0KGNvZGUpIGFzIGFueSkuZXhwcmVzc2lvbjtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZShhc3Q6IGFueSkge1xuICByZXR1cm4gZ2VuZXJhdGUoYXN0KS5jb2RlO1xufVxuXG5jb25zdCBzY29wZTogYW55ID0ge1xuICBpbXBvcnRhYmxlczogW10sXG4gIHZhcmlhYmxlczoge1xuICAgIGFfdXNlcl9kZWZpbmVkX3ZhcmlhYmxlOiB7XG4gICAgICByZXNvdXJjZTogXCJ2YXJcIixcbiAgICAgIHZhcmlhYmxlTmFtZTogXCJhVXNlckRlZmluZWRWYXJpYWJsZVwiLFxuICAgIH0sXG4gICAgYV91c2VyX2RlZmluZWRfbG9jYWw6IHtcbiAgICAgIHJlc291cmNlOiBcInZhclwiLFxuICAgICAgdmFyaWFibGVOYW1lOiBcImFVc2VyRGVmaW5lZFRlcnJhZm9ybUxvY2FsXCIsXG4gICAgfSxcbiAgfSxcbn07XG5cbmRlc2NyaWJlKFwiY29lcmNlVHlwZVwiLCAoKSA9PiB7XG4gIGl0LmVhY2goW1xuICAgIHsgY29kZTogYFwiaGVsbG8td29ybGRcImAsIHR5cGU6IFwic3RyaW5nXCIsIHRhcmdldFR5cGU6IHVuZGVmaW5lZCB9LFxuICAgIHsgY29kZTogYFwiaGVsbG8td29ybGRcImAsIHR5cGU6IFwic3RyaW5nXCIsIHRhcmdldFR5cGU6IFwic3RyaW5nXCIgfSxcbiAgXSkoXCJzaG91bGQgY2hhbmdlIG5vdGhpbmcgZm9yICVwIFwiLCAoeyBjb2RlLCB0eXBlLCB0YXJnZXRUeXBlIH0pID0+IHtcbiAgICBleHBlY3QoXG4gICAgICBnZW5lcmF0ZUNvZGUoXG4gICAgICAgIGNvZXJjZVR5cGUoc2NvcGUsIGV4cHJlc3Npb25pZnkoY29kZSksIHR5cGUgYXMgYW55LCB0YXJnZXRUeXBlIGFzIGFueSlcbiAgICAgIClcbiAgICApLnRvRXF1YWwoY29kZSk7XG4gIH0pO1xuXG4gIGl0LmVhY2goW1xuICAgIHtcbiAgICAgIGNvZGU6IGBcIjMwMFwiYCxcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB0YXJnZXRUeXBlOiBcIm51bWJlclwiLFxuICAgICAgZXhwZWN0ZWRDb2RlOiBgVG9rZW4uYXNOdW1iZXIoXCIzMDBcIilgLFxuICAgIH0sXG4gICAge1xuICAgICAgY29kZTogYDMwMGAsXG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgdGFyZ2V0VHlwZTogXCJzdHJpbmdcIixcbiAgICAgIGV4cGVjdGVkQ29kZTogYFRva2VuLmFzU3RyaW5nKDMwMClgLFxuICAgIH0sXG4gICAge1xuICAgICAgY29kZTogYFwiWydmb28nLCAnYmFyJ11cImAsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgdGFyZ2V0VHlwZTogW1wibGlzdFwiLCBcInN0cmluZ1wiXSxcbiAgICAgIGV4cGVjdGVkQ29kZTogYFRva2VuLmFzTGlzdChcIlsnZm9vJywgJ2JhciddXCIpYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNvZGU6IGBcIlsxLDIsM11cImAsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgdGFyZ2V0VHlwZTogW1wibGlzdFwiLCBcIm51bWJlclwiXSxcbiAgICAgIGV4cGVjdGVkQ29kZTogYFRva2VuLmFzTnVtYmVyTGlzdChcIlsxLDIsM11cIilgLFxuICAgIH0sXG4gICAge1xuICAgICAgY29kZTogYFwiWydmb28nLCAnYmFyJ11cImAsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgdGFyZ2V0VHlwZTogW1wic2V0XCIsIFwic3RyaW5nXCJdLFxuICAgICAgZXhwZWN0ZWRDb2RlOiBgVG9rZW4uYXNMaXN0KFwiWydmb28nLCAnYmFyJ11cIilgLFxuICAgIH0sXG4gICAge1xuICAgICAgY29kZTogYFwiWzEsMiwzXVwiYCxcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB0YXJnZXRUeXBlOiBbXCJzZXRcIiwgXCJudW1iZXJcIl0sXG4gICAgICBleHBlY3RlZENvZGU6IGBUb2tlbi5hc051bWJlckxpc3QoXCJbMSwyLDNdXCIpYCxcbiAgICB9LFxuICAgIC8vIFdlIGRvbid0IGhhdmUgYSB0b2tlbiBmdW5jdGlvbiBmb3IgYm9vbGVhbiBsaXN0cywgc28gd2UgbmVlZCB0byB0YWtlIGFuIGFzQW55XG4gICAge1xuICAgICAgY29kZTogYFwiW3RydWUsZmFsc2UsdHJ1ZV1cImAsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgdGFyZ2V0VHlwZTogW1wibGlzdFwiLCBcImJvb2xcIl0sXG4gICAgICBleHBlY3RlZENvZGU6IGBUb2tlbi5hc0FueShcIlt0cnVlLGZhbHNlLHRydWVdXCIpYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNvZGU6IGBcInsgZm9vOiAnYmFyJyB9XCJgLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHRhcmdldFR5cGU6IFtcIm1hcFwiLCBcInN0cmluZ1wiXSxcbiAgICAgIGV4cGVjdGVkQ29kZTogYFRva2VuLmFzU3RyaW5nTWFwKFwieyBmb286ICdiYXInIH1cIilgLFxuICAgIH0sXG4gICAge1xuICAgICAgY29kZTogYFwieyBmb286IDEgfVwiYCxcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB0YXJnZXRUeXBlOiBbXCJtYXBcIiwgXCJudW1iZXJcIl0sXG4gICAgICBleHBlY3RlZENvZGU6IGBUb2tlbi5hc051bWJlck1hcChcInsgZm9vOiAxIH1cIilgLFxuICAgIH0sXG5cbiAgICB7XG4gICAgICBjb2RlOiBgXCJ7IGZvbzogdHJ1ZSB9XCJgLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHRhcmdldFR5cGU6IFtcIm1hcFwiLCBcImJvb2xcIl0sXG4gICAgICBleHBlY3RlZENvZGU6IGBUb2tlbi5hc0Jvb2xlYW5NYXAoXCJ7IGZvbzogdHJ1ZSB9XCIpYCxcbiAgICB9LFxuXG4gICAge1xuICAgICAgY29kZTogYFwieyBmb286IHtiYXI6IHRydWV9IH1cImAsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgdGFyZ2V0VHlwZTogW1wibWFwXCIsIFtcIm1hcFwiLCBcImJvb2xlYW5cIl1dLFxuICAgICAgZXhwZWN0ZWRDb2RlOiBgVG9rZW4uYXNBbnlNYXAoXCJ7IGZvbzoge2JhcjogdHJ1ZX0gfVwiKWAsXG4gICAgfSxcbiAgXSkoXG4gICAgXCJzaG91bGQgdXNlIFRva2VuIGZ1bmN0aW9ucyAlcFwiLFxuICAgICh7IGNvZGUsIHR5cGUsIHRhcmdldFR5cGUsIGV4cGVjdGVkQ29kZSB9KSA9PiB7XG4gICAgICBleHBlY3QoXG4gICAgICAgIGdlbmVyYXRlQ29kZShcbiAgICAgICAgICBjb2VyY2VUeXBlKHNjb3BlLCBleHByZXNzaW9uaWZ5KGNvZGUpLCB0eXBlIGFzIGFueSwgdGFyZ2V0VHlwZSBhcyBhbnkpXG4gICAgICAgIClcbiAgICAgICkudG9FcXVhbChleHBlY3RlZENvZGUpO1xuICAgIH1cbiAgKTtcblxuICBpdC5lYWNoKFtcbiAgICB7XG4gICAgICBjb2RlOiBgYVVzZXJEZWZpbmVkVmFyaWFibGUudmFsdWVgLFxuICAgICAgdHlwZTogXCJkeW5hbWljXCIsXG4gICAgICB0YXJnZXRUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgZXhwZWN0ZWRDb2RlOiBgYVVzZXJEZWZpbmVkVmFyaWFibGUuc3RyaW5nVmFsdWVgLFxuICAgIH0sXG4gICAge1xuICAgICAgY29kZTogYGFVc2VyRGVmaW5lZFZhcmlhYmxlLnZhbHVlYCxcbiAgICAgIHR5cGU6IFwiZHluYW1pY1wiLFxuICAgICAgdGFyZ2V0VHlwZTogXCJudW1iZXJcIixcbiAgICAgIGV4cGVjdGVkQ29kZTogYGFVc2VyRGVmaW5lZFZhcmlhYmxlLm51bWJlclZhbHVlYCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGNvZGU6IGBhVXNlckRlZmluZWRWYXJpYWJsZS52YWx1ZWAsXG4gICAgICB0eXBlOiBcImR5bmFtaWNcIixcbiAgICAgIHRhcmdldFR5cGU6IFtcImxpc3RcIiwgXCJzdHJpbmdcIl0sXG4gICAgICBleHBlY3RlZENvZGU6IGBhVXNlckRlZmluZWRWYXJpYWJsZS5saXN0VmFsdWVgLFxuICAgIH0sXG4gICAge1xuICAgICAgY29kZTogYGFVc2VyRGVmaW5lZFZhcmlhYmxlLnZhbHVlYCxcbiAgICAgIHR5cGU6IFwiZHluYW1pY1wiLFxuICAgICAgdGFyZ2V0VHlwZTogXCJib29sXCIsXG4gICAgICBleHBlY3RlZENvZGU6IGBhVXNlckRlZmluZWRWYXJpYWJsZS5ib29sZWFuVmFsdWVgLFxuICAgIH0sXG4gIF0pKFxuICAgIFwic2hvdWxkIHVzZSBUZXJyYWZvcm1WYXJpYWJsZXMgYWNjZXNzb3JzICVwXCIsXG4gICAgKHsgY29kZSwgdHlwZSwgdGFyZ2V0VHlwZSwgZXhwZWN0ZWRDb2RlIH0pID0+IHtcbiAgICAgIGV4cGVjdChcbiAgICAgICAgZ2VuZXJhdGVDb2RlKFxuICAgICAgICAgIGNvZXJjZVR5cGUoc2NvcGUsIGV4cHJlc3Npb25pZnkoY29kZSksIHR5cGUgYXMgYW55LCB0YXJnZXRUeXBlIGFzIGFueSlcbiAgICAgICAgKVxuICAgICAgKS50b0VxdWFsKGV4cGVjdGVkQ29kZSk7XG4gICAgfVxuICApO1xuXG4gIGl0LmVhY2goW1xuICAgIHtcbiAgICAgIGNvZGU6IGBhVXNlckRlZmluZWRUZXJyYWZvcm1Mb2NhbC52YWx1ZWAsXG4gICAgICB0eXBlOiBcImR5bmFtaWNcIixcbiAgICAgIHRhcmdldFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBleHBlY3RlZENvZGU6IGBhVXNlckRlZmluZWRUZXJyYWZvcm1Mb2NhbC5zdHJpbmdWYWx1ZWAsXG4gICAgfSxcbiAgICB7XG4gICAgICBjb2RlOiBgYVVzZXJEZWZpbmVkVGVycmFmb3JtTG9jYWwudmFsdWVgLFxuICAgICAgdHlwZTogXCJkeW5hbWljXCIsXG4gICAgICB0YXJnZXRUeXBlOiBcIm51bWJlclwiLFxuICAgICAgZXhwZWN0ZWRDb2RlOiBgYVVzZXJEZWZpbmVkVGVycmFmb3JtTG9jYWwubnVtYmVyVmFsdWVgLFxuICAgIH0sXG4gICAge1xuICAgICAgY29kZTogYGFVc2VyRGVmaW5lZFRlcnJhZm9ybUxvY2FsLnZhbHVlYCxcbiAgICAgIHR5cGU6IFwiZHluYW1pY1wiLFxuICAgICAgdGFyZ2V0VHlwZTogW1wibGlzdFwiLCBcInN0cmluZ1wiXSxcbiAgICAgIGV4cGVjdGVkQ29kZTogYGFVc2VyRGVmaW5lZFRlcnJhZm9ybUxvY2FsLmxpc3RWYWx1ZWAsXG4gICAgfSxcbiAgICB7XG4gICAgICBjb2RlOiBgYVVzZXJEZWZpbmVkVGVycmFmb3JtTG9jYWwudmFsdWVgLFxuICAgICAgdHlwZTogXCJkeW5hbWljXCIsXG4gICAgICB0YXJnZXRUeXBlOiBcImJvb2xcIixcbiAgICAgIGV4cGVjdGVkQ29kZTogYGFVc2VyRGVmaW5lZFRlcnJhZm9ybUxvY2FsLmJvb2xlYW5WYWx1ZWAsXG4gICAgfSxcbiAgXSkoXG4gICAgXCJzaG91bGQgdXNlIFRlcnJhZm9ybUxvY2FsIGFjY2Vzc29ycyAlcFwiLFxuICAgICh7IGNvZGUsIHR5cGUsIHRhcmdldFR5cGUsIGV4cGVjdGVkQ29kZSB9KSA9PiB7XG4gICAgICBleHBlY3QoXG4gICAgICAgIGdlbmVyYXRlQ29kZShcbiAgICAgICAgICBjb2VyY2VUeXBlKHNjb3BlLCBleHByZXNzaW9uaWZ5KGNvZGUpLCB0eXBlIGFzIGFueSwgdGFyZ2V0VHlwZSBhcyBhbnkpXG4gICAgICAgIClcbiAgICAgICkudG9FcXVhbChleHBlY3RlZENvZGUpO1xuICAgIH1cbiAgKTtcbn0pO1xuIl19