"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.attributeNameToCdktfName = exports.isRegistryModule = exports.convertProject = exports.getTerraformConfigFromDir = exports.convert = exports.convertToTypescript = exports.parseProviderRequirements = exports.getParsedHcl = exports.CODE_MARKER = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const hcl2json_1 = require("@cdktf/hcl2json");
const provider_generator_1 = require("@cdktf/provider-generator");
Object.defineProperty(exports, "isRegistryModule", { enumerable: true, get: function () { return provider_generator_1.isRegistryModule; } });
const t = __importStar(require("@babel/types"));
const prettier_1 = __importDefault(require("prettier"));
const path = __importStar(require("path"));
const glob = __importStar(require("glob"));
const fs = __importStar(require("fs"));
const graphology_1 = require("graphology");
const rosetta = __importStar(require("jsii-rosetta"));
const schema_1 = require("./schema");
const references_1 = require("./references");
const generation_1 = require("./generation");
const iteration_1 = require("./iteration");
const provider_1 = require("./provider");
const utils_1 = require("./utils");
const generation_2 = require("./generation");
Object.defineProperty(exports, "attributeNameToCdktfName", { enumerable: true, get: function () { return generation_2.attributeNameToCdktfName; } });
const jsii_rosetta_workarounds_1 = require("./jsii-rosetta-workarounds");
const iteration_2 = require("./iteration");
exports.CODE_MARKER = "// define resources here";
async function getParsedHcl(hcl) {
    utils_1.logger.debug(`Parsing HCL: ${hcl}`);
    // Get the JSON representation of the HCL
    let json;
    try {
        json = await (0, hcl2json_1.parse)("terraform.tf", hcl);
    }
    catch (err) {
        utils_1.logger.error(`Failed to parse HCL: ${err}`);
        throw new Error(`Error: Could not parse HCL, this means either that the HCL passed is invalid or that you found a bug. If the HCL seems valid, please file a bug under https://cdk.tf/bugs/new/convert`);
    }
    // Ensure the JSON representation matches the expected structure
    let plan;
    try {
        plan = schema_1.schema.parse(json);
    }
    catch (err) {
        throw new Error(`Error: HCL-JSON does not conform to schema. This is not expected, please file a bug under https://cdk.tf/bugs/new/convert
Please include this information:
${JSON.stringify(err.errors)}`);
    }
    return plan;
}
exports.getParsedHcl = getParsedHcl;
async function parseProviderRequirements(hcl) {
    utils_1.logger.debug("Parsing provider requirements");
    const plan = await getParsedHcl(hcl);
    return (0, provider_1.getProviderRequirements)(plan);
}
exports.parseProviderRequirements = parseProviderRequirements;
async function convertToTypescript(hcl, providerSchema, codeContainer) {
    var _a;
    utils_1.logger.debug("Converting to typescript");
    const plan = await getParsedHcl(hcl);
    // Each key in the scope needs to be unique, therefore we save them in a set
    // Each variable needs to be unique as well, we save them in a record so we can identify if two variables are the same
    const scope = {
        providerSchema,
        providerGenerator: Object.keys(providerSchema.provider_schemas || {}).reduce((carry, fqpn) => {
            const providerGenerator = new provider_generator_1.TerraformProviderGenerator(new provider_generator_1.CodeMaker(), providerSchema);
            providerGenerator.buildResourceModels(fqpn); // can't use that type on the keys yet, since we are not on TS >=4.4 yet :sadcat:
            return { ...carry, [fqpn]: providerGenerator };
        }, {}),
        constructs: new Set(),
        variables: {},
        hasTokenBasedTypeCoercion: false,
        nodeIds: [],
        importables: [],
        topLevelConfig: {},
    };
    const graph = new graphology_1.DirectedGraph();
    // Get all items in the JSON as a map of id to function that generates the AST
    // We will use this to construct the nodes for a dependency graph
    // We need to use a function here because the same node has different representation based on if it's referenced by another one
    const nodeMap = {
        ...(0, iteration_1.forEachProvider)(scope, plan.provider, generation_1.provider),
        ...(0, iteration_1.forEachGlobal)(scope, "var", plan.variable, generation_1.variable),
        // locals are a special case
        ...(0, iteration_1.forEachGlobal)(scope, "local", Array.isArray(plan.locals)
            ? plan.locals.reduce((carry, locals) => ({ ...carry, ...locals }), {})
            : {}, generation_1.local),
        ...(0, iteration_1.forEachGlobal)(scope, "out", plan.output, generation_1.output),
        ...(0, iteration_1.forEachGlobal)(scope, "module", plan.module, generation_1.modules),
        ...(0, iteration_2.forEachImport)(scope, "import", plan.import, generation_1.imports),
        ...(0, iteration_1.forEachNamespaced)(scope, plan.resource, generation_1.resource),
        ...(0, iteration_1.forEachNamespaced)(scope, plan.data, generation_1.resource, "data"),
    };
    // Add all nodes to the dependency graph so we can detect if an edge is added for an unknown link
    Object.entries(nodeMap).forEach(([key, value]) => {
        utils_1.logger.debug(`Adding node '${key}' to graph`);
        graph.addNode(key, value);
    });
    // Finding references becomes easier of the to be referenced ids are already known
    const nodeIds = Object.keys(nodeMap);
    scope.nodeIds = nodeIds;
    async function addEdges(id, value) {
        (await (0, references_1.findUsedReferences)(nodeIds, value)).forEach((ref) => {
            if (!graph.hasDirectedEdge(ref.referencee.id, id) &&
                graph.hasNode(ref.referencee.id) // in case the referencee is a dynamic variable
            ) {
                if (!graph.hasNode(id)) {
                    throw new Error(`The dependency graph is expected to link from ${ref.referencee.id} to ${id} but ${id} does not exist. 
            These nodes exist: ${graph.nodes().join("\n")}`);
                }
                // The graph should have no self-references
                if (id === ref.referencee.id) {
                    utils_1.logger.debug(`Skipping self-reference for ${id}`);
                    return;
                }
                utils_1.logger.debug(`Adding edge from ${ref.referencee.id} to ${id}`);
                graph.addDirectedEdge(ref.referencee.id, id, { ref });
            }
        });
    }
    // We recursively inspect each resource value to find references to other values
    // We add these to a dependency graph so that the programming code has the right order
    async function addGlobalEdges(_scope, _key, id, value) {
        await addEdges(id, value);
    }
    async function addProviderEdges(_scope, _key, id, value) {
        await addEdges(id, value);
    }
    async function addNamespacedEdges(_scope, _type, _key, id, value) {
        await addEdges(id, value);
    }
    await Promise.all(Object.values({
        ...(0, iteration_1.forEachProvider)(scope, plan.provider, addProviderEdges),
        ...(0, iteration_1.forEachGlobal)(scope, "var", plan.variable, addGlobalEdges),
        // locals are a special case
        ...(0, iteration_1.forEachGlobal)(scope, "local", Array.isArray(plan.locals)
            ? plan.locals.reduce((carry, locals) => ({ ...carry, ...locals }), {})
            : {}, addGlobalEdges),
        ...(0, iteration_1.forEachGlobal)(scope, "out", plan.output, addGlobalEdges),
        ...(0, iteration_1.forEachGlobal)(scope, "module", plan.module, addGlobalEdges),
        ...(0, iteration_1.forEachNamespaced)(scope, plan.resource, addNamespacedEdges),
        ...(0, iteration_1.forEachNamespaced)(scope, plan.data, addNamespacedEdges, "data"),
    }).map(({ code: addEdgesToGraph }) => addEdgesToGraph(graph)));
    utils_1.logger.debug(`Graph: ${JSON.stringify(graph, null, 2)}`);
    utils_1.logger.debug(`Starting to assemble the typescript code`);
    // We traverse the dependency graph to get the unordered JSON nodes into an ordered array
    // where no node is referenced before it's defined
    // As we check that the nodes on both ends of an edge exist we can be sure
    // that no infinite loop exists, there can be no stray dependency on a node
    const expressions = [];
    let nodesToVisit = [...nodeIds];
    // This ensures we detect cycles and don't end up in an endless loop
    let nodesVisitedThisIteration = 0;
    do {
        nodesVisitedThisIteration = 0;
        // Find next nodes to visit
        const nodeExpressionGenerators = graph.mapNodes((nodeId, { code }) => {
            if (!nodesToVisit.includes(nodeId)) {
                return undefined;
            }
            const unresolvedDependencies = graph
                .inNeighbors(nodeId)
                .filter((item) => nodesToVisit.includes(item));
            if (unresolvedDependencies.length === 0) {
                nodesToVisit = nodesToVisit.filter((id) => nodeId !== id);
                nodesVisitedThisIteration = nodesVisitedThisIteration + 1;
                utils_1.logger.debug(`Visiting node ${nodeId}`);
                return code;
            }
            return undefined;
        });
        // Generate the code for the nodes
        for (const code of nodeExpressionGenerators) {
            if (code) {
                expressions.push(...(await code(graph)));
            }
        }
        utils_1.logger.debug(`${nodesToVisit.length} unvisited nodes: ${nodesToVisit.join(", ")}`);
    } while (nodesToVisit.length > 0 && nodesVisitedThisIteration != 0);
    if (nodesToVisit.length > 0) {
        throw new Error(`There are ${nodesToVisit.length} terraform elements that could not be visited. 
      This is likely due to a cycle in the dependency graph. 
      These nodes are: ${nodesToVisit.join(", ")}`);
    }
    utils_1.logger.debug(`${nodesToVisit.length} unvisited nodes: ${nodesToVisit.join(", ")}`);
    const backendExpressions = (await Promise.all(((_a = plan.terraform) === null || _a === void 0 ? void 0 : _a.map((terraform) => (0, generation_1.backendToExpression)(scope, terraform.backend))) || [Promise.resolve([])])).reduce((carry, item) => [...carry, ...item], []);
    utils_1.logger.debug(`Using these backend expressions: ${JSON.stringify(backendExpressions, null, 2)}`);
    // We collect all module sources
    const moduleRequirements = [
        ...new Set(Object.values(plan.module || {}).reduce((carry, moduleBlock) => [
            ...carry,
            ...moduleBlock.reduce((arr, { source, version }) => [
                ...arr,
                version ? `${source}@${version}` : source,
            ], []),
        ], []) || []),
    ];
    utils_1.logger.debug(`Found these modules: ${JSON.stringify(moduleRequirements, null, 2)}`);
    if (Object.keys(plan.variable || {}).length > 0 && expressions.length > 0) {
        expressions[0] = t.addComment(expressions[0], "leading", `Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables`);
    }
    const providerRequirements = (0, provider_1.getProviderRequirements)(plan);
    utils_1.logger.debug(`Found these provider requirements: ${JSON.stringify(providerRequirements, null, 2)}`);
    // We add a comment if there are providers with missing schema information
    const providersLackingSchema = Object.keys(providerRequirements).filter((providerName) => providerName !== "terraform" &&
        !Object.keys(providerSchema.provider_schemas || {}).some((schemaName) => schemaName.endsWith(providerName)));
    utils_1.logger.debug(`${providersLackingSchema.length} providers lack schema information: ${providersLackingSchema.join(", ")}`);
    if (providersLackingSchema.length > 0) {
        expressions[0] = t.addComment(expressions[0], "leading", `The following providers are missing schema information and might need manual adjustments to synthesize correctly: ${providersLackingSchema.join(", ")}.
For a more precise conversion please use the --provider flag in convert.`);
    }
    // Always add constructs
    scope.importables.push({
        constructName: "Construct",
        provider: "constructs",
    });
    if (scope.hasTokenBasedTypeCoercion) {
        scope.importables.push({
            constructName: "Token",
            provider: "cdktf",
        });
    }
    // Add specific import for codeContainer
    (0, generation_1.addImportForCodeContainer)(scope, codeContainer);
    const constructImports = (0, generation_1.buildImports)(scope.importables);
    const code = [...(backendExpressions || []), ...expressions];
    const configTypeName = Object.keys(scope.topLevelConfig).length > 0 ? "MyConfig" : undefined;
    const classConfig = configTypeName
        ? [(0, generation_1.generateConfigType)(configTypeName, scope.topLevelConfig)]
        : [];
    // We split up the generated code so that users can have more control over what to insert where
    return {
        // TODO: Remove imports and code because rosetta won't be able to translate them
        all: await (0, generation_1.gen)([
            ...constructImports,
            ...(0, generation_1.moduleImports)(plan.module),
            ...classConfig,
            (0, generation_1.wrapCodeInConstructor)(codeContainer, code, "MyConvertedCode", configTypeName),
        ]),
        imports: await (0, generation_1.gen)([...constructImports, ...(0, generation_1.moduleImports)(plan.module)]),
        code: await (0, generation_1.gen)(code),
        providers: Object.entries(providerRequirements).map(([source, version]) => version === "*" ? source : `${source}@${version}`),
        modules: moduleRequirements,
        // We track some usage data to make it easier to understand what is used
        stats: {
            numberOfModules: moduleRequirements.length,
            numberOfProviders: Object.keys(providerRequirements).length,
            resources: (0, iteration_1.resourceStats)(plan.resource || {}),
            data: (0, iteration_1.resourceStats)(plan.data || {}),
            convertedLines: hcl.split("\n").length,
        },
    };
}
exports.convertToTypescript = convertToTypescript;
const translators = {
    python: {
        visitor: () => new rosetta.PythonVisitor(),
        postTranslationMutation: jsii_rosetta_workarounds_1.replacePythonImports,
    },
    java: {
        visitor: () => new rosetta.JavaVisitor(),
        postTranslationMutation: jsii_rosetta_workarounds_1.replaceJavaImports,
    },
    csharp: {
        visitor: () => new rosetta.CSharpVisitor(),
        postTranslationMutation: jsii_rosetta_workarounds_1.replaceCsharpImports,
    },
    go: {
        visitor: () => new rosetta.GoVisitor(),
        postTranslationMutation: jsii_rosetta_workarounds_1.replaceGoImports,
    },
};
function translatorForLanguage(language) {
    return (file, throwOnTranslationError) => {
        const { visitor, postTranslationMutation } = translators[language];
        const { translation, diagnostics } = rosetta.translateTypeScript(file, visitor(), throwOnTranslationError ? { includeCompilerDiagnostics: true } : {});
        if (throwOnTranslationError &&
            diagnostics.filter((diag) => diag.isError).length > 0) {
            utils_1.logger.debug(`Could not translate TS to ${language}:\n${file.contents}`);
            throw new Error(`Could not translate TS to ${language}: ${diagnostics
                .map((diag) => diag.formattedMessage)
                .join("\n")}`);
        }
        return postTranslationMutation(translation);
    };
}
async function convert(hcl, { language, providerSchema, throwOnTranslationError = false, codeContainer = "cdktf.TerraformStack", }) {
    const fileName = "terraform.tf";
    const translater = language === "typescript"
        ? (file, _throwOnTranslationError) => file.contents
        : translatorForLanguage(language);
    if (!translater) {
        throw new Error("Unsupported language used: " + language);
    }
    const tsCode = await convertToTypescript(hcl, providerSchema, codeContainer);
    return {
        ...tsCode,
        all: translater({ fileName, contents: tsCode.all }, throwOnTranslationError),
        imports: translater({ fileName, contents: tsCode.imports }, false),
        code: translater({ fileName, contents: tsCode.code }, false),
        stats: { ...tsCode.stats, language },
    };
}
exports.convert = convert;
function getTerraformConfigFromDir(importPath) {
    const absPath = path.resolve(importPath);
    const fileContents = glob
        .sync("./*.tf", { cwd: absPath })
        .map((p) => fs.readFileSync(path.resolve(absPath, p), "utf8"));
    return fileContents.join("\n");
}
exports.getTerraformConfigFromDir = getTerraformConfigFromDir;
async function convertProject(combinedHcl, { language, providerSchema }) {
    if (language !== "typescript") {
        throw new Error("Unsupported language used: " + language);
    }
    const { imports, code, providers, modules: tfModules, stats, } = await convert(combinedHcl, {
        language,
        providerSchema,
    });
    return {
        code: (inputMainFile) => {
            const importMainFile = [imports, inputMainFile].join("\n");
            const outputMainFile = importMainFile.replace(exports.CODE_MARKER, code);
            return prettier_1.default.format(outputMainFile, { parser: "babel" });
        },
        cdktfJson: (inputCdktfJson) => {
            const cdktfJson = { ...inputCdktfJson };
            cdktfJson.terraformProviders = providers;
            cdktfJson.terraformModules = tfModules;
            return cdktfJson;
        },
        stats,
    };
}
exports.convertProject = convertProject;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMsOENBQXdDO0FBQ3hDLGtFQUltQztBQWdrQjFCLGlHQW5rQlAscUNBQWdCLE9BbWtCTztBQTlqQnpCLGdEQUFrQztBQUNsQyx3REFBZ0M7QUFDaEMsMkNBQTZCO0FBQzdCLDJDQUE2QjtBQUM3Qix1Q0FBeUI7QUFDekIsMkNBQTJDO0FBQzNDLHNEQUF3QztBQUd4QyxxQ0FBa0M7QUFDbEMsNkNBQWtEO0FBQ2xELDZDQWVzQjtBQUV0QiwyQ0FLcUI7QUFDckIseUNBQXFEO0FBQ3JELG1DQUFpQztBQUVqQyw2Q0FBd0Q7QUF5aEI3Qix5R0F6aEJsQixxQ0FBd0IsT0F5aEJrQjtBQXhoQm5ELHlFQUtvQztBQUVwQywyQ0FBNEM7QUFFL0IsUUFBQSxXQUFXLEdBQUcsMEJBQTBCLENBQUM7QUFFL0MsS0FBSyxVQUFVLFlBQVksQ0FBQyxHQUFXO0lBQzVDLGNBQU0sQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDcEMseUNBQXlDO0lBQ3pDLElBQUksSUFBNkIsQ0FBQztJQUNsQyxJQUFJO1FBQ0YsSUFBSSxHQUFHLE1BQU0sSUFBQSxnQkFBSyxFQUFDLGNBQWMsRUFBRSxHQUFHLENBQUMsQ0FBQztLQUN6QztJQUFDLE9BQU8sR0FBRyxFQUFFO1FBQ1osY0FBTSxDQUFDLEtBQUssQ0FBQyx3QkFBd0IsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUM1QyxNQUFNLElBQUksS0FBSyxDQUNiLHVMQUF1TCxDQUN4TCxDQUFDO0tBQ0g7SUFFRCxnRUFBZ0U7SUFDaEUsSUFBSSxJQUE0QixDQUFDO0lBQ2pDLElBQUk7UUFDRixJQUFJLEdBQUcsZUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUMzQjtJ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QWlDQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgSGFzaGlDb3JwLCBJbmNcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNUEwtMi4wXG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gXCJAY2RrdGYvaGNsMmpzb25cIjtcbmltcG9ydCB7XG4gIGlzUmVnaXN0cnlNb2R1bGUsXG4gIFRlcnJhZm9ybVByb3ZpZGVyR2VuZXJhdG9yLFxuICBDb2RlTWFrZXIsXG59IGZyb20gXCJAY2RrdGYvcHJvdmlkZXItZ2VuZXJhdG9yXCI7XG5cbmltcG9ydCAqIGFzIHQgZnJvbSBcIkBiYWJlbC90eXBlc1wiO1xuaW1wb3J0IHByZXR0aWVyIGZyb20gXCJwcmV0dGllclwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0ICogYXMgZ2xvYiBmcm9tIFwiZ2xvYlwiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgeyBEaXJlY3RlZEdyYXBoIH0gZnJvbSBcImdyYXBob2xvZ3lcIjtcbmltcG9ydCAqIGFzIHJvc2V0dGEgZnJvbSBcImpzaWktcm9zZXR0YVwiO1xuaW1wb3J0ICogYXMgeiBmcm9tIFwiem9kXCI7XG5cbmltcG9ydCB7IHNjaGVtYSB9IGZyb20gXCIuL3NjaGVtYVwiO1xuaW1wb3J0IHsgZmluZFVzZWRSZWZlcmVuY2VzIH0gZnJvbSBcIi4vcmVmZXJlbmNlc1wiO1xuaW1wb3J0IHtcbiAgYmFja2VuZFRvRXhwcmVzc2lvbixcbiAgZ2VuLFxuICBsb2NhbCxcbiAgbW9kdWxlSW1wb3J0cyxcbiAgbW9kdWxlcyxcbiAgb3V0cHV0LFxuICBwcm92aWRlcixcbiAgcmVzb3VyY2UsXG4gIHZhcmlhYmxlLFxuICB3cmFwQ29kZUluQ29uc3RydWN0b3IsXG4gIGFkZEltcG9ydEZvckNvZGVDb250YWluZXIsXG4gIGJ1aWxkSW1wb3J0cyxcbiAgZ2VuZXJhdGVDb25maWdUeXBlLFxuICBpbXBvcnRzLFxufSBmcm9tIFwiLi9nZW5lcmF0aW9uXCI7XG5pbXBvcnQgeyBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrLCBQcm9ncmFtU2NvcGUgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHtcbiAgZm9yRWFjaFByb3ZpZGVyLFxuICBmb3JFYWNoR2xvYmFsLFxuICBmb3JFYWNoTmFtZXNwYWNlZCxcbiAgcmVzb3VyY2VTdGF0cyxcbn0gZnJvbSBcIi4vaXRlcmF0aW9uXCI7XG5pbXBvcnQgeyBnZXRQcm92aWRlclJlcXVpcmVtZW50cyB9IGZyb20gXCIuL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgRlFQTiB9IGZyb20gXCJAY2RrdGYvcHJvdmlkZXItc2NoZW1hXCI7XG5pbXBvcnQgeyBhdHRyaWJ1dGVOYW1lVG9DZGt0Zk5hbWUgfSBmcm9tIFwiLi9nZW5lcmF0aW9uXCI7XG5pbXBvcnQge1xuICByZXBsYWNlQ3NoYXJwSW1wb3J0cyxcbiAgcmVwbGFjZUdvSW1wb3J0cyxcbiAgcmVwbGFjZUphdmFJbXBvcnRzLFxuICByZXBsYWNlUHl0aG9uSW1wb3J0cyxcbn0gZnJvbSBcIi4vanNpaS1yb3NldHRhLXdvcmthcm91bmRzXCI7XG5pbXBvcnQgeyBQcm92aWRlclNjaGVtYSB9IGZyb20gXCJAY2RrdGYvY29tbW9uc1wiO1xuaW1wb3J0IHsgZm9yRWFjaEltcG9ydCB9IGZyb20gXCIuL2l0ZXJhdGlvblwiO1xuXG5leHBvcnQgY29uc3QgQ09ERV9NQVJLRVIgPSBcIi8vIGRlZmluZSByZXNvdXJjZXMgaGVyZVwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGFyc2VkSGNsKGhjbDogc3RyaW5nKSB7XG4gIGxvZ2dlci5kZWJ1ZyhgUGFyc2luZyBIQ0w6ICR7aGNsfWApO1xuICAvLyBHZXQgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIEhDTFxuICBsZXQganNvbjogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIHRyeSB7XG4gICAganNvbiA9IGF3YWl0IHBhcnNlKFwidGVycmFmb3JtLnRmXCIsIGhjbCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHBhcnNlIEhDTDogJHtlcnJ9YCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEVycm9yOiBDb3VsZCBub3QgcGFyc2UgSENMLCB0aGlzIG1lYW5zIGVpdGhlciB0aGF0IHRoZSBIQ0wgcGFzc2VkIGlzIGludmFsaWQgb3IgdGhhdCB5b3UgZm91bmQgYSBidWcuIElmIHRoZSBIQ0wgc2VlbXMgdmFsaWQsIHBsZWFzZSBmaWxlIGEgYnVnIHVuZGVyIGh0dHBzOi8vY2RrLnRmL2J1Z3MvbmV3L2NvbnZlcnRgXG4gICAgKTtcbiAgfVxuXG4gIC8vIEVuc3VyZSB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBtYXRjaGVzIHRoZSBleHBlY3RlZCBzdHJ1Y3R1cmVcbiAgbGV0IHBsYW46IHouaW5mZXI8dHlwZW9mIHNjaGVtYT47XG4gIHRyeSB7XG4gICAgcGxhbiA9IHNjaGVtYS5wYXJzZShqc29uKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvcjogSENMLUpTT04gZG9lcyBub3QgY29uZm9ybSB0byBzY2hlbWEuIFRoaXMgaXMgbm90IGV4cGVjdGVkLCBwbGVhc2UgZmlsZSBhIGJ1ZyB1bmRlciBodHRwczovL2Nkay50Zi9idWdzL25ldy9jb252ZXJ0XG5QbGVhc2UgaW5jbHVkZSB0aGlzIGluZm9ybWF0aW9uOlxuJHtKU09OLnN0cmluZ2lmeSgoZXJyIGFzIHouWm9kRXJyb3IpLmVycm9ycyl9YCk7XG4gIH1cblxuICByZXR1cm4gcGxhbjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlUHJvdmlkZXJSZXF1aXJlbWVudHMoaGNsOiBzdHJpbmcpIHtcbiAgbG9nZ2VyLmRlYnVnKFwiUGFyc2luZyBwcm92aWRlciByZXF1aXJlbWVudHNcIik7XG4gIGNvbnN0IHBsYW4gPSBhd2FpdCBnZXRQYXJzZWRIY2woaGNsKTtcbiAgcmV0dXJuIGdldFByb3ZpZGVyUmVxdWlyZW1lbnRzKHBsYW4pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29udmVydFRvVHlwZXNjcmlwdChcbiAgaGNsOiBzdHJpbmcsXG4gIHByb3ZpZGVyU2NoZW1hOiBQcm92aWRlclNjaGVtYSxcbiAgY29kZUNvbnRhaW5lcjogc3RyaW5nXG4pIHtcbiAgbG9nZ2VyLmRlYnVnKFwiQ29udmVydGluZyB0byB0eXBlc2NyaXB0XCIpO1xuICBjb25zdCBwbGFuID0gYXdhaXQgZ2V0UGFyc2VkSGNsKGhjbCk7XG5cbiAgLy8gRWFjaCBrZXkgaW4gdGhlIHNjb3BlIG5lZWRzIHRvIGJlIHVuaXF1ZSwgdGhlcmVmb3JlIHdlIHNhdmUgdGhlbSBpbiBhIHNldFxuICAvLyBFYWNoIHZhcmlhYmxlIG5lZWRzIHRvIGJlIHVuaXF1ZSBhcyB3ZWxsLCB3ZSBzYXZlIHRoZW0gaW4gYSByZWNvcmQgc28gd2UgY2FuIGlkZW50aWZ5IGlmIHR3byB2YXJpYWJsZXMgYXJlIHRoZSBzYW1lXG4gIGNvbnN0IHNjb3BlOiBQcm9ncmFtU2NvcGUgPSB7XG4gICAgcHJvdmlkZXJTY2hlbWEsXG4gICAgcHJvdmlkZXJHZW5lcmF0b3I6IE9iamVjdC5rZXlzKFxuICAgICAgcHJvdmlkZXJTY2hlbWEucHJvdmlkZXJfc2NoZW1hcyB8fCB7fVxuICAgICkucmVkdWNlKChjYXJyeSwgZnFwbikgPT4ge1xuICAgICAgY29uc3QgcHJvdmlkZXJHZW5lcmF0b3IgPSBuZXcgVGVycmFmb3JtUHJvdmlkZXJHZW5lcmF0b3IoXG4gICAgICAgIG5ldyBDb2RlTWFrZXIoKSxcbiAgICAgICAgcHJvdmlkZXJTY2hlbWFcbiAgICAgICk7XG4gICAgICBwcm92aWRlckdlbmVyYXRvci5idWlsZFJlc291cmNlTW9kZWxzKGZxcG4gYXMgRlFQTik7IC8vIGNhbid0IHVzZSB0aGF0IHR5cGUgb24gdGhlIGtleXMgeWV0LCBzaW5jZSB3ZSBhcmUgbm90IG9uIFRTID49NC40IHlldCA6c2FkY2F0OlxuICAgICAgcmV0dXJuIHsgLi4uY2FycnksIFtmcXBuXTogcHJvdmlkZXJHZW5lcmF0b3IgfTtcbiAgICB9LCB7fSksXG4gICAgY29uc3RydWN0czogbmV3IFNldDxzdHJpbmc+KCksXG4gICAgdmFyaWFibGVzOiB7fSxcbiAgICBoYXNUb2tlbkJhc2VkVHlwZUNvZXJjaW9uOiBmYWxzZSxcbiAgICBub2RlSWRzOiBbXSxcbiAgICBpbXBvcnRhYmxlczogW10sXG4gICAgdG9wTGV2ZWxDb25maWc6IHt9LFxuICB9O1xuXG4gIGNvbnN0IGdyYXBoID0gbmV3IERpcmVjdGVkR3JhcGg8e1xuICAgIGNvZGU6IChcbiAgICAgIGc6IERpcmVjdGVkR3JhcGg8YW55PlxuICAgICkgPT4gUHJvbWlzZTxBcnJheTx0LlN0YXRlbWVudCB8IHQuVmFyaWFibGVEZWNsYXJhdGlvbj4+O1xuICB9PigpO1xuXG4gIC8vIEdldCBhbGwgaXRlbXMgaW4gdGhlIEpTT04gYXMgYSBtYXAgb2YgaWQgdG8gZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhlIEFTVFxuICAvLyBXZSB3aWxsIHVzZSB0aGlzIHRvIGNvbnN0cnVjdCB0aGUgbm9kZXMgZm9yIGEgZGVwZW5kZW5jeSBncmFwaFxuICAvLyBXZSBuZWVkIHRvIHVzZSBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZSB0aGUgc2FtZSBub2RlIGhhcyBkaWZmZXJlbnQgcmVwcmVzZW50YXRpb24gYmFzZWQgb24gaWYgaXQncyByZWZlcmVuY2VkIGJ5IGFub3RoZXIgb25lXG4gIGNvbnN0IG5vZGVNYXA6IFJlY29yZDxcbiAgICBzdHJpbmcsXG4gICAge1xuICAgICAgY29kZTogKFxuICAgICAgICBnOiB0eXBlb2YgZ3JhcGhcbiAgICAgICkgPT4gUHJvbWlzZTxBcnJheTx0LlN0YXRlbWVudCB8IHQuVmFyaWFibGVEZWNsYXJhdGlvbj4+O1xuICAgICAgdmFsdWU6IHVua25vd247XG4gICAgfVxuICA+ID0ge1xuICAgIC4uLmZvckVhY2hQcm92aWRlcihzY29wZSwgcGxhbi5wcm92aWRlciwgcHJvdmlkZXIpLFxuICAgIC4uLmZvckVhY2hHbG9iYWwoc2NvcGUsIFwidmFyXCIsIHBsYW4udmFyaWFibGUsIHZhcmlhYmxlKSxcbiAgICAvLyBsb2NhbHMgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgLi4uZm9yRWFjaEdsb2JhbChcbiAgICAgIHNjb3BlLFxuICAgICAgXCJsb2NhbFwiLFxuICAgICAgQXJyYXkuaXNBcnJheShwbGFuLmxvY2FscylcbiAgICAgICAgPyBwbGFuLmxvY2Fscy5yZWR1Y2UoKGNhcnJ5LCBsb2NhbHMpID0+ICh7IC4uLmNhcnJ5LCAuLi5sb2NhbHMgfSksIHt9KVxuICAgICAgICA6IHt9LFxuICAgICAgbG9jYWxcbiAgICApLFxuICAgIC4uLmZvckVhY2hHbG9iYWwoc2NvcGUsIFwib3V0XCIsIHBsYW4ub3V0cHV0LCBvdXRwdXQpLFxuICAgIC4uLmZvckVhY2hHbG9iYWwoc2NvcGUsIFwibW9kdWxlXCIsIHBsYW4ubW9kdWxlLCBtb2R1bGVzKSxcbiAgICAuLi5mb3JFYWNoSW1wb3J0KHNjb3BlLCBcImltcG9ydFwiLCBwbGFuLmltcG9ydCwgaW1wb3J0cyksXG4gICAgLi4uZm9yRWFjaE5hbWVzcGFjZWQoc2NvcGUsIHBsYW4ucmVzb3VyY2UsIHJlc291cmNlKSxcbiAgICAuLi5mb3JFYWNoTmFtZXNwYWNlZChzY29wZSwgcGxhbi5kYXRhLCByZXNvdXJjZSwgXCJkYXRhXCIpLFxuICB9O1xuXG4gIC8vIEFkZCBhbGwgbm9kZXMgdG8gdGhlIGRlcGVuZGVuY3kgZ3JhcGggc28gd2UgY2FuIGRldGVjdCBpZiBhbiBlZGdlIGlzIGFkZGVkIGZvciBhbiB1bmtub3duIGxpbmtcbiAgT2JqZWN0LmVudHJpZXMobm9kZU1hcCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKGBBZGRpbmcgbm9kZSAnJHtrZXl9JyB0byBncmFwaGApO1xuICAgIGdyYXBoLmFkZE5vZGUoa2V5LCB2YWx1ZSk7XG4gIH0pO1xuXG4gIC8vIEZpbmRpbmcgcmVmZXJlbmNlcyBiZWNvbWVzIGVhc2llciBvZiB0aGUgdG8gYmUgcmVmZXJlbmNlZCBpZHMgYXJlIGFscmVhZHkga25vd25cbiAgY29uc3Qgbm9kZUlkcyA9IE9iamVjdC5rZXlzKG5vZGVNYXApO1xuICBzY29wZS5ub2RlSWRzID0gbm9kZUlkcztcbiAgYXN5bmMgZnVuY3Rpb24gYWRkRWRnZXMoaWQ6IHN0cmluZywgdmFsdWU6IFRlcnJhZm9ybVJlc291cmNlQmxvY2spIHtcbiAgICAoYXdhaXQgZmluZFVzZWRSZWZlcmVuY2VzKG5vZGVJZHMsIHZhbHVlKSkuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICFncmFwaC5oYXNEaXJlY3RlZEVkZ2UocmVmLnJlZmVyZW5jZWUuaWQsIGlkKSAmJlxuICAgICAgICBncmFwaC5oYXNOb2RlKHJlZi5yZWZlcmVuY2VlLmlkKSAvLyBpbiBjYXNlIHRoZSByZWZlcmVuY2VlIGlzIGEgZHluYW1pYyB2YXJpYWJsZVxuICAgICAgKSB7XG4gICAgICAgIGlmICghZ3JhcGguaGFzTm9kZShpZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVGhlIGRlcGVuZGVuY3kgZ3JhcGggaXMgZXhwZWN0ZWQgdG8gbGluayBmcm9tICR7XG4gICAgICAgICAgICAgIHJlZi5yZWZlcmVuY2VlLmlkXG4gICAgICAgICAgICB9IHRvICR7aWR9IGJ1dCAke2lkfSBkb2VzIG5vdCBleGlzdC4gXG4gICAgICAgICAgICBUaGVzZSBub2RlcyBleGlzdDogJHtncmFwaC5ub2RlcygpLmpvaW4oXCJcXG5cIil9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZ3JhcGggc2hvdWxkIGhhdmUgbm8gc2VsZi1yZWZlcmVuY2VzXG4gICAgICAgIGlmIChpZCA9PT0gcmVmLnJlZmVyZW5jZWUuaWQpIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoYFNraXBwaW5nIHNlbGYtcmVmZXJlbmNlIGZvciAke2lkfWApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgQWRkaW5nIGVkZ2UgZnJvbSAke3JlZi5yZWZlcmVuY2VlLmlkfSB0byAke2lkfWApO1xuICAgICAgICBncmFwaC5hZGREaXJlY3RlZEVkZ2UocmVmLnJlZmVyZW5jZWUuaWQsIGlkLCB7IHJlZiB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFdlIHJlY3Vyc2l2ZWx5IGluc3BlY3QgZWFjaCByZXNvdXJjZSB2YWx1ZSB0byBmaW5kIHJlZmVyZW5jZXMgdG8gb3RoZXIgdmFsdWVzXG4gIC8vIFdlIGFkZCB0aGVzZSB0byBhIGRlcGVuZGVuY3kgZ3JhcGggc28gdGhhdCB0aGUgcHJvZ3JhbW1pbmcgY29kZSBoYXMgdGhlIHJpZ2h0IG9yZGVyXG4gIGFzeW5jIGZ1bmN0aW9uIGFkZEdsb2JhbEVkZ2VzKFxuICAgIF9zY29wZTogUHJvZ3JhbVNjb3BlLFxuICAgIF9rZXk6IHN0cmluZyxcbiAgICBpZDogc3RyaW5nLFxuICAgIHZhbHVlOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrXG4gICkge1xuICAgIGF3YWl0IGFkZEVkZ2VzKGlkLCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gYWRkUHJvdmlkZXJFZGdlcyhcbiAgICBfc2NvcGU6IFByb2dyYW1TY29wZSxcbiAgICBfa2V5OiBzdHJpbmcsXG4gICAgaWQ6IHN0cmluZyxcbiAgICB2YWx1ZTogVGVycmFmb3JtUmVzb3VyY2VCbG9ja1xuICApIHtcbiAgICBhd2FpdCBhZGRFZGdlcyhpZCwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZE5hbWVzcGFjZWRFZGdlcyhcbiAgICBfc2NvcGU6IFByb2dyYW1TY29wZSxcbiAgICBfdHlwZTogc3RyaW5nLFxuICAgIF9rZXk6IHN0cmluZyxcbiAgICBpZDogc3RyaW5nLFxuICAgIHZhbHVlOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrXG4gICkge1xuICAgIGF3YWl0IGFkZEVkZ2VzKGlkLCB2YWx1ZSk7XG4gIH1cblxuICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBPYmplY3QudmFsdWVzKHtcbiAgICAgIC4uLmZvckVhY2hQcm92aWRlcihzY29wZSwgcGxhbi5wcm92aWRlciwgYWRkUHJvdmlkZXJFZGdlcyksXG4gICAgICAuLi5mb3JFYWNoR2xvYmFsKHNjb3BlLCBcInZhclwiLCBwbGFuLnZhcmlhYmxlLCBhZGRHbG9iYWxFZGdlcyksXG4gICAgICAvLyBsb2NhbHMgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgICAuLi5mb3JFYWNoR2xvYmFsKFxuICAgICAgICBzY29wZSxcbiAgICAgICAgXCJsb2NhbFwiLFxuICAgICAgICBBcnJheS5pc0FycmF5KHBsYW4ubG9jYWxzKVxuICAgICAgICAgID8gcGxhbi5sb2NhbHMucmVkdWNlKChjYXJyeSwgbG9jYWxzKSA9PiAoeyAuLi5jYXJyeSwgLi4ubG9jYWxzIH0pLCB7fSlcbiAgICAgICAgICA6IHt9LFxuICAgICAgICBhZGRHbG9iYWxFZGdlc1xuICAgICAgKSxcbiAgICAgIC4uLmZvckVhY2hHbG9iYWwoc2NvcGUsIFwib3V0XCIsIHBsYW4ub3V0cHV0LCBhZGRHbG9iYWxFZGdlcyksXG4gICAgICAuLi5mb3JFYWNoR2xvYmFsKHNjb3BlLCBcIm1vZHVsZVwiLCBwbGFuLm1vZHVsZSwgYWRkR2xvYmFsRWRnZXMpLFxuICAgICAgLi4uZm9yRWFjaE5hbWVzcGFjZWQoc2NvcGUsIHBsYW4ucmVzb3VyY2UsIGFkZE5hbWVzcGFjZWRFZGdlcyksXG4gICAgICAuLi5mb3JFYWNoTmFtZXNwYWNlZChzY29wZSwgcGxhbi5kYXRhLCBhZGROYW1lc3BhY2VkRWRnZXMsIFwiZGF0YVwiKSxcbiAgICB9KS5tYXAoKHsgY29kZTogYWRkRWRnZXNUb0dyYXBoIH0pID0+IGFkZEVkZ2VzVG9HcmFwaChncmFwaCkpXG4gICk7XG5cbiAgbG9nZ2VyLmRlYnVnKGBHcmFwaDogJHtKU09OLnN0cmluZ2lmeShncmFwaCwgbnVsbCwgMil9YCk7XG4gIGxvZ2dlci5kZWJ1ZyhgU3RhcnRpbmcgdG8gYXNzZW1ibGUgdGhlIHR5cGVzY3JpcHQgY29kZWApO1xuICAvLyBXZSB0cmF2ZXJzZSB0aGUgZGVwZW5kZW5jeSBncmFwaCB0byBnZXQgdGhlIHVub3JkZXJlZCBKU09OIG5vZGVzIGludG8gYW4gb3JkZXJlZCBhcnJheVxuICAvLyB3aGVyZSBubyBub2RlIGlzIHJlZmVyZW5jZWQgYmVmb3JlIGl0J3MgZGVmaW5lZFxuICAvLyBBcyB3ZSBjaGVjayB0aGF0IHRoZSBub2RlcyBvbiBib3RoIGVuZHMgb2YgYW4gZWRnZSBleGlzdCB3ZSBjYW4gYmUgc3VyZVxuICAvLyB0aGF0IG5vIGluZmluaXRlIGxvb3AgZXhpc3RzLCB0aGVyZSBjYW4gYmUgbm8gc3RyYXkgZGVwZW5kZW5jeSBvbiBhIG5vZGVcbiAgY29uc3QgZXhwcmVzc2lvbnM6IHQuU3RhdGVtZW50W10gPSBbXTtcbiAgbGV0IG5vZGVzVG9WaXNpdCA9IFsuLi5ub2RlSWRzXTtcbiAgLy8gVGhpcyBlbnN1cmVzIHdlIGRldGVjdCBjeWNsZXMgYW5kIGRvbid0IGVuZCB1cCBpbiBhbiBlbmRsZXNzIGxvb3BcbiAgbGV0IG5vZGVzVmlzaXRlZFRoaXNJdGVyYXRpb24gPSAwO1xuICBkbyB7XG4gICAgbm9kZXNWaXNpdGVkVGhpc0l0ZXJhdGlvbiA9IDA7XG5cbiAgICAvLyBGaW5kIG5leHQgbm9kZXMgdG8gdmlzaXRcbiAgICBjb25zdCBub2RlRXhwcmVzc2lvbkdlbmVyYXRvcnMgPSBncmFwaC5tYXBOb2Rlcygobm9kZUlkLCB7IGNvZGUgfSkgPT4ge1xuICAgICAgaWYgKCFub2Rlc1RvVmlzaXQuaW5jbHVkZXMobm9kZUlkKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1bnJlc29sdmVkRGVwZW5kZW5jaWVzID0gZ3JhcGhcbiAgICAgICAgLmluTmVpZ2hib3JzKG5vZGVJZClcbiAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gbm9kZXNUb1Zpc2l0LmluY2x1ZGVzKGl0ZW0pKTtcblxuICAgICAgaWYgKHVucmVzb2x2ZWREZXBlbmRlbmNpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5vZGVzVG9WaXNpdCA9IG5vZGVzVG9WaXNpdC5maWx0ZXIoKGlkKSA9PiBub2RlSWQgIT09IGlkKTtcbiAgICAgICAgbm9kZXNWaXNpdGVkVGhpc0l0ZXJhdGlvbiA9IG5vZGVzVmlzaXRlZFRoaXNJdGVyYXRpb24gKyAxO1xuXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgVmlzaXRpbmcgbm9kZSAke25vZGVJZH1gKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgLy8gR2VuZXJhdGUgdGhlIGNvZGUgZm9yIHRoZSBub2Rlc1xuICAgIGZvciAoY29uc3QgY29kZSBvZiBub2RlRXhwcmVzc2lvbkdlbmVyYXRvcnMpIHtcbiAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goLi4uKGF3YWl0IGNvZGUoZ3JhcGgpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgYCR7bm9kZXNUb1Zpc2l0Lmxlbmd0aH0gdW52aXNpdGVkIG5vZGVzOiAke25vZGVzVG9WaXNpdC5qb2luKFwiLCBcIil9YFxuICAgICk7XG4gIH0gd2hpbGUgKG5vZGVzVG9WaXNpdC5sZW5ndGggPiAwICYmIG5vZGVzVmlzaXRlZFRoaXNJdGVyYXRpb24gIT0gMCk7XG5cbiAgaWYgKG5vZGVzVG9WaXNpdC5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZXJlIGFyZSAke1xuICAgICAgICBub2Rlc1RvVmlzaXQubGVuZ3RoXG4gICAgICB9IHRlcnJhZm9ybSBlbGVtZW50cyB0aGF0IGNvdWxkIG5vdCBiZSB2aXNpdGVkLiBcbiAgICAgIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBhIGN5Y2xlIGluIHRoZSBkZXBlbmRlbmN5IGdyYXBoLiBcbiAgICAgIFRoZXNlIG5vZGVzIGFyZTogJHtub2Rlc1RvVmlzaXQuam9pbihcIiwgXCIpfWBcbiAgICApO1xuICB9XG5cbiAgbG9nZ2VyLmRlYnVnKFxuICAgIGAke25vZGVzVG9WaXNpdC5sZW5ndGh9IHVudmlzaXRlZCBub2RlczogJHtub2Rlc1RvVmlzaXQuam9pbihcIiwgXCIpfWBcbiAgKTtcblxuICBjb25zdCBiYWNrZW5kRXhwcmVzc2lvbnMgPSAoXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBwbGFuLnRlcnJhZm9ybT8ubWFwKCh0ZXJyYWZvcm0pID0+XG4gICAgICAgIGJhY2tlbmRUb0V4cHJlc3Npb24oc2NvcGUsIHRlcnJhZm9ybS5iYWNrZW5kKVxuICAgICAgKSB8fCBbUHJvbWlzZS5yZXNvbHZlKFtdKV1cbiAgICApXG4gICkucmVkdWNlKChjYXJyeSwgaXRlbSkgPT4gWy4uLmNhcnJ5LCAuLi5pdGVtXSwgW10pO1xuXG4gIGxvZ2dlci5kZWJ1ZyhcbiAgICBgVXNpbmcgdGhlc2UgYmFja2VuZCBleHByZXNzaW9uczogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgIGJhY2tlbmRFeHByZXNzaW9ucyxcbiAgICAgIG51bGwsXG4gICAgICAyXG4gICAgKX1gXG4gICk7XG5cbiAgLy8gV2UgY29sbGVjdCBhbGwgbW9kdWxlIHNvdXJjZXNcbiAgY29uc3QgbW9kdWxlUmVxdWlyZW1lbnRzID0gW1xuICAgIC4uLm5ldyBTZXQoXG4gICAgICBPYmplY3QudmFsdWVzKHBsYW4ubW9kdWxlIHx8IHt9KS5yZWR1Y2UoXG4gICAgICAgIChjYXJyeSwgbW9kdWxlQmxvY2spID0+IFtcbiAgICAgICAgICAuLi5jYXJyeSxcbiAgICAgICAgICAuLi5tb2R1bGVCbG9jay5yZWR1Y2UoXG4gICAgICAgICAgICAoYXJyLCB7IHNvdXJjZSwgdmVyc2lvbiB9KSA9PiBbXG4gICAgICAgICAgICAgIC4uLmFycixcbiAgICAgICAgICAgICAgdmVyc2lvbiA/IGAke3NvdXJjZX1AJHt2ZXJzaW9ufWAgOiBzb3VyY2UsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW10gYXMgc3RyaW5nW11cbiAgICAgICAgICApLFxuICAgICAgICBdLFxuICAgICAgICBbXSBhcyBzdHJpbmdbXVxuICAgICAgKSB8fCBbXVxuICAgICksXG4gIF07XG5cbiAgbG9nZ2VyLmRlYnVnKFxuICAgIGBGb3VuZCB0aGVzZSBtb2R1bGVzOiAke0pTT04uc3RyaW5naWZ5KG1vZHVsZVJlcXVpcmVtZW50cywgbnVsbCwgMil9YFxuICApO1xuXG4gIGlmIChPYmplY3Qua2V5cyhwbGFuLnZhcmlhYmxlIHx8IHt9KS5sZW5ndGggPiAwICYmIGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICBleHByZXNzaW9uc1swXSA9IHQuYWRkQ29tbWVudChcbiAgICAgIGV4cHJlc3Npb25zWzBdLFxuICAgICAgXCJsZWFkaW5nXCIsXG4gICAgICBgVGVycmFmb3JtIFZhcmlhYmxlcyBhcmUgbm90IGFsd2F5cyB0aGUgYmVzdCBmaXQgZm9yIGdldHRpbmcgaW5wdXRzIGluIHRoZSBjb250ZXh0IG9mIFRlcnJhZm9ybSBDREsuXG5Zb3UgY2FuIHJlYWQgbW9yZSBhYm91dCB0aGlzIGF0IGh0dHBzOi8vY2RrLnRmL3ZhcmlhYmxlc2BcbiAgICApO1xuICB9XG5cbiAgY29uc3QgcHJvdmlkZXJSZXF1aXJlbWVudHMgPSBnZXRQcm92aWRlclJlcXVpcmVtZW50cyhwbGFuKTtcbiAgbG9nZ2VyLmRlYnVnKFxuICAgIGBGb3VuZCB0aGVzZSBwcm92aWRlciByZXF1aXJlbWVudHM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICBwcm92aWRlclJlcXVpcmVtZW50cyxcbiAgICAgIG51bGwsXG4gICAgICAyXG4gICAgKX1gXG4gICk7XG5cbiAgLy8gV2UgYWRkIGEgY29tbWVudCBpZiB0aGVyZSBhcmUgcHJvdmlkZXJzIHdpdGggbWlzc2luZyBzY2hlbWEgaW5mb3JtYXRpb25cbiAgY29uc3QgcHJvdmlkZXJzTGFja2luZ1NjaGVtYSA9IE9iamVjdC5rZXlzKHByb3ZpZGVyUmVxdWlyZW1lbnRzKS5maWx0ZXIoXG4gICAgKHByb3ZpZGVyTmFtZSkgPT5cbiAgICAgIHByb3ZpZGVyTmFtZSAhPT0gXCJ0ZXJyYWZvcm1cIiAmJlxuICAgICAgIU9iamVjdC5rZXlzKHByb3ZpZGVyU2NoZW1hLnByb3ZpZGVyX3NjaGVtYXMgfHwge30pLnNvbWUoKHNjaGVtYU5hbWUpID0+XG4gICAgICAgIHNjaGVtYU5hbWUuZW5kc1dpdGgocHJvdmlkZXJOYW1lKVxuICAgICAgKVxuICApO1xuICBsb2dnZXIuZGVidWcoXG4gICAgYCR7XG4gICAgICBwcm92aWRlcnNMYWNraW5nU2NoZW1hLmxlbmd0aFxuICAgIH0gcHJvdmlkZXJzIGxhY2sgc2NoZW1hIGluZm9ybWF0aW9uOiAke3Byb3ZpZGVyc0xhY2tpbmdTY2hlbWEuam9pbihcIiwgXCIpfWBcbiAgKTtcblxuICBpZiAocHJvdmlkZXJzTGFja2luZ1NjaGVtYS5sZW5ndGggPiAwKSB7XG4gICAgZXhwcmVzc2lvbnNbMF0gPSB0LmFkZENvbW1lbnQoXG4gICAgICBleHByZXNzaW9uc1swXSxcbiAgICAgIFwibGVhZGluZ1wiLFxuICAgICAgYFRoZSBmb2xsb3dpbmcgcHJvdmlkZXJzIGFyZSBtaXNzaW5nIHNjaGVtYSBpbmZvcm1hdGlvbiBhbmQgbWlnaHQgbmVlZCBtYW51YWwgYWRqdXN0bWVudHMgdG8gc3ludGhlc2l6ZSBjb3JyZWN0bHk6ICR7cHJvdmlkZXJzTGFja2luZ1NjaGVtYS5qb2luKFxuICAgICAgICBcIiwgXCJcbiAgICAgICl9LlxuRm9yIGEgbW9yZSBwcmVjaXNlIGNvbnZlcnNpb24gcGxlYXNlIHVzZSB0aGUgLS1wcm92aWRlciBmbGFnIGluIGNvbnZlcnQuYFxuICAgICk7XG4gIH1cblxuICAvLyBBbHdheXMgYWRkIGNvbnN0cnVjdHNcbiAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgY29uc3RydWN0TmFtZTogXCJDb25zdHJ1Y3RcIixcbiAgICBwcm92aWRlcjogXCJjb25zdHJ1Y3RzXCIsXG4gIH0pO1xuXG4gIGlmIChzY29wZS5oYXNUb2tlbkJhc2VkVHlwZUNvZXJjaW9uKSB7XG4gICAgc2NvcGUuaW1wb3J0YWJsZXMucHVzaCh7XG4gICAgICBjb25zdHJ1Y3ROYW1lOiBcIlRva2VuXCIsXG4gICAgICBwcm92aWRlcjogXCJjZGt0ZlwiLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gQWRkIHNwZWNpZmljIGltcG9ydCBmb3IgY29kZUNvbnRhaW5lclxuICBhZGRJbXBvcnRGb3JDb2RlQ29udGFpbmVyKHNjb3BlLCBjb2RlQ29udGFpbmVyKTtcbiAgY29uc3QgY29uc3RydWN0SW1wb3J0cyA9IGJ1aWxkSW1wb3J0cyhzY29wZS5pbXBvcnRhYmxlcyk7XG5cbiAgY29uc3QgY29kZSA9IFsuLi4oYmFja2VuZEV4cHJlc3Npb25zIHx8IFtdKSwgLi4uZXhwcmVzc2lvbnNdO1xuICBjb25zdCBjb25maWdUeXBlTmFtZSA9XG4gICAgT2JqZWN0LmtleXMoc2NvcGUudG9wTGV2ZWxDb25maWcpLmxlbmd0aCA+IDAgPyBcIk15Q29uZmlnXCIgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgY2xhc3NDb25maWcgPSBjb25maWdUeXBlTmFtZVxuICAgID8gW2dlbmVyYXRlQ29uZmlnVHlwZShjb25maWdUeXBlTmFtZSwgc2NvcGUudG9wTGV2ZWxDb25maWcpXVxuICAgIDogW107XG5cbiAgLy8gV2Ugc3BsaXQgdXAgdGhlIGdlbmVyYXRlZCBjb2RlIHNvIHRoYXQgdXNlcnMgY2FuIGhhdmUgbW9yZSBjb250cm9sIG92ZXIgd2hhdCB0byBpbnNlcnQgd2hlcmVcbiAgcmV0dXJuIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgaW1wb3J0cyBhbmQgY29kZSBiZWNhdXNlIHJvc2V0dGEgd29uJ3QgYmUgYWJsZSB0byB0cmFuc2xhdGUgdGhlbVxuICAgIGFsbDogYXdhaXQgZ2VuKFtcbiAgICAgIC4uLmNvbnN0cnVjdEltcG9ydHMsXG4gICAgICAuLi5tb2R1bGVJbXBvcnRzKHBsYW4ubW9kdWxlKSxcbiAgICAgIC4uLmNsYXNzQ29uZmlnLFxuICAgICAgd3JhcENvZGVJbkNvbnN0cnVjdG9yKFxuICAgICAgICBjb2RlQ29udGFpbmVyLFxuICAgICAgICBjb2RlLFxuICAgICAgICBcIk15Q29udmVydGVkQ29kZVwiLFxuICAgICAgICBjb25maWdUeXBlTmFtZVxuICAgICAgKSxcbiAgICBdKSxcbiAgICBpbXBvcnRzOiBhd2FpdCBnZW4oWy4uLmNvbnN0cnVjdEltcG9ydHMsIC4uLm1vZHVsZUltcG9ydHMocGxhbi5tb2R1bGUpXSksXG4gICAgY29kZTogYXdhaXQgZ2VuKGNvZGUpLFxuICAgIHByb3ZpZGVyczogT2JqZWN0LmVudHJpZXMocHJvdmlkZXJSZXF1aXJlbWVudHMpLm1hcCgoW3NvdXJjZSwgdmVyc2lvbl0pID0+XG4gICAgICB2ZXJzaW9uID09PSBcIipcIiA/IHNvdXJjZSA6IGAke3NvdXJjZX1AJHt2ZXJzaW9ufWBcbiAgICApLFxuICAgIG1vZHVsZXM6IG1vZHVsZVJlcXVpcmVtZW50cyxcbiAgICAvLyBXZSB0cmFjayBzb21lIHVzYWdlIGRhdGEgdG8gbWFrZSBpdCBlYXNpZXIgdG8gdW5kZXJzdGFuZCB3aGF0IGlzIHVzZWRcbiAgICBzdGF0czoge1xuICAgICAgbnVtYmVyT2ZNb2R1bGVzOiBtb2R1bGVSZXF1aXJlbWVudHMubGVuZ3RoLFxuICAgICAgbnVtYmVyT2ZQcm92aWRlcnM6IE9iamVjdC5rZXlzKHByb3ZpZGVyUmVxdWlyZW1lbnRzKS5sZW5ndGgsXG4gICAgICByZXNvdXJjZXM6IHJlc291cmNlU3RhdHMocGxhbi5yZXNvdXJjZSB8fCB7fSksXG4gICAgICBkYXRhOiByZXNvdXJjZVN0YXRzKHBsYW4uZGF0YSB8fCB7fSksXG4gICAgICBjb252ZXJ0ZWRMaW5lczogaGNsLnNwbGl0KFwiXFxuXCIpLmxlbmd0aCxcbiAgICB9LFxuICB9O1xufVxuXG50eXBlIEZpbGUgPSB7IGNvbnRlbnRzOiBzdHJpbmc7IGZpbGVOYW1lOiBzdHJpbmcgfTtcbmNvbnN0IHRyYW5zbGF0b3JzID0ge1xuICBweXRob246IHtcbiAgICB2aXNpdG9yOiAoKSA9PiBuZXcgcm9zZXR0YS5QeXRob25WaXNpdG9yKCksXG4gICAgcG9zdFRyYW5zbGF0aW9uTXV0YXRpb246IHJlcGxhY2VQeXRob25JbXBvcnRzLFxuICB9LFxuICBqYXZhOiB7XG4gICAgdmlzaXRvcjogKCkgPT4gbmV3IHJvc2V0dGEuSmF2YVZpc2l0b3IoKSxcbiAgICBwb3N0VHJhbnNsYXRpb25NdXRhdGlvbjogcmVwbGFjZUphdmFJbXBvcnRzLFxuICB9LFxuICBjc2hhcnA6IHtcbiAgICB2aXNpdG9yOiAoKSA9PiBuZXcgcm9zZXR0YS5DU2hhcnBWaXNpdG9yKCksXG4gICAgcG9zdFRyYW5zbGF0aW9uTXV0YXRpb246IHJlcGxhY2VDc2hhcnBJbXBvcnRzLFxuICB9LFxuICBnbzoge1xuICAgIHZpc2l0b3I6ICgpID0+IG5ldyByb3NldHRhLkdvVmlzaXRvcigpLFxuICAgIHBvc3RUcmFuc2xhdGlvbk11dGF0aW9uOiByZXBsYWNlR29JbXBvcnRzLFxuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRvckZvckxhbmd1YWdlKGxhbmd1YWdlOiBrZXlvZiB0eXBlb2YgdHJhbnNsYXRvcnMpIHtcbiAgcmV0dXJuIChmaWxlOiBGaWxlLCB0aHJvd09uVHJhbnNsYXRpb25FcnJvcjogYm9vbGVhbikgPT4ge1xuICAgIGNvbnN0IHsgdmlzaXRvciwgcG9zdFRyYW5zbGF0aW9uTXV0YXRpb24gfSA9IHRyYW5zbGF0b3JzW2xhbmd1YWdlXTtcbiAgICBjb25zdCB7IHRyYW5zbGF0aW9uLCBkaWFnbm9zdGljcyB9ID0gcm9zZXR0YS50cmFuc2xhdGVUeXBlU2NyaXB0KFxuICAgICAgZmlsZSxcbiAgICAgIHZpc2l0b3IoKSxcbiAgICAgIHRocm93T25UcmFuc2xhdGlvbkVycm9yID8geyBpbmNsdWRlQ29tcGlsZXJEaWFnbm9zdGljczogdHJ1ZSB9IDoge31cbiAgICApO1xuXG4gICAgaWYgKFxuICAgICAgdGhyb3dPblRyYW5zbGF0aW9uRXJyb3IgJiZcbiAgICAgIGRpYWdub3N0aWNzLmZpbHRlcigoZGlhZykgPT4gZGlhZy5pc0Vycm9yKS5sZW5ndGggPiAwXG4gICAgKSB7XG4gICAgICBsb2dnZXIuZGVidWcoYENvdWxkIG5vdCB0cmFuc2xhdGUgVFMgdG8gJHtsYW5ndWFnZX06XFxuJHtmaWxlLmNvbnRlbnRzfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IHRyYW5zbGF0ZSBUUyB0byAke2xhbmd1YWdlfTogJHtkaWFnbm9zdGljc1xuICAgICAgICAgIC5tYXAoKGRpYWcpID0+IGRpYWcuZm9ybWF0dGVkTWVzc2FnZSlcbiAgICAgICAgICAuam9pbihcIlxcblwiKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwb3N0VHJhbnNsYXRpb25NdXRhdGlvbih0cmFuc2xhdGlvbik7XG4gIH07XG59XG5cbnR5cGUgQ29udmVydE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBUaGUgbGFuZ3VhZ2UgdG8gY29udmVydCB0b1xuICAgKi9cbiAgbGFuZ3VhZ2U6IGtleW9mIHR5cGVvZiB0cmFuc2xhdG9ycyB8IFwidHlwZXNjcmlwdFwiO1xuICAvKipcbiAgICogVGhlIHByb3ZpZGVyIHNjaGVtYSB0byB1c2UgZm9yIGNvbnZlcnNpb25cbiAgICovXG4gIHByb3ZpZGVyU2NoZW1hOiBQcm92aWRlclNjaGVtYTtcbiAgLyoqXG4gICAqIFRoZSBiYXNlIGNsYXNzIHRvIGV4dGVuZCBmcm9tLiBEZWZhdWx0cyB0byBgY29uc3RydWN0cy5Db25zdHJ1Y3RgXG4gICAqL1xuICBjb2RlQ29udGFpbmVyPzogc3RyaW5nO1xuICAvKipcbiAgICogV2hldGhlciB0byB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdHJhbnNsYXRpb24gZmFpbHNcbiAgICogRGVmYXVsdHMgdG8gZmFsc2VcbiAgICovXG4gIHRocm93T25UcmFuc2xhdGlvbkVycm9yPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0KFxuICBoY2w6IHN0cmluZyxcbiAge1xuICAgIGxhbmd1YWdlLFxuICAgIHByb3ZpZGVyU2NoZW1hLFxuICAgIHRocm93T25UcmFuc2xhdGlvbkVycm9yID0gZmFsc2UsXG4gICAgY29kZUNvbnRhaW5lciA9IFwiY2RrdGYuVGVycmFmb3JtU3RhY2tcIixcbiAgfTogQ29udmVydE9wdGlvbnNcbikge1xuICBjb25zdCBmaWxlTmFtZSA9IFwidGVycmFmb3JtLnRmXCI7XG4gIGNvbnN0IHRyYW5zbGF0ZXIgPVxuICAgIGxhbmd1YWdlID09PSBcInR5cGVzY3JpcHRcIlxuICAgICAgPyAoZmlsZTogRmlsZSwgX3Rocm93T25UcmFuc2xhdGlvbkVycm9yOiBib29sZWFuKSA9PiBmaWxlLmNvbnRlbnRzXG4gICAgICA6IHRyYW5zbGF0b3JGb3JMYW5ndWFnZShsYW5ndWFnZSk7XG5cbiAgaWYgKCF0cmFuc2xhdGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgbGFuZ3VhZ2UgdXNlZDogXCIgKyBsYW5ndWFnZSk7XG4gIH1cblxuICBjb25zdCB0c0NvZGUgPSBhd2FpdCBjb252ZXJ0VG9UeXBlc2NyaXB0KGhjbCwgcHJvdmlkZXJTY2hlbWEsIGNvZGVDb250YWluZXIpO1xuXG4gIHJldHVybiB7XG4gICAgLi4udHNDb2RlLFxuICAgIGFsbDogdHJhbnNsYXRlcihcbiAgICAgIHsgZmlsZU5hbWUsIGNvbnRlbnRzOiB0c0NvZGUuYWxsIH0sXG4gICAgICB0aHJvd09uVHJhbnNsYXRpb25FcnJvclxuICAgICksXG4gICAgaW1wb3J0czogdHJhbnNsYXRlcih7IGZpbGVOYW1lLCBjb250ZW50czogdHNDb2RlLmltcG9ydHMgfSwgZmFsc2UpLFxuICAgIGNvZGU6IHRyYW5zbGF0ZXIoeyBmaWxlTmFtZSwgY29udGVudHM6IHRzQ29kZS5jb2RlIH0sIGZhbHNlKSxcbiAgICBzdGF0czogeyAuLi50c0NvZGUuc3RhdHMsIGxhbmd1YWdlIH0sXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXJyYWZvcm1Db25maWdGcm9tRGlyKGltcG9ydFBhdGg6IHN0cmluZykge1xuICBjb25zdCBhYnNQYXRoID0gcGF0aC5yZXNvbHZlKGltcG9ydFBhdGgpO1xuICBjb25zdCBmaWxlQ29udGVudHMgPSBnbG9iXG4gICAgLnN5bmMoXCIuLyoudGZcIiwgeyBjd2Q6IGFic1BhdGggfSlcbiAgICAubWFwKChwKSA9PiBmcy5yZWFkRmlsZVN5bmMocGF0aC5yZXNvbHZlKGFic1BhdGgsIHApLCBcInV0ZjhcIikpO1xuXG4gIHJldHVybiBmaWxlQ29udGVudHMuam9pbihcIlxcblwiKTtcbn1cblxudHlwZSBDZGt0Zkpzb24gPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiAmIHtcbiAgdGVycmFmb3JtUHJvdmlkZXJzOiBhbnlbXTtcbiAgdGVycmFmb3JtTW9kdWxlczogYW55W107XG59O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRQcm9qZWN0KFxuICBjb21iaW5lZEhjbDogc3RyaW5nLFxuICB7IGxhbmd1YWdlLCBwcm92aWRlclNjaGVtYSB9OiBDb252ZXJ0T3B0aW9uc1xuKSB7XG4gIGlmIChsYW5ndWFnZSAhPT0gXCJ0eXBlc2NyaXB0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBsYW5ndWFnZSB1c2VkOiBcIiArIGxhbmd1YWdlKTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBpbXBvcnRzLFxuICAgIGNvZGUsXG4gICAgcHJvdmlkZXJzLFxuICAgIG1vZHVsZXM6IHRmTW9kdWxlcyxcbiAgICBzdGF0cyxcbiAgfSA9IGF3YWl0IGNvbnZlcnQoY29tYmluZWRIY2wsIHtcbiAgICBsYW5ndWFnZSxcbiAgICBwcm92aWRlclNjaGVtYSxcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjb2RlOiAoaW5wdXRNYWluRmlsZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBpbXBvcnRNYWluRmlsZSA9IFtpbXBvcnRzLCBpbnB1dE1haW5GaWxlXS5qb2luKFwiXFxuXCIpO1xuICAgICAgY29uc3Qgb3V0cHV0TWFpbkZpbGUgPSBpbXBvcnRNYWluRmlsZS5yZXBsYWNlKENPREVfTUFSS0VSLCBjb2RlKTtcbiAgICAgIHJldHVybiBwcmV0dGllci5mb3JtYXQob3V0cHV0TWFpbkZpbGUsIHsgcGFyc2VyOiBcImJhYmVsXCIgfSk7XG4gICAgfSxcbiAgICBjZGt0Zkpzb246IChpbnB1dENka3RmSnNvbjogQ2RrdGZKc29uKSA9PiB7XG4gICAgICBjb25zdCBjZGt0Zkpzb24gPSB7IC4uLmlucHV0Q2RrdGZKc29uIH07XG4gICAgICBjZGt0Zkpzb24udGVycmFmb3JtUHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgY2RrdGZKc29uLnRlcnJhZm9ybU1vZHVsZXMgPSB0Zk1vZHVsZXM7XG4gICAgICByZXR1cm4gY2RrdGZKc29uO1xuICAgIH0sXG4gICAgc3RhdHMsXG4gIH07XG59XG5cbmV4cG9ydCB7IGlzUmVnaXN0cnlNb2R1bGUsIGF0dHJpYnV0ZU5hbWVUb0Nka3RmTmFtZSB9O1xuIl19