"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findExpressionType = exports.coerceType = exports.typeForCallExpression = void 0;
// Copyright (c) HashiCorp, Inc
// SPDX-License-Identifier: MPL-2.0
const template_1 = __importDefault(require("@babel/template"));
const t = __importStar(require("@babel/types"));
const commons_1 = require("@cdktf/commons");
const deep_equal_1 = __importDefault(require("deep-equal"));
const functions_1 = require("./function-bindings/functions");
const terraformSchema_1 = require("./terraformSchema");
const codemaker_1 = require("codemaker");
function changeValueAccessor(ast, newAccessor) {
    const propertyIdentifier = {
        ...ast.property,
        name: newAccessor,
    };
    return {
        ...ast,
        property: propertyIdentifier,
    };
}
function typeForCallExpression(ast) {
    // Find all cdktf.Fn.* calls
    if (t.isMemberExpression(ast.callee) &&
        t.isMemberExpression(ast.callee.object) &&
        t.isIdentifier(ast.callee.object.object) &&
        ast.callee.object.object.name === "cdktf" &&
        t.isIdentifier(ast.callee.object.property) &&
        ast.callee.object.property.name === "Fn" &&
        t.isIdentifier(ast.callee.property)) {
        const meta = functions_1.tsFunctionsMap[ast.callee.property.name];
        if (meta) {
            return meta.returnType;
        }
        else {
            return "dynamic";
        }
    }
    // cdktf.conditional, cdktf.propertyAccess, cdktf.Op.* are all dynamic
    // By default we assume dynamic
    return "dynamic";
}
exports.typeForCallExpression = typeForCallExpression;
const coerceType = (scope, ast, from, to) => {
    if (to === undefined) {
        return ast;
    }
    if ((0, deep_equal_1.default)(to, from)) {
        return ast;
    }
    const isTerraformVariableOrLocal = ast.type === "MemberExpression" &&
        ast.property.type === "Identifier" &&
        ast.property.name === "value" &&
        ast.object.type === "Identifier" &&
        Object.values(scope.variables).some((knownVars) => knownVars.variableName === ast.object.name &&
            ["var", "local"].includes(knownVars.resource));
    const addTokenToImports = () => scope.importables.push({
        constructName: "Token",
        provider: "cdktf",
    });
    if (Array.isArray(to)) {
        if (to[0] === "list" || to[0] === "set") {
            switch (to[1]) {
                case "string":
                    if (isTerraformVariableOrLocal) {
                        return changeValueAccessor(ast, "listValue");
                    }
                    addTokenToImports();
                    return template_1.default.expression(`Token.asList(%%ast%%)`)({
                        ast: ast,
                    });
                case "number":
                    addTokenToImports();
                    return template_1.default.expression(`Token.asNumberList(%%ast%%)`)({
                        ast: ast,
                    });
                case "bool":
                    addTokenToImports();
                    return template_1.default.expression(`Token.asAny(%%ast%%)`)({
                        ast: ast,
                    });
                default:
                    addTokenToImports();
                    return template_1.default.expression(`Token.asAny(%%ast%%)`)({
                        ast: ast,
                    });
            }
        }
        if (to[0] === "map") {
            switch (to[1]) {
                case "string":
                    addTokenToImports();
                    return template_1.default.expression(`Token.asStringMap(%%ast%%)`)({
                        ast: ast,
                    });
                case "number":
                    addTokenToImports();
                    return template_1.default.expression(`Token.asNumberMap(%%ast%%)`)({
                        ast: ast,
                    });
                case "bool":
                    addTokenToImports();
                    return template_1.default.expression(`Token.asBooleanMap(%%ast%%)`)({
                        ast: ast,
                    });
                default:
                    addTokenToImports();
                    return template_1.default.expression(`Token.asAnyMap(%%ast%%)`)({
                        ast: ast,
                    });
            }
        }
    }
    switch (to) {
        case "number":
            if (isTerraformVariableOrLocal) {
                return changeValueAccessor(ast, "numberValue");
            }
            addTokenToImports();
            return template_1.default.expression(`Token.asNumber(%%ast%%)`)({
                ast: ast,
            });
        case "string":
            if (isTerraformVariableOrLocal) {
                return changeValueAccessor(ast, "stringValue");
            }
            addTokenToImports();
            return template_1.default.expression(`Token.asString(%%ast%%)`)({
                ast: ast,
            });
        case "bool":
            if (isTerraformVariableOrLocal) {
                return changeValueAccessor(ast, "booleanValue");
            }
            addTokenToImports();
            return template_1.default.expression(`Token.asBoolean(%%ast%%)`)({
                ast: ast,
            });
    }
    commons_1.logger.debug(`Could not coerce from ${from} to ${to} for ${ast}`);
    return ast;
};
exports.coerceType = coerceType;
function findExpressionType(scope, ast) {
    const isReferenceWithoutTemplateString = ast.type === "MemberExpression" && ast.object.type === "Identifier";
    // If we have a property to cdktf.propertyAccess call it's dynamic
    if (ast.type === "CallExpression") {
        return typeForCallExpression(ast);
    }
    if (ast.type === "StringLiteral") {
        return "string";
    }
    if (ast.type === "NumericLiteral") {
        return "number";
    }
    if (ast.type === "BooleanLiteral") {
        return "bool";
    }
    // If we only have one reference this is a
    if (isReferenceWithoutTemplateString) {
        const destructuredAst = destructureAst(ast);
        if (!destructuredAst) {
            commons_1.logger.debug(`Could not destructure ast: ${JSON.stringify(ast, null, 2)}`);
            return "dynamic";
        }
        const [astVariableName, ...attributes] = destructuredAst;
        const variable = Object.values(scope.variables).find((x) => x.variableName === astVariableName);
        if (!variable) {
            commons_1.logger.debug(`Could not find variable ${astVariableName} given scope: ${JSON.stringify(scope.variables, null, 2)}`);
            // We don't know, this should not happen, but if it does we assume the worst case and make it dynamic
            return "dynamic";
        }
        if (variable.resource === "var") {
            return "dynamic";
        }
        const { resource: resourceType } = variable;
        const [provider, ...resourceNameFragments] = resourceType.split("_");
        const tfResourcePath = `${provider}.${resourceNameFragments.join("_")}.${attributes.map((x) => (0, codemaker_1.toSnakeCase)(x)).join(".")}`;
        const type = (0, terraformSchema_1.getTypeAtPath)(scope.providerSchema, tfResourcePath);
        // If this is an attribute type we can return it
        if (typeof type === "string" || Array.isArray(type)) {
            return type;
        }
        // Either nothing is found or it's a block type
        return "dynamic";
    }
    return "string";
}
exports.findExpressionType = findExpressionType;
/*
 * Transforms a babel AST into a list of string accessors
 * e.g. foo.bar.baz -> ["foo", "bar", "baz"]
 */
function destructureAst(ast) {
    switch (ast.type) {
        case "Identifier":
            return [ast.name];
        case "MemberExpression":
            const object = destructureAst(ast.object);
            const property = destructureAst(ast.property);
            if (object && property) {
                return [...object, ...property];
            }
            else {
                return undefined;
            }
        default:
            return undefined;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29lcmNlVHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvZXJjZVR5cGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBK0I7QUFDL0IsbUNBQW1DO0FBQ25DLCtEQUF1QztBQUN2QyxnREFBa0M7QUFDbEMsNENBQXVEO0FBRXZELDREQUFtQztBQUNuQyw2REFBK0Q7QUFDL0QsdURBQWtEO0FBQ2xELHlDQUF3QztBQUV4QyxTQUFTLG1CQUFtQixDQUMxQixHQUF1QixFQUN2QixXQUFtQjtJQUVuQixNQUFNLGtCQUFrQixHQUFpQjtRQUN2QyxHQUFJLEdBQUcsQ0FBQyxRQUF5QjtRQUNqQyxJQUFJLEVBQUUsV0FBVztLQUNsQixDQUFDO0lBQ0YsT0FBTztRQUNMLEdBQUcsR0FBRztRQUNOLFFBQVEsRUFBRSxrQkFBa0I7S0FDN0IsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFnQixxQkFBcUIsQ0FBQyxHQUFxQjtJQUN6RCw0QkFBNEI7SUFDNUIsSUFDRSxDQUFDLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQztRQUNoQyxDQUFDLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDdkMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDeEMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxPQUFPO1FBQ3pDLENBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO1FBQzFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssSUFBSTtRQUN4QyxDQUFDLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxD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QUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ3ZELE1BQU0sSUFBSSxHQUFHLElBQUEsK0JBQWEsRUFBQyxLQUFLLENBQUMsY0FBYyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBRWpFLGdEQUFnRDtRQUNoRCxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ25ELE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCwrQ0FBK0M7UUFDL0MsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFFRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBdEVELGdEQXNFQztBQUVEOzs7R0FHRztBQUNILFNBQVMsY0FBYyxDQUFDLEdBQWlCO0lBQ3ZDLFFBQVEsR0FBRyxDQUFDLElBQUksRUFBRTtRQUNoQixLQUFLLFlBQVk7WUFDZixPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BCLEtBQUssa0JBQWtCO1lBQ3JCLE1BQU0sTUFBTSxHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDMUMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxRQUF3QixDQUFDLENBQUM7WUFDOUQsSUFBSSxNQUFNLElBQUksUUFBUSxFQUFFO2dCQUN0QixPQUFPLENBQUMsR0FBRyxNQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsQ0FBQzthQUNqQztpQkFBTTtnQkFDTCxPQUFPLFNBQVMsQ0FBQzthQUNsQjtRQUNIO1lBQ0UsT0FBTyxTQUFTLENBQUM7S0FDcEI7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBIYXNoaUNvcnAsIEluY1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1QTC0yLjBcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tIFwiQGJhYmVsL3RlbXBsYXRlXCI7XG5pbXBvcnQgKiBhcyB0IGZyb20gXCJAYmFiZWwvdHlwZXNcIjtcbmltcG9ydCB7IGxvZ2dlciwgQXR0cmlidXRlVHlwZSB9IGZyb20gXCJAY2RrdGYvY29tbW9uc1wiO1xuaW1wb3J0IHsgUHJvZ3JhbVNjb3BlIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCBkZWVwRXF1YWwgZnJvbSBcImRlZXAtZXF1YWxcIjtcbmltcG9ydCB7IHRzRnVuY3Rpb25zTWFwIH0gZnJvbSBcIi4vZnVuY3Rpb24tYmluZGluZ3MvZnVuY3Rpb25zXCI7XG5pbXBvcnQgeyBnZXRUeXBlQXRQYXRoIH0gZnJvbSBcIi4vdGVycmFmb3JtU2NoZW1hXCI7XG5pbXBvcnQgeyB0b1NuYWtlQ2FzZSB9IGZyb20gXCJjb2RlbWFrZXJcIjtcblxuZnVuY3Rpb24gY2hhbmdlVmFsdWVBY2Nlc3NvcihcbiAgYXN0OiB0Lk1lbWJlckV4cHJlc3Npb24sXG4gIG5ld0FjY2Vzc29yOiBzdHJpbmdcbik6IHQuTWVtYmVyRXhwcmVzc2lvbiB7XG4gIGNvbnN0IHByb3BlcnR5SWRlbnRpZmllcjogdC5JZGVudGlmaWVyID0ge1xuICAgIC4uLihhc3QucHJvcGVydHkgYXMgdC5JZGVudGlmaWVyKSxcbiAgICBuYW1lOiBuZXdBY2Nlc3NvcixcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICAuLi5hc3QsXG4gICAgcHJvcGVydHk6IHByb3BlcnR5SWRlbnRpZmllcixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVGb3JDYWxsRXhwcmVzc2lvbihhc3Q6IHQuQ2FsbEV4cHJlc3Npb24pOiBBdHRyaWJ1dGVUeXBlIHtcbiAgLy8gRmluZCBhbGwgY2RrdGYuRm4uKiBjYWxsc1xuICBpZiAoXG4gICAgdC5pc01lbWJlckV4cHJlc3Npb24oYXN0LmNhbGxlZSkgJiZcbiAgICB0LmlzTWVtYmVyRXhwcmVzc2lvbihhc3QuY2FsbGVlLm9iamVjdCkgJiZcbiAgICB0LmlzSWRlbnRpZmllcihhc3QuY2FsbGVlLm9iamVjdC5vYmplY3QpICYmXG4gICAgYXN0LmNhbGxlZS5vYmplY3Qub2JqZWN0Lm5hbWUgPT09IFwiY2RrdGZcIiAmJlxuICAgIHQuaXNJZGVudGlmaWVyKGFzdC5jYWxsZWUub2JqZWN0LnByb3BlcnR5KSAmJlxuICAgIGFzdC5jYWxsZWUub2JqZWN0LnByb3BlcnR5Lm5hbWUgPT09IFwiRm5cIiAmJlxuICAgIHQuaXNJZGVudGlmaWVyKGFzdC5jYWxsZWUucHJvcGVydHkpXG4gICkge1xuICAgIGNvbnN0IG1ldGEgPSB0c0Z1bmN0aW9uc01hcFthc3QuY2FsbGVlLnByb3BlcnR5Lm5hbWVdO1xuICAgIGlmIChtZXRhKSB7XG4gICAgICByZXR1cm4gbWV0YS5yZXR1cm5UeXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJkeW5hbWljXCI7XG4gICAgfVxuICB9XG5cbiAgLy8gY2RrdGYuY29uZGl0aW9uYWwsIGNka3RmLnByb3BlcnR5QWNjZXNzLCBjZGt0Zi5PcC4qIGFyZSBhbGwgZHluYW1pY1xuICAvLyBCeSBkZWZhdWx0IHdlIGFzc3VtZSBkeW5hbWljXG4gIHJldHVybiBcImR5bmFtaWNcIjtcbn1cblxuZXhwb3J0IGNvbnN0IGNvZXJjZVR5cGUgPSAoXG4gIHNjb3BlOiBQcm9ncmFtU2NvcGUsXG4gIGFzdDogdC5FeHByZXNzaW9uLFxuICBmcm9tOiBBdHRyaWJ1dGVUeXBlLFxuICB0bzogQXR0cmlidXRlVHlwZSB8IHVuZGVmaW5lZFxuKTogdC5FeHByZXNzaW9uID0+IHtcbiAgaWYgKHRvID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYXN0O1xuICB9XG5cbiAgaWYgKGRlZXBFcXVhbCh0bywgZnJvbSkpIHtcbiAgICByZXR1cm4gYXN0O1xuICB9XG5cbiAgY29uc3QgaXNUZXJyYWZvcm1WYXJpYWJsZU9yTG9jYWwgPVxuICAgIGFzdC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJlxuICAgIGFzdC5wcm9wZXJ0eS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgIGFzdC5wcm9wZXJ0eS5uYW1lID09PSBcInZhbHVlXCIgJiZcbiAgICBhc3Qub2JqZWN0LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgT2JqZWN0LnZhbHVlcyhzY29wZS52YXJpYWJsZXMpLnNvbWUoXG4gICAgICAoa25vd25WYXJzKSA9PlxuICAgICAgICBrbm93blZhcnMudmFyaWFibGVOYW1lID09PSAoYXN0Lm9iamVjdCBhcyB0LklkZW50aWZpZXIpLm5hbWUgJiZcbiAgICAgICAgW1widmFyXCIsIFwibG9jYWxcIl0uaW5jbHVkZXMoa25vd25WYXJzLnJlc291cmNlKVxuICAgICk7XG5cbiAgY29uc3QgYWRkVG9rZW5Ub0ltcG9ydHMgPSAoKSA9PlxuICAgIHNjb3BlLmltcG9ydGFibGVzLnB1c2goe1xuICAgICAgY29uc3RydWN0TmFtZTogXCJUb2tlblwiLFxuICAgICAgcHJvdmlkZXI6IFwiY2RrdGZcIixcbiAgICB9KTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh0bykpIHtcbiAgICBpZiAodG9bMF0gPT09IFwibGlzdFwiIHx8IHRvWzBdID09PSBcInNldFwiKSB7XG4gICAgICBzd2l0Y2ggKHRvWzFdKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICBpZiAoaXNUZXJyYWZvcm1WYXJpYWJsZU9yTG9jYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VWYWx1ZUFjY2Vzc29yKGFzdCBhcyB0Lk1lbWJlckV4cHJlc3Npb24sIFwibGlzdFZhbHVlXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFkZFRva2VuVG9JbXBvcnRzKCk7XG4gICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmV4cHJlc3Npb24oYFRva2VuLmFzTGlzdCglJWFzdCUlKWApKHtcbiAgICAgICAgICAgIGFzdDogYXN0LFxuICAgICAgICAgIH0pIGFzIHQuRXhwcmVzc2lvbjtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgIGFkZFRva2VuVG9JbXBvcnRzKCk7XG4gICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmV4cHJlc3Npb24oYFRva2VuLmFzTnVtYmVyTGlzdCglJWFzdCUlKWApKHtcbiAgICAgICAgICAgIGFzdDogYXN0LFxuICAgICAgICAgIH0pIGFzIHQuRXhwcmVzc2lvbjtcbiAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICBhZGRUb2tlblRvSW1wb3J0cygpO1xuICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZS5leHByZXNzaW9uKGBUb2tlbi5hc0FueSglJWFzdCUlKWApKHtcbiAgICAgICAgICAgIGFzdDogYXN0LFxuICAgICAgICAgIH0pIGFzIHQuRXhwcmVzc2lvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhZGRUb2tlblRvSW1wb3J0cygpO1xuICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZS5leHByZXNzaW9uKGBUb2tlbi5hc0FueSglJWFzdCUlKWApKHtcbiAgICAgICAgICAgIGFzdDogYXN0LFxuICAgICAgICAgIH0pIGFzIHQuRXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9bMF0gPT09IFwibWFwXCIpIHtcbiAgICAgIHN3aXRjaCAodG9bMV0pIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIGFkZFRva2VuVG9JbXBvcnRzKCk7XG4gICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmV4cHJlc3Npb24oYFRva2VuLmFzU3RyaW5nTWFwKCUlYXN0JSUpYCkoe1xuICAgICAgICAgICAgYXN0OiBhc3QsXG4gICAgICAgICAgfSkgYXMgdC5FeHByZXNzaW9uO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgYWRkVG9rZW5Ub0ltcG9ydHMoKTtcbiAgICAgICAgICByZXR1cm4gdGVtcGxhdGUuZXhwcmVzc2lvbihgVG9rZW4uYXNOdW1iZXJNYXAoJSVhc3QlJSlgKSh7XG4gICAgICAgICAgICBhc3Q6IGFzdCxcbiAgICAgICAgICB9KSBhcyB0LkV4cHJlc3Npb247XG4gICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgYWRkVG9rZW5Ub0ltcG9ydHMoKTtcbiAgICAgICAgICByZXR1cm4gdGVtcGxhdGUuZXhwcmVzc2lvbihgVG9rZW4uYXNCb29sZWFuTWFwKCUlYXN0JSUpYCkoe1xuICAgICAgICAgICAgYXN0OiBhc3QsXG4gICAgICAgICAgfSkgYXMgdC5FeHByZXNzaW9uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFkZFRva2VuVG9JbXBvcnRzKCk7XG4gICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmV4cHJlc3Npb24oYFRva2VuLmFzQW55TWFwKCUlYXN0JSUpYCkoe1xuICAgICAgICAgICAgYXN0OiBhc3QsXG4gICAgICAgICAgfSkgYXMgdC5FeHByZXNzaW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodG8pIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZiAoaXNUZXJyYWZvcm1WYXJpYWJsZU9yTG9jYWwpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZVZhbHVlQWNjZXNzb3IoYXN0IGFzIHQuTWVtYmVyRXhwcmVzc2lvbiwgXCJudW1iZXJWYWx1ZVwiKTtcbiAgICAgIH1cbiAgICAgIGFkZFRva2VuVG9JbXBvcnRzKCk7XG4gICAgICByZXR1cm4gdGVtcGxhdGUuZXhwcmVzc2lvbihgVG9rZW4uYXNOdW1iZXIoJSVhc3QlJSlgKSh7XG4gICAgICAgIGFzdDogYXN0LFxuICAgICAgfSkgYXMgdC5FeHByZXNzaW9uO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIGlmIChpc1RlcnJhZm9ybVZhcmlhYmxlT3JMb2NhbCkge1xuICAgICAgICByZXR1cm4gY2hhbmdlVmFsdWVBY2Nlc3Nvcihhc3QgYXMgdC5NZW1iZXJFeHByZXNzaW9uLCBcInN0cmluZ1ZhbHVlXCIpO1xuICAgICAgfVxuICAgICAgYWRkVG9rZW5Ub0ltcG9ydHMoKTtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZS5leHByZXNzaW9uKGBUb2tlbi5hc1N0cmluZyglJWFzdCUlKWApKHtcbiAgICAgICAgYXN0OiBhc3QsXG4gICAgICB9KSBhcyB0LkV4cHJlc3Npb247XG4gICAgY2FzZSBcImJvb2xcIjpcbiAgICAgIGlmIChpc1RlcnJhZm9ybVZhcmlhYmxlT3JMb2NhbCkge1xuICAgICAgICByZXR1cm4gY2hhbmdlVmFsdWVBY2Nlc3Nvcihhc3QgYXMgdC5NZW1iZXJFeHByZXNzaW9uLCBcImJvb2xlYW5WYWx1ZVwiKTtcbiAgICAgIH1cbiAgICAgIGFkZFRva2VuVG9JbXBvcnRzKCk7XG4gICAgICByZXR1cm4gdGVtcGxhdGUuZXhwcmVzc2lvbihgVG9rZW4uYXNCb29sZWFuKCUlYXN0JSUpYCkoe1xuICAgICAgICBhc3Q6IGFzdCxcbiAgICAgIH0pIGFzIHQuRXhwcmVzc2lvbjtcbiAgfVxuXG4gIGxvZ2dlci5kZWJ1ZyhgQ291bGQgbm90IGNvZXJjZSBmcm9tICR7ZnJvbX0gdG8gJHt0b30gZm9yICR7YXN0fWApO1xuICByZXR1cm4gYXN0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFeHByZXNzaW9uVHlwZShcbiAgc2NvcGU6IFByb2dyYW1TY29wZSxcbiAgYXN0OiB0LkV4cHJlc3Npb25cbik6IEF0dHJpYnV0ZVR5cGUge1xuICBjb25zdCBpc1JlZmVyZW5jZVdpdGhvdXRUZW1wbGF0ZVN0cmluZyA9XG4gICAgYXN0LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIGFzdC5vYmplY3QudHlwZSA9PT0gXCJJZGVudGlmaWVyXCI7XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIHByb3BlcnR5IHRvIGNka3RmLnByb3BlcnR5QWNjZXNzIGNhbGwgaXQncyBkeW5hbWljXG4gIGlmIChhc3QudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgcmV0dXJuIHR5cGVGb3JDYWxsRXhwcmVzc2lvbihhc3QpO1xuICB9XG5cbiAgaWYgKGFzdC50eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIikge1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gXCJOdW1lcmljTGl0ZXJhbFwiKSB7XG4gICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSBcIkJvb2xlYW5MaXRlcmFsXCIpIHtcbiAgICByZXR1cm4gXCJib29sXCI7XG4gIH1cblxuICAvLyBJZiB3ZSBvbmx5IGhhdmUgb25lIHJlZmVyZW5jZSB0aGlzIGlzIGFcbiAgaWYgKGlzUmVmZXJlbmNlV2l0aG91dFRlbXBsYXRlU3RyaW5nKSB7XG4gICAgY29uc3QgZGVzdHJ1Y3R1cmVkQXN0ID0gZGVzdHJ1Y3R1cmVBc3QoYXN0KTtcbiAgICBpZiAoIWRlc3RydWN0dXJlZEFzdCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICBgQ291bGQgbm90IGRlc3RydWN0dXJlIGFzdDogJHtKU09OLnN0cmluZ2lmeShhc3QsIG51bGwsIDIpfWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gXCJkeW5hbWljXCI7XG4gICAgfVxuXG4gICAgY29uc3QgW2FzdFZhcmlhYmxlTmFtZSwgLi4uYXR0cmlidXRlc10gPSBkZXN0cnVjdHVyZWRBc3Q7XG4gICAgY29uc3QgdmFyaWFibGUgPSBPYmplY3QudmFsdWVzKHNjb3BlLnZhcmlhYmxlcykuZmluZChcbiAgICAgICh4KSA9PiB4LnZhcmlhYmxlTmFtZSA9PT0gYXN0VmFyaWFibGVOYW1lXG4gICAgKTtcblxuICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYENvdWxkIG5vdCBmaW5kIHZhcmlhYmxlICR7YXN0VmFyaWFibGVOYW1lfSBnaXZlbiBzY29wZTogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzY29wZS52YXJpYWJsZXMsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAyXG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICAgIC8vIFdlIGRvbid0IGtub3csIHRoaXMgc2hvdWxkIG5vdCBoYXBwZW4sIGJ1dCBpZiBpdCBkb2VzIHdlIGFzc3VtZSB0aGUgd29yc3QgY2FzZSBhbmQgbWFrZSBpdCBkeW5hbWljXG4gICAgICByZXR1cm4gXCJkeW5hbWljXCI7XG4gICAgfVxuXG4gICAgaWYgKHZhcmlhYmxlLnJlc291cmNlID09PSBcInZhclwiKSB7XG4gICAgICByZXR1cm4gXCJkeW5hbWljXCI7XG4gICAgfVxuXG4gICAgY29uc3QgeyByZXNvdXJjZTogcmVzb3VyY2VUeXBlIH0gPSB2YXJpYWJsZTtcbiAgICBjb25zdCBbcHJvdmlkZXIsIC4uLnJlc291cmNlTmFtZUZyYWdtZW50c10gPSByZXNvdXJjZVR5cGUuc3BsaXQoXCJfXCIpO1xuICAgIGNvbnN0IHRmUmVzb3VyY2VQYXRoID0gYCR7cHJvdmlkZXJ9LiR7cmVzb3VyY2VOYW1lRnJhZ21lbnRzLmpvaW4oXG4gICAgICBcIl9cIlxuICAgICl9LiR7YXR0cmlidXRlcy5tYXAoKHgpID0+IHRvU25ha2VDYXNlKHgpKS5qb2luKFwiLlwiKX1gO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlQXRQYXRoKHNjb3BlLnByb3ZpZGVyU2NoZW1hLCB0ZlJlc291cmNlUGF0aCk7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGF0dHJpYnV0ZSB0eXBlIHdlIGNhbiByZXR1cm4gaXRcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgLy8gRWl0aGVyIG5vdGhpbmcgaXMgZm91bmQgb3IgaXQncyBhIGJsb2NrIHR5cGVcbiAgICByZXR1cm4gXCJkeW5hbWljXCI7XG4gIH1cblxuICByZXR1cm4gXCJzdHJpbmdcIjtcbn1cblxuLypcbiAqIFRyYW5zZm9ybXMgYSBiYWJlbCBBU1QgaW50byBhIGxpc3Qgb2Ygc3RyaW5nIGFjY2Vzc29yc1xuICogZS5nLiBmb28uYmFyLmJheiAtPiBbXCJmb29cIiwgXCJiYXJcIiwgXCJiYXpcIl1cbiAqL1xuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVBc3QoYXN0OiB0LkV4cHJlc3Npb24pOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCB7XG4gIHN3aXRjaCAoYXN0LnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgcmV0dXJuIFthc3QubmFtZV07XG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGNvbnN0IG9iamVjdCA9IGRlc3RydWN0dXJlQXN0KGFzdC5vYmplY3QpO1xuICAgICAgY29uc3QgcHJvcGVydHkgPSBkZXN0cnVjdHVyZUFzdChhc3QucHJvcGVydHkgYXMgdC5FeHByZXNzaW9uKTtcbiAgICAgIGlmIChvYmplY3QgJiYgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5vYmplY3QsIC4uLnByb3BlcnR5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbiJdfQ==