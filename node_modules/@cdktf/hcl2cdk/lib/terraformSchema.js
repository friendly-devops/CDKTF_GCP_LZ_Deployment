"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDesiredType = exports.isMapAttribute = exports.getTypeAtPath = void 0;
const provider_1 = require("./provider");
function getResourceAtPath(schema, path) {
    var _a;
    const parts = path.split(".");
    if (parts.length < 2) {
        // Too short to be a valid path
        return null;
    }
    const isDataSource = parts[0] === "data";
    if (isDataSource) {
        parts.shift();
    }
    const providerName = parts.shift();
    const resourceName = parts.shift();
    const fullProviderName = (0, provider_1.getFullProviderName)(schema, providerName);
    // Hack: In the case of 'external', the name of the data source 'external' doesn't have a prefix
    // so we repeat the name as both provider prefix and the data source name
    const fullResourceName = providerName === resourceName
        ? providerName
        : `${providerName}_${resourceName}`;
    if (!fullProviderName) {
        // No provider found with that name
        return null;
    }
    const provider = (_a = schema.provider_schemas) === null || _a === void 0 ? void 0 : _a[fullProviderName];
    if (!provider) {
        // Could not find provider
        return null;
    }
    if (resourceName.endsWith("Provider")) {
        // This is a provider
        return { resource: provider.provider, parts };
    }
    const resources = isDataSource
        ? provider.data_source_schemas
        : provider.resource_schemas;
    const resource = resources[fullResourceName];
    if (!resource) {
        // Could not find resource
        return null;
    }
    return { resource, parts };
}
function findType(item, parts) {
    if (!parts.length) {
        return item;
    }
    const [currentPart, ...otherParts] = parts;
    // Promitive attributes can be returned directly
    if (typeof item === "string") {
        return item;
    }
    // Complex attributes
    if (Array.isArray(item)) {
        if (item[0] === "set" || item[0] === "list") {
            if (currentPart === "[]") {
                return findType(item[1], otherParts);
            }
            // Trying to access a property on a list
            return null;
        }
        if (item[0] === "object") {
            if (currentPart === "[]") {
                // Trying to access a property on a list
                return null;
            }
            return findType(item[1][currentPart], otherParts);
        }
        if (item[0] === "map") {
            // We don't care what the key is
            return findType(item[1], otherParts);
        }
        // Unknown type
        return null;
    }
    // If we are not in an attribute, we can ignore the [] (since max_item=1 parts don't have [], so we just ignore it)
    if (currentPart === "[]") {
        return findType(item, otherParts);
    }
    // Block
    if (item.block) {
        // Find block type in block
        if (item.block.block_types) {
            const blockType = item.block.block_types[currentPart];
            if (blockType) {
                return findType(blockType, otherParts);
            }
        }
        // Find attribute in block
        if (item.block.attributes) {
            const attribute = item.block.attributes[currentPart];
            if (attribute && attribute.type) {
                return findType(attribute.type, otherParts);
            }
        }
    }
    // Could not find the type
    return null;
}
function getTypeAtPath(schema, path) {
    const resourceSchema = getResourceAtPath(schema, path);
    if (!resourceSchema) {
        return null;
    }
    const { resource, parts } = resourceSchema;
    return findType(resource, parts);
}
exports.getTypeAtPath = getTypeAtPath;
const isMapAttribute = (attribute) => (Array.isArray(attribute) ? attribute[0] === "map" : false);
exports.isMapAttribute = isMapAttribute;
function getDesiredType(scope, path) {
    const attributeOrBlockType = getTypeAtPath(scope.providerSchema, path);
    // Attribute type is not defined
    if (!attributeOrBlockType) {
        return "dynamic";
    }
    // Primitive attribute type
    if (typeof attributeOrBlockType === "string") {
        return attributeOrBlockType;
    }
    // Complex attribute type
    if (Array.isArray(attributeOrBlockType)) {
        return attributeOrBlockType;
    }
    // Schema
    if ("version" in attributeOrBlockType) {
        return "dynamic";
    }
    // Block type
    return "dynamic";
}
exports.getDesiredType = getDesiredType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVycmFmb3JtU2NoZW1hLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidGVycmFmb3JtU2NoZW1hLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQVFBLHlDQUFpRDtBQUdqRCxTQUFTLGlCQUFpQixDQUFDLE1BQXNCLEVBQUUsSUFBWTs7SUFDN0QsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUU5QixJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3BCLCtCQUErQjtRQUMvQixPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsTUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLE1BQU0sQ0FBQztJQUN6QyxJQUFJLFlBQVksRUFBRTtRQUNoQixLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7S0FDZjtJQUVELE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQVksQ0FBQztJQUM3QyxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFZLENBQUM7SUFFN0MsTUFBTSxnQkFBZ0IsR0FBRyxJQUFBLDhCQUFtQixFQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQztJQUNuRSxnR0FBZ0c7SUFDaEcseUVBQXlFO0lBQ3pFLE1BQU0sZ0JBQWdCLEdBQ3BCLFlBQVksS0FBSyxZQUFZO1FBQzNCLENBQUMsQ0FBQyxZQUFZO1FBQ2QsQ0FBQyxDQUFDLEdBQUcsWUFBWSxJQUFJLFlBQVksRUFBRSxDQUFDO0lBRXhDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtRQUNyQixtQ0FBbUM7UUFDbkMsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELE1BQU0sUUFBUSxHQUFHLE1BQUEsTUFBTSxDQUFDLGdCQUFnQiwwQ0FBRyxnQkFBZ0IsQ0FBQyxDQUFDO0lBRTdELElBQUksQ0FBQyxRQUFRLEVBQUU7UUFDYiwwQkFBMEI7UUFDMUIsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELElBQUksWUFBWSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUNyQyxxQkFBcUI7UUFDckIsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxDQUFDO0tBQy9DO0lBRUQsTUFBTSxTQUFTLEdBQUcsWUFBWTtRQUM1QixDQUFDLENBQUMsUUFBUSxDQUFDLG1CQUFtQjtRQUM5QixDQUFDLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDO0lBRTlCLE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzdDLElBQUksQ0FBQyxRQUFRLEVBQUU7UUFDYiwwQkFBMEI7UUFDMUIsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELE9BQU8sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLENBQUM7QUFDN0IsQ0FBQztBQUVELFNBQVMsUUFBUSxDQUNmLElBQXdDLEVBQ3hDLEtBQWU7SUFFZixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUNqQixPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsTUFBTSxDQUFDLFdBQVcsRUFBRSxHQUFHLFVBQVUsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUUzQyxnREFBZ0Q7SUFDaEQsSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLEVBQUU7UUFDNUIsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELHFCQUFxQjtJQUNyQixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDdkIsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxNQUFNLEVBQUU7WUFDM0MsSUFBSSxXQUFXLEtBQUssSUFBSSxFQUFFO2dCQUN4QixPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUM7YUFDdEM7WUFDRCx3Q0FBd0M7WUFDeEMsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUVELElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsRUFBRTtZQUN4QixJQUFJLFdBQVcsS0FBSyxJQUFJLEVBQUU7Z0JBQ3hCLHdDQUF3QztnQkFDeEMsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUVELE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQztTQUNuRDtRQUVELElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssRUFBRTtZQUNyQixnQ0FBZ0M7WUFDaEMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1NBQ3RDO1FBRUQsZUFBZTtRQUNmLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCxtSEFBbUg7SUFDbkgsSUFBSSxXQUFXLEtBQUssSUFBSSxFQUFFO1FBQ3hCLE9BQU8sUUFBUSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztLQUNuQztJQUVELFFBQVE7SUFDUixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDZCwyQkFBMkI7UUFDM0IsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRTtZQUMxQixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUN0RCxJQUFJLFNBQVMsRUFBRTtnQkFDYixPQUFPLFFBQVEsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7YUFDeEM7U0FDRjtRQUVELDBCQUEwQjtRQUMxQixJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFO1lBQ3pCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3JELElBQUksU0FBUyxJQUFJLFNBQVMsQ0FBQyxJQUFJLEVBQUU7Z0JBQy9CLE9BQU8sUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7YUFDN0M7U0FDRjtLQUNGO0lBRUQsMEJBQTBCO0lBQzFCLE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVELFNBQWdCLGFBQWEsQ0FDM0IsTUFBc0IsRUFDdEIsSUFBWTtJQUVaLE1BQU0sY0FBYyxHQUFHLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUV2RCxJQUFJLENBQUMsY0FBYyxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxNQUFNLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxHQUFHLGNBQWMsQ0FBQztJQUMzQyxPQUFPLFFBQVEsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDbkMsQ0FBQztBQVhELHNDQVdDO0FBRU0sTUFBTSxjQUFjLEdBQUcsQ0FDNUIsU0FBb0QsRUFDcEQsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7QUFGcEQsUUFBQSxjQUFjLGtCQUVzQztBQUVqRSxTQUFnQixjQUFjLENBQzVCLEtBQW1CLEVBQ25CLElBQVk7SUFFWixNQUFNLG9CQUFvQixHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBRXZFLGdDQUFnQztJQUNoQyxJQUFJLENBQUMsb0JBQW9CLEVBQUU7UUFDekIsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFFRCwyQkFBMkI7SUFDM0IsSUFBSSxPQUFPLG9CQUFvQixLQUFLLFFBQVEsRUFBRTtRQUM1QyxPQUFPLG9CQUFvQixDQUFDO0tBQzdCO0lBRUQseUJBQXlCO0lBQ3pCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFO1FBQ3ZDLE9BQU8sb0JBQW9CLENBQUM7S0FDN0I7SUFFRCxTQUFTO0lBQ1QsSUFBSSxTQUFTLElBQUksb0JBQW9CLEVBQUU7UUFDckMsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFFRCxhQUFhO0lBQ2IsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQztBQTVCRCx3Q0E0QkMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIEhhc2hpQ29ycCwgSW5jXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTVBMLTIuMFxuaW1wb3J0IHtcbiAgUHJvdmlkZXJTY2hlbWEsXG4gIEJsb2NrVHlwZSxcbiAgQXR0cmlidXRlVHlwZSxcbiAgU2NoZW1hLFxufSBmcm9tIFwiQGNka3RmL2NvbW1vbnNcIjtcbmltcG9ydCB7IGdldEZ1bGxQcm92aWRlck5hbWUgfSBmcm9tIFwiLi9wcm92aWRlclwiO1xuaW1wb3J0IHsgUHJvZ3JhbVNjb3BlIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuZnVuY3Rpb24gZ2V0UmVzb3VyY2VBdFBhdGgoc2NoZW1hOiBQcm92aWRlclNjaGVtYSwgcGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdChcIi5cIik7XG5cbiAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpIHtcbiAgICAvLyBUb28gc2hvcnQgdG8gYmUgYSB2YWxpZCBwYXRoXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBpc0RhdGFTb3VyY2UgPSBwYXJ0c1swXSA9PT0gXCJkYXRhXCI7XG4gIGlmIChpc0RhdGFTb3VyY2UpIHtcbiAgICBwYXJ0cy5zaGlmdCgpO1xuICB9XG5cbiAgY29uc3QgcHJvdmlkZXJOYW1lID0gcGFydHMuc2hpZnQoKSBhcyBzdHJpbmc7XG4gIGNvbnN0IHJlc291cmNlTmFtZSA9IHBhcnRzLnNoaWZ0KCkgYXMgc3RyaW5nO1xuXG4gIGNvbnN0IGZ1bGxQcm92aWRlck5hbWUgPSBnZXRGdWxsUHJvdmlkZXJOYW1lKHNjaGVtYSwgcHJvdmlkZXJOYW1lKTtcbiAgLy8gSGFjazogSW4gdGhlIGNhc2Ugb2YgJ2V4dGVybmFsJywgdGhlIG5hbWUgb2YgdGhlIGRhdGEgc291cmNlICdleHRlcm5hbCcgZG9lc24ndCBoYXZlIGEgcHJlZml4XG4gIC8vIHNvIHdlIHJlcGVhdCB0aGUgbmFtZSBhcyBib3RoIHByb3ZpZGVyIHByZWZpeCBhbmQgdGhlIGRhdGEgc291cmNlIG5hbWVcbiAgY29uc3QgZnVsbFJlc291cmNlTmFtZSA9XG4gICAgcHJvdmlkZXJOYW1lID09PSByZXNvdXJjZU5hbWVcbiAgICAgID8gcHJvdmlkZXJOYW1lXG4gICAgICA6IGAke3Byb3ZpZGVyTmFtZX1fJHtyZXNvdXJjZU5hbWV9YDtcblxuICBpZiAoIWZ1bGxQcm92aWRlck5hbWUpIHtcbiAgICAvLyBObyBwcm92aWRlciBmb3VuZCB3aXRoIHRoYXQgbmFtZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgcHJvdmlkZXIgPSBzY2hlbWEucHJvdmlkZXJfc2NoZW1hcz8uW2Z1bGxQcm92aWRlck5hbWVdO1xuXG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICAvLyBDb3VsZCBub3QgZmluZCBwcm92aWRlclxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHJlc291cmNlTmFtZS5lbmRzV2l0aChcIlByb3ZpZGVyXCIpKSB7XG4gICAgLy8gVGhpcyBpcyBhIHByb3ZpZGVyXG4gICAgcmV0dXJuIHsgcmVzb3VyY2U6IHByb3ZpZGVyLnByb3ZpZGVyLCBwYXJ0cyB9O1xuICB9XG5cbiAgY29uc3QgcmVzb3VyY2VzID0gaXNEYXRhU291cmNlXG4gICAgPyBwcm92aWRlci5kYXRhX3NvdXJjZV9zY2hlbWFzXG4gICAgOiBwcm92aWRlci5yZXNvdXJjZV9zY2hlbWFzO1xuXG4gIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VzW2Z1bGxSZXNvdXJjZU5hbWVdO1xuICBpZiAoIXJlc291cmNlKSB7XG4gICAgLy8gQ291bGQgbm90IGZpbmQgcmVzb3VyY2VcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7IHJlc291cmNlLCBwYXJ0cyB9O1xufVxuXG5mdW5jdGlvbiBmaW5kVHlwZShcbiAgaXRlbTogU2NoZW1hIHwgQmxvY2tUeXBlIHwgQXR0cmlidXRlVHlwZSxcbiAgcGFydHM6IHN0cmluZ1tdXG4pOiBTY2hlbWEgfCBCbG9ja1R5cGUgfCBBdHRyaWJ1dGVUeXBlIHwgbnVsbCB7XG4gIGlmICghcGFydHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICBjb25zdCBbY3VycmVudFBhcnQsIC4uLm90aGVyUGFydHNdID0gcGFydHM7XG5cbiAgLy8gUHJvbWl0aXZlIGF0dHJpYnV0ZXMgY2FuIGJlIHJldHVybmVkIGRpcmVjdGx5XG4gIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgLy8gQ29tcGxleCBhdHRyaWJ1dGVzXG4gIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgaWYgKGl0ZW1bMF0gPT09IFwic2V0XCIgfHwgaXRlbVswXSA9PT0gXCJsaXN0XCIpIHtcbiAgICAgIGlmIChjdXJyZW50UGFydCA9PT0gXCJbXVwiKSB7XG4gICAgICAgIHJldHVybiBmaW5kVHlwZShpdGVtWzFdLCBvdGhlclBhcnRzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRyeWluZyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSBvbiBhIGxpc3RcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpdGVtWzBdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoY3VycmVudFBhcnQgPT09IFwiW11cIikge1xuICAgICAgICAvLyBUcnlpbmcgdG8gYWNjZXNzIGEgcHJvcGVydHkgb24gYSBsaXN0XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmluZFR5cGUoaXRlbVsxXVtjdXJyZW50UGFydF0sIG90aGVyUGFydHMpO1xuICAgIH1cblxuICAgIGlmIChpdGVtWzBdID09PSBcIm1hcFwiKSB7XG4gICAgICAvLyBXZSBkb24ndCBjYXJlIHdoYXQgdGhlIGtleSBpc1xuICAgICAgcmV0dXJuIGZpbmRUeXBlKGl0ZW1bMV0sIG90aGVyUGFydHMpO1xuICAgIH1cblxuICAgIC8vIFVua25vd24gdHlwZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgd2UgYXJlIG5vdCBpbiBhbiBhdHRyaWJ1dGUsIHdlIGNhbiBpZ25vcmUgdGhlIFtdIChzaW5jZSBtYXhfaXRlbT0xIHBhcnRzIGRvbid0IGhhdmUgW10sIHNvIHdlIGp1c3QgaWdub3JlIGl0KVxuICBpZiAoY3VycmVudFBhcnQgPT09IFwiW11cIikge1xuICAgIHJldHVybiBmaW5kVHlwZShpdGVtLCBvdGhlclBhcnRzKTtcbiAgfVxuXG4gIC8vIEJsb2NrXG4gIGlmIChpdGVtLmJsb2NrKSB7XG4gICAgLy8gRmluZCBibG9jayB0eXBlIGluIGJsb2NrXG4gICAgaWYgKGl0ZW0uYmxvY2suYmxvY2tfdHlwZXMpIHtcbiAgICAgIGNvbnN0IGJsb2NrVHlwZSA9IGl0ZW0uYmxvY2suYmxvY2tfdHlwZXNbY3VycmVudFBhcnRdO1xuICAgICAgaWYgKGJsb2NrVHlwZSkge1xuICAgICAgICByZXR1cm4gZmluZFR5cGUoYmxvY2tUeXBlLCBvdGhlclBhcnRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaW5kIGF0dHJpYnV0ZSBpbiBibG9ja1xuICAgIGlmIChpdGVtLmJsb2NrLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGl0ZW0uYmxvY2suYXR0cmlidXRlc1tjdXJyZW50UGFydF07XG4gICAgICBpZiAoYXR0cmlidXRlICYmIGF0dHJpYnV0ZS50eXBlKSB7XG4gICAgICAgIHJldHVybiBmaW5kVHlwZShhdHRyaWJ1dGUudHlwZSwgb3RoZXJQYXJ0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ291bGQgbm90IGZpbmQgdGhlIHR5cGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUeXBlQXRQYXRoKFxuICBzY2hlbWE6IFByb3ZpZGVyU2NoZW1hLFxuICBwYXRoOiBzdHJpbmdcbik6IFNjaGVtYSB8IEJsb2NrVHlwZSB8IEF0dHJpYnV0ZVR5cGUgfCBudWxsIHtcbiAgY29uc3QgcmVzb3VyY2VTY2hlbWEgPSBnZXRSZXNvdXJjZUF0UGF0aChzY2hlbWEsIHBhdGgpO1xuXG4gIGlmICghcmVzb3VyY2VTY2hlbWEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCB7IHJlc291cmNlLCBwYXJ0cyB9ID0gcmVzb3VyY2VTY2hlbWE7XG4gIHJldHVybiBmaW5kVHlwZShyZXNvdXJjZSwgcGFydHMpO1xufVxuXG5leHBvcnQgY29uc3QgaXNNYXBBdHRyaWJ1dGUgPSAoXG4gIGF0dHJpYnV0ZTogU2NoZW1hIHwgQXR0cmlidXRlVHlwZSB8IEJsb2NrVHlwZSB8IG51bGxcbikgPT4gKEFycmF5LmlzQXJyYXkoYXR0cmlidXRlKSA/IGF0dHJpYnV0ZVswXSA9PT0gXCJtYXBcIiA6IGZhbHNlKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlc2lyZWRUeXBlKFxuICBzY29wZTogUHJvZ3JhbVNjb3BlLFxuICBwYXRoOiBzdHJpbmdcbik6IEF0dHJpYnV0ZVR5cGUge1xuICBjb25zdCBhdHRyaWJ1dGVPckJsb2NrVHlwZSA9IGdldFR5cGVBdFBhdGgoc2NvcGUucHJvdmlkZXJTY2hlbWEsIHBhdGgpO1xuXG4gIC8vIEF0dHJpYnV0ZSB0eXBlIGlzIG5vdCBkZWZpbmVkXG4gIGlmICghYXR0cmlidXRlT3JCbG9ja1R5cGUpIHtcbiAgICByZXR1cm4gXCJkeW5hbWljXCI7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgYXR0cmlidXRlIHR5cGVcbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVPckJsb2NrVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBhdHRyaWJ1dGVPckJsb2NrVHlwZTtcbiAgfVxuXG4gIC8vIENvbXBsZXggYXR0cmlidXRlIHR5cGVcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cmlidXRlT3JCbG9ja1R5cGUpKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZU9yQmxvY2tUeXBlO1xuICB9XG5cbiAgLy8gU2NoZW1hXG4gIGlmIChcInZlcnNpb25cIiBpbiBhdHRyaWJ1dGVPckJsb2NrVHlwZSkge1xuICAgIHJldHVybiBcImR5bmFtaWNcIjtcbiAgfVxuXG4gIC8vIEJsb2NrIHR5cGVcbiAgcmV0dXJuIFwiZHluYW1pY1wiO1xufVxuIl19